= TO-DO =

== Known bugs ==

* Weird combinations of Subversion tag creation followed by tag delete
  and renaming operations can produce content-mismatch failures
  detectable by repotool compare. In the test suite, this problem is
  exhibited by branchreplace.svn, emptyfrom.svn, references.svn.

* Also see https://gitlab.com/esr/reposurgeon/issues for two minor problems.

* The pathological-load Hg cases fail, that should be fixed.  They
  succeeded in Python. "make REPOSURGEON=pyreposurgeon hg-regress-patho"
  exhibits correct behavior.

== Tuning for speed ==

The goal of moving the code to Golang is to improve conversion
performance on large repositories by an order of magnitude or more,
with the horrible example being the GCC subversion history.  Trial
runs with the Python version were taking 9-10 hours!

If you are already a Go expert, you can help by tuning for speed.  The
most important single operations to speed up are fast-import stream
reads and Subversion dump stream reads.

First thing to do is make a test load.  The reposurgeon history itself is
large enough to be a useful one.  So:

$ goreposurgeon "read ." "write >reposurgeon.fi"

The ability to dump profile data is built into reposurgeon itself:

$ goreposurgeon "verbose 1" "profile reposurgeon.prof" "read <rs.fi" "profile"

Once you have the profile data you can sic the profile viewer on it.
Have graphviz installed and do

go tool pprof goreposurgeon rs.prof

There are lots of ways to explore the data but the single most interesting one
is to enter "web" and look at your browser. The size of each box is proportional
to the number of profiler samples it appears in.  "top10" gives you the same
data in tabular form:

      flat  flat%   sum%        cum   cum%
     1.41s 22.45% 22.45%      1.43s 22.77%  syscall.Syscall
     1.11s 17.68% 40.13%      2.22s 35.35%  runtime.scanobject
     0.75s 11.94% 52.07%      0.75s 11.94%  runtime.greyobject
     0.58s  9.24% 61.31%      0.58s  9.24%  runtime.memmove

This is telling us that (a) disk I/O (syscall.Syscall) is slow, but garbage
collection overhead dominates (runtime.scanobject and runtime.greyobject, 47%).
That runtime.memmove is probably array copies during append operations.

To go faster we need to exercise the allocator less.  In a way this is
good news - it suggests we don't have a big-O/algorithmic problem.

The obvious thing to do first is a search-and-destroy for heap escapes.
We can't avoid doing a lot of allocation; what we can do is avoid creating
lots of short-lived heap objects that will churn heap storage and trigger GC.

Some references:

https://blog.golang.org/profiling-go-programs

https://github.com/google/pprof/blob/master/doc/README.md

https://www.signalfx.com/blog/a-pattern-for-optimizing-go-2/

http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html

https://github.com/golang/go/wiki/Performance
