<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE refentry PUBLIC
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Oct 31 2010</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <command>reposurgeon</command> is to enable risky
operations that VCSes (version-control systems) don't want to let you
do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing and splitting commits, (d) removing files and
subtrees from repo history, (e) merging or grafting two or more repos,
and (f) cutting a repo in two by cutting a parent-child link,
preserving the branch structure of both child repos.</para>

<para>A major use of reposurgeon is to assist a human operator to
perform higher-quality conversions among version control systems than
can be achieved with fully automated converters.</para>

<para>The original motivation for <command>reposurgeon</command> was
to clean up artifacts created by repository conversions.  It was
foreseen that the tool would also have applications when code needs to
be removed from repositories for legal or policy reasons.</para>

<para>To keep <command>reposurgeon</command> simple and flexible, it
normally does not do its own repository reading and writing.  Instead, it
relies on being able to parse and emit the command streams created by
git-fast-export and read by git-fast-import.  This means that it can
be used on any version-control system that has both fast-export
and fast-import utilities. The git-import stream format also implicitly
defines a common language of primitive operations for
<command>reposurgeon</command> to speak.</para>

<para>Fully supported systems (those for which
<command>reposurgeon</command> can both read and write repositories)
include git, hg, bzr, svn, darcs, bk, RCS, and SRC.  For a complete list, with
dependencies and technical notes, type <command>prefer</command> to
the <command>reposurgeon</command> prompt.</para>

<para>Writing to the file-oriented systems RCS and SRC is done via
<citerefentry><refentrytitle>rcs-fast-import</refentrytitle><manvolnum>1</manvolnum></citerefentry>
and has some serious limitations because those systems cannot
represent all the metadata in a git-fast-export stream. Consult that
tool's documentation for details and partial workarounds.</para>

<para>Writing Subversion repositories also has some
significant limitations, discussed in the section on <link
linkend="subversion">Working With Subversion</link>.</para>

<para>Fossil repository files can be read in using the
<option>--format=fossil</option> option of the <command>read</command>
command and written out with the <option>--format=fossil</option> option of
the <command>write</command>. Ignore patterns are not translated
in either direction.</para>

<para>CVS is supported for read only, not write.  For CVS,
<command>reposurgeon</command> must be run from within a repository
directory (one with a CVSROOT subdirectory). Each module becomes
a subdirectory in the the <command>reposurgeon</command>
representation of the change history.</para>

<para>In order to deal with version-control systems that do not have
fast-export equivalents, <command>reposurgeon</command> can also host
extractor code that reads repositories directly.  For each
version-control system supported through an extractor,
<command>reposurgeon</command> uses a small amount of knowledge about
the system's command-line tools to (in effect) replay repository
history into an input stream internally. Repositories under systems
supported through extractors can be read by
<command>reposurgeon</command>, but not modified by it.  In
particular, <command>reposurgeon</command> can be used to move a
repository history from any VCS supported by an extractor to any VCS
supported by a normal importer/exporter pair.</para>

<para>Mercurial repository reading is implemented with an extractor
class; writing is handled with the stock "hg fastimport" command.  A
test extractor exists for git, but is normally disabled in favor of
the regular exporter.</para>

<para>For guidance on the pragmatics of repository conversion, see the
<ulink url="http://www.catb.org/esr/dvcs-migration-guide.html">DVCS
Migration HOWTO</ulink>.</para>
</refsect1>

<refsect1 id='warning'><title>SAFETY WARNINGS</title>

<para><command>reposurgeon</command> is a sharp enough tool to cut
you.  It takes care not to ever write a repository in an actually
inconsistent state, and will terminate with an error message rather
than proceed when its internal data structures are confused.  However,
there are lots of things you can do with it - like altering stored
commit timestamps so they no longer match the commit sequence - that
are likely to cause havoc after you're done.  Proceed with caution and
check your work.</para>

<para>Also note that, if your DVCS does the usual thing of making
commit IDs a cryptographic hash of content and parent links, editing a
publicly-accessible repository with this tool would be a bad idea. All
of the surgical operations in <command>reposurgeon</command> will
modify the hash chains.</para>

<para>Please also see the notes on system-specific issues under <xref
linkend='limitations'/>.</para>

</refsect1>

<refsect1 id='options'><title>OPERATION</title>

<para>The program can be run in one of two modes, either as an
interactive command interpreter or in batch mode to execute commands
given as arguments on the <command>reposurgeon</command> invocation
line. The only differences between these modes are (1) the interactive
one begins by turning on the 'verbose 1' option, (2) in batch mode all
errors (including normally recoverable errors in selection-set syntax)
are fatal, and (3) each command-line argument beginning with
<quote>--</quote> has that stripped off (which, in particular means
that --help and --version will work as expected). Also, in interactive
mode, Ctrl-P and Ctrl-N will be available to scroll through your
command history and tab completion of both command keywords and name
arguments (wherever that makes semantic sense) is available.</para>

<para>A git-fast-import stream consists of a sequence of commands
which must be executed in the specified sequence to build the repo; to
avoid confusion with <command>reposurgeon</command> commands
we will refer to the stream commands as <emphasis>events</emphasis> in
this documentation.  These events are implicitly numbered from 1
upwards.  Most commands require specifying a selection of event
sequence numbers so <command>reposurgeon</command> will know
which events to modify or delete.</para>

<para>For all the details of event types and semantics, see the
<citerefentry><refentrytitle>git-fast-import</refentrytitle><manvolnum>1</manvolnum></citerefentry>
manual page; the rest of this paragraph is a quick start for the
impatient. Most events in a stream are <emphasis
role="bold">commits</emphasis> describing revision states of the
repository; these group together under a single change comment one or
more <emphasis role="bold">fileops</emphasis> (file operations), which
usually point to <emphasis role="bold">blobs</emphasis> that are
revision states of individual files. A fileop may also be a delete
operation indicating that a specified previously-existing file was
deleted as part of the version commit; there are a couple of other
special fileop types of lesser importance.</para>

<para>Commands to <command>reposurgeon</command> consist of a
command keyword, sometimes preceded by a selection set, sometimes
followed by whitespace-separated arguments. It is often possible to
omit the selection-set argument and have it default to something
reasonable.</para>

<para>Here are some motivating examples.  The commands will be
explained in more detail after the description of selection
syntax.</para>

<programlisting>
:15 edit               ;; edit the object associated with mark :15

edit                   ;; edit all editable objects

29..71 list            ;; list summary index of events 29..71

236..$ list            ;; List events from 236 to the last

&lt;#523&gt; inspect         ;; Look for commit #523; they are numbered 
                       ;; 1-origin from the beginning of the repository.

&lt;2317&gt; inspect         ;; Look for a tag with the name 2317, a tip commit
                       ;; of a branch named 2317, or a commit with legacy ID
                       ;; 2317. Inspect what is found. A plain number is
                       ;; probably a legacy ID inherited from a Subversion
                       ;; revision number.

/regression/ list      ;; list all commits and tags with comments or
                       ;; committer headers or author headers containing
                       ;; the string "regression"

1..:97 &amp; =T delete     ;; delete tags from event 1 to mark 97

[Makefile] inspect     ;; Inspect all commits with a file op touching Makefile
                       ;; and all blobs referred to in a fileop
                       ;; touching Makefile.

:46 tip                ;; Display the branch tip that owns commit :46.

@dsc(:55) list         ;; Display all commits with ancestry tracing to :55 

@min([.gitignore]) remove .gitignore delete
                       ;; Remove the first .gitignore fileop in the repo.
</programlisting>


<refsect2 id='selections'><title>SELECTION SYNTAX</title>

<para>A selection set is ordered; that is, any given element may occur
only one, and the set is ordered by when its members were first added.</para>

<para>The selection-set specification syntax is an expression-oriented
minilanguage.  The most basic term in this language is a
<firstterm>location</firstterm>. The following sorts of primitive locations
are supported:</para>

<variablelist>
<varlistentry>
<term><firstterm>event numbers</firstterm></term>
<listitem><para>A plain numeric literal is interpreted as a 1-origin
event-sequence number.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>marks</firstterm></term>
<listitem><para>A numeric literal preceded by a colon is interpreted
as a mark; see the import stream format documentation for explanation
of the semantics of marks.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>tag and branch names</firstterm></term>
<listitem>
<para>The basename of a branch (including branches in the refs/tags
namespace) refers to its tip commit.  The name of a tag is equivalent
to its mark (that of the tag itself, not the commit it refers to). Tag
and branch locations are bracketed with &lt; &gt; (angle brackets) to
distinguish them from command keywords.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><firstterm>legacy IDs</firstterm></term>
<listitem>
<para>If the contents of name brackets (&lt; &gt;) does not match a tag or
branch name, the interpreter next searches legacy IDs of commits.  This
is especially useful when you have imported a Subversion dump; it
means that commits made from it can be referred to by their corresponding
Subversion revision numbers.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><firstterm>commit numbers</firstterm></term>
<listitem><para>A numeric literal within  name brackets (&lt; &gt;)
preceded by # is interpreted as a 1-origin
commit-sequence number.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>$</firstterm></term>
<listitem><para>Refers to the last event.</para></listitem>
</varlistentry>
</variablelist>

<para>These may be grouped into sets in the following ways:</para>

<variablelist>
<varlistentry>
<term><firstterm>ranges</firstterm></term>
<listitem><para>A range is two locations separated by "..", and is
the set of events beginning at the left-hand location and ending at the
right-hand location (inclusive).</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>lists</firstterm></term>
<listitem><para>Comma-separated lists of locations and ranges are
accepted, with the obvious meaning.</para></listitem>
</varlistentry>
</variablelist>

<para>There are some other ways to construct event sets:</para>

<variablelist>
<varlistentry>
<term><firstterm>visibility sets</firstterm></term>
<listitem>
<para>A visibility set is an expression specifying a set of event
types. It will consist of a leading equal sign, followed by type
letters. These are the type letters:</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='3' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <colspec colname='c3'/>
    <tbody>
      <row>
        <entry align='center'>B</entry>
        <entry align='center'>blobs</entry>
        <entry><para>Most default selection sets exclude blobs; they
        have to be manipulated through the commits they are attached
        to.</para></entry>
      </row>
      <row>
        <entry align='center'>C</entry>
        <entry align='center'>commits</entry>
        <entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>D</entry>
        <entry align='center'>all-delete commits</entry>
        <entry><para>These are artifacts produced by some older
	repository-conversion tools.</para></entry>
      </row>
      <row>
        <entry align='center'>H</entry>
        <entry align='center'>head (branch tip) commits</entry>
        <entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>O</entry>
        <entry align='center'>orphaned (parentless) commits</entry>
        <entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>U</entry>
        <entry align='center'>commits with callouts as parents</entry>
        <entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>Z</entry>
        <entry align='center'>commits with no fileops</entry>
        <entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>M</entry>
        <entry align='center'>merge (multi-parent) commits</entry>
        <entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>F</entry>
        <entry align='center'>fork (multi-child) commits</entry>
        <entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>L</entry>
        <entry align='center'><para>commits with unclean multi-line comments
        (without a separating empty line after the first)</para></entry>
        <entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>I</entry>
        <entry align='center'><para>commits for which metadata cannot be
        decoded to UTF-8</para></entry>
        <entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>T</entry>
        <entry align='center'>tags</entry>
        <entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>R</entry>
        <entry align='center'>resets</entry>
        <entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>P</entry>
        <entry align='center'>Passthrough</entry>
        <entry><para>All event types simply passed through,
        including comments, <command>progress</command> commands,
        and <command>checkpoint</command> commands.</para></entry>
      </row>
      <row>
        <entry align='center'>N</entry>
        <entry align='center'>Legacy IDs</entry>
        <entry><para>Any string matching a cookie (legacy-ID) format.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

</listitem>
</varlistentry>
<varlistentry>
<term><firstterm>references</firstterm></term>
<listitem><para>A reference name (bracketed by angle brackets) resolves
to a single object, either a commit or tag.</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='2' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <thead>
      <row>
        <entry align='center'>type</entry>
        <entry align='center'>interpretation</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry align='center'>tag name</entry>
        <entry align='center'>annotated tag with that name</entry>
      </row>
      <row>
        <entry align='center'>branch name</entry>
        <entry align='center'>the branch tip commit</entry>
      </row>
      <row>
        <entry align='center'>legacy ID</entry>
        <entry align='center'>commit with that legacy ID</entry>
      </row>
      <row>
        <entry align='center'>assigned name</entry>
        <entry align='center'>name equated to a selection by assign</entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>
<para>Note that if an annotated tag and a branch have the same name foo,
&lt;foo&gt; will resolve to the tag rather than the branch tip commit.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><firstterm>dates and action stamps</firstterm></term>
<listitem><para>A date or action stamp in angle brackets resolves
to a selection set of all matching commits.</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='2' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <thead>
      <row>
        <entry align='center'>type</entry>
        <entry align='center'>interpretation</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry align='center'>RFC3339 timestamp</entry>
        <entry align='center'>commit or tag with that time/date</entry>
      </row>
      <row>
        <entry align='center'>action stamp (timestamp!email)</entry>
        <entry align='center'><para>commits or tags with that timestamp and
        author (or committer if no author).</para></entry>
      </row>
      <row>
        <entry align='center'>yyyy-mm-dd part of RFC3339 timestamp</entry>
        <entry align='center'>all commits and tags with that date</entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>
<para>To refine the match to a single commit, use a 1-origin index
suffix separated  by '#'. Thus "&lt;2000-02-06T09:35:10Z&gt;" can
match multiple commits, but "&lt;2000-02-06T09:35:10Z#2&gt;" matches
only the second in the set.</para>

</listitem>
</varlistentry>
<varlistentry>
<term><firstterm>text search</firstterm></term>
<listitem><para>A text search expression is a Python regular expression
surrounded by forward slashes (to embed a forward slash in it, use a
Python string escape such as \x2f).</para>

<para>A text search normally matches against the comment fields of commits and
annotated tags, or against their author/committer names, or against
the names of tags; also the text of passthrough objects.</para>

<para>The scope of a text search can be changed with qualifier
letters after the trailing slash.  These are as follows:</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='2' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <thead>
      <row>
        <entry align='center'>letter</entry>
        <entry align='center'>interpretation</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry align='center'>a</entry>
        <entry align='center'>author name in commit</entry>
      </row>
      <row>
        <entry align='center'>b</entry>
        <entry align='center'><para>branch name in commit; also matches
        blobs referenced by commits on matching branches, and tags
        which point to commmits on patching branches.</para></entry>
      </row>
      <row>
        <entry align='center'>c</entry>
        <entry align='center'>comment text of commit or tag</entry>
      </row>
      <row>
        <entry align='center'>r</entry>
        <entry align='center'>committish reference in tag or reset</entry>
      </row>
     <row>
        <entry align='center'>p</entry>
        <entry align='center'>text in passthrough</entry>
      </row>
      <row>
        <entry align='center'>t</entry>
        <entry align='center'>tagger in tag</entry>
      </row>
      <row>
        <entry align='center'>n</entry>
        <entry align='center'>name of tag</entry>
      </row>
      <row>
        <entry align='center'>B</entry>
        <entry align='center'>blob content</entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>Multiple qualifier letters can add more search scopes.</para>

<para>(The <quote>b</quote> qualifier replaces the branchset syntax
in earlier versions of <command>reposurgeon</command>.)</para>

</listitem>
</varlistentry>
<varlistentry>
<term><firstterm>paths</firstterm></term>
<listitem>
<para>A "path expression" enclosed in square brackets resolves to the
set of all commits and blobs related to a path matching the given
expression. The path expression itself is either a path literal or a
regular expression surrounded by slashes. Immediately after the
trailing / of a path regexp you can put any number of the following
characters which act as flags: 'a', 'c', 'D', "M', 'R', 'C', 'N'.</para>

<para>By default, a path is related to a commit if the latter has a
fileop that touches that file path - modifies that change it, deletes
that remove it, renames and copies that have it as a source or
target. When the 'c' flag is in use the meaning changes: the paths
related to a commit become all paths that would be present in a
checkout for that commit.</para>

<para>A path literal matches a commit if and only if the path literal is
exactly one of the paths related to the commit (no prefix or suffix operation
is done). In particular a path literal won't match if it corresponds to a
directory in the chosen repository.</para>

<para>A regular expression matches a commit if it matches any path related to
the commit anywhere in the path. You can use '^' or '$' if you want the
expression to only match at the beginning or end of paths.  When the 'a' flag is
in use, the path expression selects commits whose every path matches the regular
expression. This is not always a subset of commits selected without the 'a'
flag because it also selects commits with no related paths (e.g. empty commits,
deletealls and commits with empty trees). If you want to avoid those, you can
use e.g. '[/regex/] &amp; [/regex/a]'.</para>

<para>The flags 'D', "M', 'R', 'C', 'N' restrict match checking to the
corresponding fileop types.  Note that this means an 'a' match is
easier (not harder) to achieve.  These are no-ops when used with 'c'.</para>

<para>A path or literal matches a blob if it matches any path that
appeared in a modification fileop that referred to that blob. To
select purely matching blobs or matching commits, compose a path
expression with =B or =C.</para>

<para>If you need to embed '[^/]' into your regular expression (e.g. to
express "all characters but a slash") you can use a Python string
escape such as \x2f.</para>

</listitem>
</varlistentry>
<varlistentry>
<term><firstterm>function calls</firstterm></term>
<listitem>
<para>The expression language has named special functions.  The sequence for
a named function is <quote>@</quote> followed by a function name,
followed by an argument in parentheses. Presently the following
functions are defined:</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='2' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <thead>
      <row>
        <entry align='center'>name</entry>
        <entry align='center'>interpretation</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry align='center'>min</entry>
        <entry align='center'>minimum member of a selection set</entry>
      </row>
      <row>
        <entry align='center'>max</entry>
        <entry align='center'>maximum member of a selection set</entry>
      </row>
      <row>
        <entry align='center'>amp</entry>
        <entry align='center'><para>nonempty selection set becomes all
        objects, empty set is returned empty</para></entry>
      </row>
      <row>
        <entry align='center'>par</entry>
        <entry align='center'><para>all parents of commits in the
	argument set</para></entry>
      </row>
      <row>
        <entry align='center'>chn</entry>
        <entry align='center'><para>all children of commits in the
	argument set</para></entry>
      </row>
      <row>
        <entry align='center'>dsc</entry>
        <entry align='center'><para>all commits descended from the
	argument set (argument set included)</para></entry>
      </row>
      <row>
        <entry align='center'>anc</entry>
        <entry align='center'><para>all commits whom the argument set is
	descended from (argument set included)</para></entry>
      </row>
      <row>
        <entry align='center'>pre</entry>
        <entry align='center'><para>events before the argument set;
        empty if the argument set includes the first
        event.</para></entry>
      </row>
      <row>
        <entry align='center'>suc</entry>
        <entry align='center'><para>events after the argument set;
        empty if the argument set includes the last
        event.</para></entry>
      </row>
      <row>
        <entry align='center'>srt</entry>
        <entry align='center'><para>sort the argument set
	by event number.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

</listitem>
</varlistentry>
</variablelist>

<para>Set expressions may be combined with the operators | and &amp;;
these are, respectively, set union and intersection. The | has lower
precedence than intersection, but you may use parentheses '(' and
')' to group expressions in case there is ambiguity (this replaces the
curly brackets used in older versions of the syntax).</para>

<para>Any set operation may be followed by '?' to add the set
members' neighbors and referents.  This extends the set to include the
parents and children of all commits in the set, and the referents of
any tags and resets in the set. Each blob reference in the set is
replaced by all commit events that refer to it. The '?' can be repeated
to extend the neighborhood depth.  The result of a '?' extension is
sorted so the result is in ascending order.</para>

<para>Do set negation with prefix ~; it has higher precedence than
&amp; and | but lower than ?</para>

</refsect2>
<refsect2 id='import-export'><title>IMPORT AND EXPORT</title>

<para><command>reposurgeon</command> can hold multiple repository
states in core.  Each has a name.  At any given time, one may be selected
for editing. Commands in this group import repositories, export them,
and manipulate the in-core list and the selection.</para>

<variablelist>
<varlistentry>
<term><command>read</command>
        [--format=fossil]
        [<emphasis>directory</emphasis>|<emphasis>-</emphasis>|<emphasis>&lt;infile</emphasis>]
</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no arguments
does this in the current directory. If output is redirected to a
plain file, it will be read in as a fast-import stream or Subversion
dumpfile. With an argument of <quote>-</quote>, this command reads a
fast-import stream or Subversion dumpfile from standard input (this
will be useful in filters constructed with command-line
arguments).</para>

<para>If the contents is a fast-import stream, any "cvs-revision" property
on a commit is taken to be a newline-separated list of CVS revision cookies
pointing to the commit, and used for reference lifting.</para>

<para>If the contents is a fast-import stream, any "legacy-id" property
on a commit is taken to be a legacy ID token pointing to the commit,
and used for reference-lifting.</para>

<para>If the read location is a git repository and contains a
<filename>.git/cvsauthors</filename> file (such as is left in place
by <command>git cvsimport -A</command>) that file will be read in as
if it had been given to the <command>authors read</command> command.</para>

<para>If the read location is a directory, and its repository
subdirectory has a file named <filename>legacy-map</filename>, that file
will be read as though passed to a <filename>legacy read</filename>
command.</para>

<para>If the read location is a file and the <option>--format=fossil</option>
is used, the file is interpreted as a Fossil repository.</para>

<para>The just-read-in repo is added to the list of loaded
repositories and becomes the current one, selected for surgery. If it
was read from a plain file and the file name ends with one of the
extensions <filename>.fi</filename> or <filename>.svn</filename>, that
extension is removed from the load list name.</para>

<para>Note: this command does not take a selection set.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>write</command>
        [--legacy] [--format=fossil] [--noincremental] [--callout]
        [<emphasis>&gt;outfile</emphasis>|<emphasis>-</emphasis>]
</term>
<listitem>
<para>Dump selected events as a fast-import stream representing the
edited repository; the default selection set is all events. Where to
dump to is standard output if there is no argument or the argument is
'-', or the target of an output redirect. </para>

<para>Alternatively, if there is no redirect and the argument names a
directory, the repository is rebuilt into that directory, with any
selection set being ignored; if that target directory is nonempty its
contents are backed up to a save directory.</para>

<para>If the write location is a file and the
<option>--format=fossil</option> is used, the file is written in
Fossil repository format.</para>

<para>With the <option>--legacy</option> option, the Legacy-ID of
each commit is appended to its commit comment at write time. This
option is mainly useful for debugging conversion edge cases.</para>

<para>If you specify a partial selection set such that some commits
are included but their parents are not, the output will include
incremental dump cookies for each branch with an origin outside the
selection set, just before the first reference to that branch in a
commit.  An incremental dump cookie looks like "refs/heads/foo^0" and
is a clue to export-stream loaders that the branch should be glued to
the tip of a pre-existing branch of the same name.  The
<option>--noincremental</option> option suppresses this behavior.</para>

<para>When you specify a partial selection set, including a commit
object forces the inclusion of every blob to which it refers and
every tag that refers to it.</para>

<para>Specifying a partial selection may cause a situation in which
some parent marks in merges don't correspond to commits present in the
dump.  When this happens and <option>--callout</option> option was
specified, the write code replaces the merge mark with a callout, the
action stamp of the parent commit; otherwise the parent mark is
omitted.  Importers will fail when reading a stream dump with callouts;
it is intended to be used by the <command>graft</command>
command.</para>

<para>Specifying a write selection set with gaps in it is allowed
but unlikely to lead to good results if it is loaded by an importer.</para>

<para>Property extensions will be be omitted from the output if the
importer for the preferred repository type cannot digest them.</para>

<para>Note: to examine small groups of commits without the progress
meter, use <command>inspect</command>.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>choose</command>
        [<emphasis>reponame</emphasis>]
</term>
<listitem>
<para>Choose a named repo on which to operate.  The name of a repo is
normally the basename of the directory or file it was loaded from, but
repos loaded from standard input are "unnamed".
<command>reposurgeon</command> will add a disambiguating
suffix if there have been multiple reads from the same source.</para>

<para>With no argument, lists the names of the currently stored
repositories and their load times.  The second column is '*' for the
currently selected repository, '-' for others.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>drop</command>
        [<emphasis>reponame</emphasis>]
</term>
<listitem>
<para>Drop a repo named by the argument from reposurgeon's list,
freeing the memory used for its metadata and deleting on-disk
blobs. With no argument, drops the currently chosen repo.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>rename</command>
        <emphasis>reponame</emphasis>
</term>
<listitem>
<para>Rename the currently chosen repo; requires an argument.  Won't
do it if there is already one by the new name.
</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id='rebuild'><title>REBUILDS IN PLACE</title>

<para><command>reposurgeon</command> can rebuild an altered repository
in place.  Untracked files are normally saved and restored when the
contents of the new repository is checked out (but see the
documentation of the <quote>preserve</quote> command for a
caveat).</para>

<variablelist>
<varlistentry>
<term><command>rebuild</command>
        [<emphasis>directory</emphasis>]
</term>
<listitem>
<para> Rebuild a repository from the state held by
<command>reposurgeon</command>.  This command does not take a
selection set.</para>

<para>The single argument, if present,
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import
stream), it defaults to that directory.  If the target directory is
nonempty its contents are backed up to a save directory.  Files and
directories on the repository's preserve list are copied back from the
backup directory after repo rebuild. The default preserve list
depends on the repository type, and can be displayed with the
<command>stats</command> command.</para>

<para>If <command>reposurgeon</command> has a nonempty legacy map,
it will be written to a file named <filename>legacy-map</filename>
in the repository subdirectory as though by a
<filename>legacy write</filename> command. (This will normally
be the case for Subversion and CVS conversions.)</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>preserve</command>
    [<emphasis>file...</emphasis>]
</term>
<listitem>
<para>Add (presumably untracked) files or directories to the repo's
list of paths to be restored from the backup directory after a
<command>rebuild</command>. Each argument, if any, is interpreted as a
pathname.  The current preserve list is displayed afterwards.</para>

<para>It is only necessary to use this feature if your version-control
system lacks a command to list files under version control. Under
systems with such a command (which include git and hg), all files that
are neither beneath the repository dot directory nor under reposurgeon
temporary directories are preserved automatically.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>unpreserve</command>
    [<emphasis>file...</emphasis>]
</term>
<listitem><para>Remove (presumably untracked) files or directories to
the repo's list of paths to be restored from the backup directory
after a <command>rebuild</command>. Each argument, if any, is
interpreted as a pathname.  The current preserve list is displayed
afterwards.</para></listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id='timequakes'><title>TIMEQUAKES AND TIMEBUMPS</title>

<para>Modifying a repository so every commit in it has a unique
timestamp is often a useful thing to do, in order for every commit has
a unique action stamp that can be referred to in surgical
commands.</para>

<variablelist>
<varlistentry>
<term><command>timequake</command></term>
<listitem>
<para>Attempt to hack committer and author time stamps in the
selection set (defaulting to all commits in the repository) to be
unique.  Works by identifying collisions between parent and child,
than incrementing child timestamps so they no longer coincide. Won't
touch commits with multiple parents.</para>

<para>Because commits are checked in ascending order, this logic will
normally do the right thing on chains of three or more commits with
identical timestamps.</para>
 
<para>Any timestamp collisions left after this operation are probably
cross-branch and have to be individually dealt with using 'timebump'
commands.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>timebump</command>
[<emphasis>seconds</emphasis>]
</term>
<listitem>
<para>Bump the committer and author timestamps of commits in the selection
set (defaulting to empty) by one second.   With following integer argument,
that many seconds. Argument may be negative.</para>
</listitem>
</varlistentry>
</variablelist>

<para>Those of you twitchy about "rewriting history" should bear in
mind that the commit stamps in many older repositories were never very
reliable to begin with.</para>

<para>CVS in particular is notorious for shipping client-side
timestamps with timezone and DST issues (as opposed to UTC) that don't
necessary compare well with stamps from different clients of the same
CVS server. Thus, inducing a timequake in a CVS repo seldom produces
effects anywhere near as large than the measurement noise of the
repository's own timestamps.</para>

<para>Subversion was somewhat better about this, as commits were
stamped at the server, but older Subversion repositories often have
sections that predate the era of ubiquitous NTP time.</para>
</refsect2>

<refsect2 id='information'><title>INFORMATION AND REPORTS</title>

<para>Commands in this group report information about the selected
repository.</para>

<para>The output of these commands can individually be redirected to
a named output file. Where indicated in the syntax, you can prefix the
output filename with <quote>&gt;</quote> and give it as a following
argument.  If you use <quote>&gt;&gt;</quote> the file is opened
for append rather than write.</para>

<variablelist>
<varlistentry>
<term><command>list</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem><para>This is the main command for identifying the events
you want to modify.  It lists commits in the selection set by event
sequence number with summary information. The first column is raw
event numbers, the second a timestamp in local time. If the repository
has legacy IDs, they will be displayed in the third column. The
leading portion of the comment follows.
</para></listitem>
</varlistentry>
<varlistentry>
<term><command>stamp</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem><para>Alternative form of listing that displays full action
stamps, usable as references in selections. Supports &gt;
redirection.</para></listitem>
</varlistentry>
<varlistentry>
<term><command>tip</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem><para>Display the branch tip names associated with commits
in the selection set.  These will not necessarily be the same as their
branch fields (which will often be tag names if the repo contains
either annotated or lightweight tags).</para>

<para>If a commit is at a branch tip, its tip is its branch name.  If
it has only one child, its tip is the child's tip.  If it has multiple
children, then if there is a child with a matching branch name its tip
is the child's tip.  Otherwise this function throws a recoverable
error.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>tags</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem><para>
Display tags and resets: three fields, an event number and a type and a name.
Branch tip commits associated with tags are also displayed with the type
field 'commit'. Supports > redirection.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>stats</command>
        [<emphasis>repo-name</emphasis>...]
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem><para>
Report size statistics and import/export method information about
named repositories, or with no argument the currently chosen repository.
</para></listitem>
</varlistentry>
<varlistentry>
<term><command>count</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem><para>
Report a count of items in the selection set. Default set is everything
in the currently-selected repo. Supports &gt; redirection.
</para></listitem>
</varlistentry>
<varlistentry>
<term><command>inspect</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem><para>
Dump a fast-import stream representing selected events to standard
output.  Just like a write, except (1) the progress meter is disabled,
and (2) there is an identifying header before each event dump.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>graph</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem>
<para>Emit a visualization of the commit graph in the DOT markup language
used by the graphviz tool suite.  This can be fed as input to the main
graphviz rendering program
<citerefentry><refentrytitle>dot</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
which will yield a viewable image. Supports &gt; redirection.</para>

<para>You may find a script like this useful:

<programlisting>
graph $1 &gt;/tmp/foo$$
shell dot &lt;/tmp/foo$$ -Tpng | display -; rm /tmp/foo$$
</programlisting>

You can substitute in your own preferred image viewer, of course.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>sizes</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem>
<para>Print a report on data volume per branch; takes a selection set,
defaulting to all events. The numbers tally the size of uncompressed
blobs, commit and tag comments, and other metadata strings (a blob is
counted each time a commit points at it). </para>

<para>The numbers are not an exact measure of storage size: they are
intended mainly as a way to get information on how to efficiently
partition a repository that has become large enough to be
unwieldy.</para>

<para>Supports &gt; redirection.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>lint</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem>
<para>Look for DAG and metadata configurations that may indicate a
problem. Presently checks for: (1) Mid-branch deletes, (2)
disconnected commits, (3) parentless commits, (4) the existence of
multiple roots, (5) committer and author IDs that don't look
well-formed as DVCS IDs, (6) multiple child links with identical
branch labels descending from the same commit, (7) time and
action-stamp collisions.</para>

<para>Options to issue only partial reports are supported; "lint
--options" or "lint -?" lists them.</para>

<para>The options and output format of this command are unstable; they may
change without notice as more sanity checks are added.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><command>when</command>
        &gt;<emphasis>timespec</emphasis>
</term>
<listitem>
<para>Interconvert between git timestamps (integer Unix time plus TZ) and
RFC3339 format.  Takes one argument, autodetects the format.  Useful
when eyeballing export streams.  Also accepts any other supported
date format and converts to RFC3339.
</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id='surgical'><title>SURGICAL OPERATIONS</title>

<para>These are the operations the rest of reposurgeon is designed
to support.</para>

<variablelist>
<varlistentry>
<term><command>squash</command>
        [<emphasis>policy...</emphasis>]
</term>
<listitem>
<para>Combine or delete commits in a selection set of events. The
default selection set for this command is empty. Has no effect on
events other than commits unless the --delete policy is selected;
see the 'delete' command for discussion.</para>

<para>Normally, when a commit is squashed, its file operation list
(and any associated blob references) gets either prepended to the
beginning of the operation list of each of the commit's children or
appended to the operation list of each of the commit's parents. Then
children of a deleted commit get it removed from their parent set and
its parents added to their parent set.</para>

<para> The analogous operation is performed on commit comments, so no
comment text is ever outright discarded.  Exception: comments
consisting of "*** empty log messages ***", as generated by
CVS, are ignored.</para>

<para>The default is to squash forward, modifying children; but see the
list of policy modifiers below for how to change this.</para>

<warning>
<para>It is easy to get the bounds of a squash command wrong, with
confusing and destructive results. Beware thinking you can squash on a
selection set to merge all commits except the last one into the last
one; what you will actually do is to merge all of them to the first
commit <emphasis>after</emphasis> the selected set.</para>
</warning>

<para>Normally, any tag pointing to a combined commit will also be
pushed forward.  But see the list of policy modifiers below for how to
change this.</para>

<para>Following all operation moves, every one of the altered file
operation lists is reduced to a shortest normalized form. The
normalized form detects various combinations of modification,
deletion, and renaming and simplifies the operation sequence as much
as it can without losing any information.</para>

<para>After canonicalization, a file op list may still end up containing
multiple M operations on the same file. Normally the tool utters a
warning when this occurs but does not try to resolve it.</para>

<para>The following modifiers change these policies:</para>

<variablelist>
<varlistentry>
<term><option>--delete</option></term>
<listitem>
<para>Simply discards all file ops and tags associated with deleted commit(s).</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>--coalesce</option></term>
<listitem>
<para>Discard all M operations (and associated blobs) except the last.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>--pushback</option></term>
<listitem>
<para>Append fileops to parents, rather than prepending to children.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>--pushforward</option></term>
<listitem>
<para>Prepend fileops to children. This is the default; it can be
specified in a lift script for explicitness about intentions.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>--tagforward</option></term>
<listitem>
<para>With the "tagforward" modifier, any tag on the deleted commit is pushed
forward to the first child rather than being deleted. This is the
default; it can be specified for explicitness.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>--tagback</option></term>
<listitem>
<para>With the "--tagback" modifier, any tag on the deleted commit is pushed
backward to the first parent rather than being deleted. </para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>--quiet</option></term>
<listitem>
<para>Suppresses warning messages about deletion of commits with
non-delete fileops.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>--complain</option></term>
<listitem>
<para>The opposite of quiet. Can be specified for explicitness.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>--empty-only</option></term>
<listitem>
<para>Complain if a squash operation modifies a nonempty comment.</para>
</listitem>
</varlistentry>
</variablelist>

<para>Under any of these policies except <quote>--delete</quote>,
deleting a commit that has children does not back out the changes made
by that commit, as they will still be present in the blobs attached to
versions past the end of the deletion set.  All a delete does when the
commit has children is lose the metadata information about when and by
who those changes were actually made; after the delete any such
changes will be attributed to the first undeleted children of the
deleted commits.  It is expected that this command will be useful
mainly for removing commits mechanically generated by repository
converters such as <command>cvs2svn</command>.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>delete</command>
        [<emphasis>policy...</emphasis>]
</term>
<listitem>
<para>Delete a selection set of events. The default selection set for
this command is empty. On a set of commits, this is equivalent to a
squash with the --delete flag.  It unconditionally deletes tags,
resets, and passthroughs; blobs can be removed only as a side effect
of deleting every commit that points at them.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>divide</command>
        <emphasis>parent</emphasis>
        [<emphasis>child</emphasis>]
</term>
<listitem>
<para>Attempt to partition a repo by cutting the parent-child link
between two specified commits (they must be adjacent). Does not take a
general selection set.  It is only necessary to specify the
parent commit, unless it has multiple children in which case the child
commit must follow (separate it with a comma).</para>

<para>If the repo was named 'foo', you will normally end up with two
repos named 'foo-early' and 'foo-late' (option and feature events at
the beginning of the early segment will be duplicated onto the
beginning of the late one.).  But if the commit graph would remain
connected through another path after the cut, the behavior changes.
In this case, if the parent and child were on the same branch 'qux',
the branch segments are renamed 'qux-early' and 'qux-late' but
the repo is not divided.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>expunge</command>
        <emphasis>[--notagify] [path | /regexp/]...</emphasis>
</term>
<listitem>
<para>Expunge files from the selected portion of the repo history; the
default is the entire history.  The arguments to this command may be
paths or Python regular expressions matching paths (regexps must
be marked by being surrounded with //).</para>

<para>All filemodify (M) operations and delete (D) operations
involving a matched file in the selected set of events are
disconnected from the repo and put in a removal set.  Renames are
followed as the tool walks forward in the selection set; each triggers
a warning message. If a selected file is a copy (C) target, the copy
will be deleted and a warning message issued. If a selected file is a
copy source, the copy target will be added to the list of paths to be
deleted and a warning issued.</para>

<para>After file expunges have been performed, any commits with no
remaining file operations will be removed, and any tags pointing to
them. By default each deleted commit is replaced with a tag of the form
'emptycommit-<emphasis>ident</emphasis>' on the preceding commit unless
--notagify is specified as an argument. Commits with deleted fileops
pointing both in and outside the path set are not deleted, but are
cloned into the removal set.</para>

<para>The removal set is not discarded. It is assembled into a new
repository named after the old one with the suffix "-expunges" added.
Thus, this command can be used to carve a repository into sections by
file path matches.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>tagify</command>
        [<command>--canonicalize</command>]
        [<command>--tipdeletes</command>]
        [<command>--tagify-merges</command>]
</term>
<listitem>
<para>Search for empty commits and turn them into tags. Takes an optional
selection set argument defaulting to all commits. For each commit in the
selection set, turn it into a tag with the same message and author information
if it has no fileops. By default merge commits are not considered, even if they
have no fileops (thus no tree differences with their first parent). To change
that, use the <option>--tagify-merges</option> option.</para>

<para>The name of the generated tag will be
'emptycommit-<emphasis>ident</emphasis>', where
<emphasis>ident</emphasis> is generated from the legacy ID of the
deleted commit, or from its mark, or from its index in the repository,
with a disambiguation suffix if needed.</para>

<para>With the <option>--canonicalize</option>, tagify tries harder to detect
trivial commits by first ensuring that all fileops of selected commits will
have an actual effect when processed by fast-import.</para>

<para>With the <option>--tipdeletes</option>, tagify also considers branch tips
with only deleteall fileops to be candidates for tagification. The
corresponding tags get names of the form
'tipdelete-<emphasis>branchname</emphasis>' rather than the default
'emptycommit-<emphasis>ident</emphasis>'.</para>

<para>With the <option>--tagify-merges</option>, tagify also tagifies merge
commits that have no fileops. When this is done the merge link is move to the
yagified commit's parent.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>coalesce</command>
        [<command>--debug</command>|<command>--changelog</command>]
        [<emphasis>timefuzz</emphasis>]
</term>
<listitem>
<para>Scan the selection set for runs of commits with identical
comments close to each other in time (this is a common form of scar
tissues in repository up-conversions from older file-oriented
version-control systems).  Merge these cliques by deleting all but the
last commit, in order; fileops from the deleted commits are pushed
forward to that last one</para>

<para>The optional second argument, if present, is a maximum time
separation in seconds; the default is 90 seconds.</para>

<para>The default selection set for this command is =C, all
commits. Occasionally you may want to restrict it, for example to
avoid coalescing unrelated cliques of "*** empty log message ***"
commits from CVS lifts.</para>

<para>With  the --debug option, show messages about mismatches.</para>

<para>With the --changelog option, any commit with a comment
containing the string 'empty log message' (such as is generated by
CVS) and containing exactly one file operation modifying a path ending
in <filename>ChangeLog</filename> is treated specially.  Such
ChangeLog commits are considered to match any commit before them by
content, and will coalesce with it if the committer matches and the
commit separation is small enough.  This option handles a convention
used by Free Software Foundation projects.</para>

</listitem>
</varlistentry>
<varlistentry>
<term><command>split</command>
        <command>{at|by}</command>
        <emphasis>item</emphasis>
</term>
<listitem>
<para>The first argument is required to be a commit location; the second is
a preposition which indicates which splitting method to use. If the
preposition is 'at', then the third argument must be an integer
1-origin index of a file operation within the commit. If it is 'by',
then the third argument must be a pathname to be prefix-matched,
pathname match is done first).</para>

<para>The commit is copied and inserted into a new position in the
event sequence, immediately following itself; the duplicate becomes
the child of the original, and replaces it as parent of the original's
children. Commit metadata is duplicated; the new commit then gets a
new mark. If the new commit has a legacy ID, the suffix '.split' is
appended to it.</para>

<para>Finally, some file operations - starting at the one matched or
indexed by the split argument - are moved forward from the original
commit into the new one.  Legal indices are 2-n, where n is the number
of file operations in the original commit.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>add</command>
     {<emphasis>D</emphasis> <emphasis>path</emphasis> 
     | 
     <emphasis>M</emphasis> <emphasis>perm</emphasis>
     <emphasis>mark</emphasis> <emphasis>path</emphasis>
     |
     <emphasis>R</emphasis> <emphasis>source</emphasis> <emphasis>target</emphasis>
     |
     <emphasis>C</emphasis> <emphasis>source</emphasis> <emphasis>target</emphasis>}
</term>
<listitem>
<para>To a specified commit, add a specified fileop.</para>

<para>For a D operation to be valid there must be an M operation for
the path in the commit's ancestry.  For an M operation to be valid,
the 'perm' part must be a token ending with 755 or 644 and the 'mark'
must refer to a blob that precedes the commit location.  For an R or C
operation to be valid, there must be an M operation for the source in
the commit's ancestry.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>remove</command>
        [<emphasis>index</emphasis> | <emphasis>path</emphasis> | <command>deletes</command>]
        [<command>to</command> <emphasis>commit</emphasis>]
</term>
<listitem>
<para>From a specified commit, remove a specified fileop.  The op must
be one of (a) the keyword <quote>deletes</quote>, (b) a file path, (c)
a file path preceded by an op type set (some subset of the letters
DMRCN), or (d) a 1-origin numeric index. The <quote>deletes</quote> keyword
selects all D fileops in the commit; the others select one
each.</para>

<para>If the <quote>to</quote> clause is present, the removed op is
appended to the commit specified by the following singleton selection
set. This option cannot be combined with <quote>deletes</quote>.</para>

<para>Note that this command does not attempt to scavenge blobs even
if the deleted fileop might be the only reference to them. This
behavior may change in a future release.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>blob</command>
</term>
<listitem>
<para>Create a blob at mark :1 after renumbering other marks starting from
:2.  Data is taken from stdin, which may be a here-doc.  This can be
used with the add command to patch synthetic data into a repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>renumber</command>
</term>
<listitem>
<para>Renumber the marks in a repository, from :1 up to :&lt;n&gt;
where &lt;n&gt; is the count of the last mark. Just in case an importer
ever cares about mark ordering or gaps in the sequence.</para>

<para>A side effect of this comment is to clean up stray "done"
passthroughs that may have entered the repository via graft
operations.  After a renumber, the repository will have at most
one "done" and it will be at the end of the events.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>dedup</command>
</term>
<listitem>
<para>Deduplicate blobs in the selection set.  If multiple blobs in the
selection set have the same SHA1, throw away all but the first, and change
fileops referencing them to instead reference the (kept) first blob.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>mailbox_out</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem>
<para>Emit a mailbox file of messages in RFC822 format representing
the contents of repository metadata. Takes a selection set; members of
the set other than commits, annotated tags, and passthroughs are
ignored (that is, presently, blobs and resets).</para>

<para>The output from this command can optionally be redirected
to a named output file. Prefix the filename with <quote>&gt;</quote>
and give it as a following argument.</para>

<para>May have an option --filter, followed by = and a /-enclosed
regular expression.  If this is given, only headers with names
matching it are emitted.  In this context the name of the header
includes its trailing colon.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>mailbox_in</command>
        [<emphasis>--create</emphasis>]
        [<emphasis>--empty-only</emphasis>]
        [&lt;<emphasis>infile</emphasis>]
        [<emphasis>--changed</emphasis> &gt;<emphasis>outfile</emphasis>]
</term>
<listitem>
<para>Accept a mailbox file of messages in RFC822 format representing the
contents of the metadata in selected commits and annotated tags. Takes
no selection set.  If there is an argument it will be taken as the
name of a mailbox file to read from; if no argument, or one of '-', reads
from standard input. Supports &lt; redirection.</para>

<para>Users should be aware that modifying an Event-Number or
Event-Mark field will change which event the update from that message
is applied to.  This is unlikely to have good results.</para>

<para>The header CheckText, if present, is examined to see if the comment text of
the associated event begins with it. If not, the mailbox modification
is aborted. This helps ensure that you are landing updates ob the
events you intend.</para>

<para>If the <quote>--create</quote> modifier is present, new tags and
commits will be appended to the repository. In this case it is an error
for a tag name to match any exting tag name. Commit objects are created
with no fileops. If Committer-Date or Tagger-Date fields are not present
they are filled in with the time at which this command is executed. If
Committer or Tagger fields are not present, reposurgeon will attempt to
deduce the user's git-style identity and fill it in.</para>

<para>Otherwise, if the Event-Number and Event-Mark fields are absent, the
mailbox_in logic will attempt to match the commit or tag first by
Legacy-ID, then by a unique committer ID and timestamp pair.</para>

<para>If output is redirected and the modifier <quote>--changed</quote>
appears, a minimal set of modifications actually made is written to the
output file in a form that can be fed back in. Supports &gt; redirection.</para>

<para>If the option --empty-only is given, this command will throw a
recoverable error if it tries to alter a message body that is neither
empty nor consists of the CVS empty-comment marker.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>setfield</command>
        <emphasis>attribute</emphasis>
        <emphasis>value</emphasis>
</term>
<listitem>
<para>In the selected objects (defaulting to none) set every instance
of a named field to a string value.  The string may be quoted to
include whitespace, and use backslash escapes interpreted by the
Python string-escape codec, such as \n and \t. </para>

<para>Attempts to set nonexistent attributes are ignored. Valid values
for the attribute are internal Python field names; in particular, for 
commits, <quote>comment</quote> and <quote>branch</quote> are legal.
Consult the source code for other interesting values.</para>

<para>The special fieldnames 'author', 'commitdate' and 'authdate' apply only
to commits in the range.  The latter two sets attribution dates. The
former set the author's name, copying the committer timestamp.</para> 
</listitem>
</varlistentry>
<varlistentry>
<term><command>append</command>
        [<command>--rstrip</command>]
        [&gt;<emphasis>text</emphasis>]
</term>
<listitem>
<para>Append text to the comments of commits and tags in the specified
selection set. The text is the first token of the command and may
be a quoted string. C-style escape sequences in the string are
interpreted using Python's string_decode codec.</para>

<para>If the option --rstrip is given, the comment is right-stripped before
the new text is appended.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>filter</command>
        [<emphasis>--shell</emphasis>|<emphasis>--regex</emphasis>|<emphasis>--replace</emphasis>|<emphasis>--dedos</emphasis>]
</term>
<listitem>
<para>Run blobs, commit comments, or tag comments in the selection set
through the filter specified on the command line.</para>

<para>In any mode other than --dedos, attempting to specify a
selection set including both blobs and non-blobs (that is, commits or
tags) throws an error. Inline content in commits is filtered when the
selection set contains (only) blobs and the commit is within the range
bounded by the earliest and latest blob in the specification.</para>

<para>When filtering blobs, if the command line contains the magic cookie
'%PATHS%' it is replaced with a space-separated list of all paths
that reference the blob.</para>

<para>With --shell, the remainder of the line specifies a filter as a
shell command. Each blob or comment is presented to the filter on
standard input; the content is replaced with whatever the filter emits
to standard output.</para>

<para>With --regex, the remainder of the line is expected to be a Python
regular expression substitution written as /from/to/ with from and
to being passed as arguments to the standard re.sub() function and
it applied to modify the content. Actually, any non-space character will
work as a delimiter in place of the /; this makes it easier to use
/ in patterns. Ordinarily only the first such
substitution is performed; putting 'g' after the slash replaces
globally, and a numeric literal gives the maximum number
of substitutions to perform. Other flags available restrict substitution
scope - 'c' for comment text only, 'C' for committer name only, 'a'
for author names only.  Note that parsing of a --regex argument will
be confused by any substring consisting of whitespace followed by #;
use "\s" rather than whitespace to avoid this.</para>

<para>With --replace, the behavior is like --regexp but the expressions are
not interpreted as regular expressions. (This is slightly
faster).</para>

<para>With --dedos, DOS/Windows-style \r\n line terminators are
replaced with \n.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>transcode</command>
        <emphasis>codec</emphasis>
</term>
<listitem>
<para>Transcode blobs, commit comments and committer/author names, or tag
comments and tag committer names in the selection set to UTF-8 from
the character encoding specified on the command line.</para>

<para>Attempting to specify a selection set including both blobs and
non-blobs (that is, commits or tags) throws an error. Inline content
in commits is filtered when the selection set contains (only) blobs
and the commit is within the range bounded by the earliest and latest
blob in the specification.</para>

<para>The encoding argument must name one of the codecs known to the Python
standard codecs library. In particular, 'latin-1' is a valid codec name.</para>

<para>Errors in this command are fatal, because an error may leave
repository objects in a damaged state.</para>

<para>The theory behind the design of this command is that the
repository might contain a mixture of encodings used to enter commit
metadata by different people at different times. After using =I to
identify metadata containing non-Unicode high bytes in text, a human
must use context to identify which particular encodings were used in
particular event spans and compose appropriate transcode commands
to fix them up.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>edit</command>
</term>
<listitem>
<para>Report the selection set of events to a tempfile as mailbox_out does,
call an editor on it, and update from the result as mailbox_in does.
If you do not specify an editor name as second argument, it will be
taken from the $EDITOR variable in your environment.</para>

<para>Normally this command ignores blobs because
<command>mailbox_out</command> does.  However, if you specify a
selection set consisting of a single blob, your editor will be called
directly on the blob file.</para>

<para>Supports &lt; and &gt; redirection.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>timeoffset</command>
        offset
        [<emphasis>timezone</emphasis>]
</term>
<listitem>
<para>Apply a time offset to all time/date stamps in the selected set.
An offset argument is required; it may be in the form [+-]ss,
[+-]mm:ss or [+-]hh:mm:ss.  The leading sign is required to distinguish
it from a selection expression.</para>

<para>Optionally you may also specify another argument in the form [+-]hhmm, a
timezone literal to apply.  To apply a timezone without an offset, use
an offset literal of +0 or -0.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>unite</command>
        [--prune]
        <emphasis>reponame</emphasis>...
</term>
<listitem>
<para>Unite repositories. Name any number of loaded repositories; they will
be united into one union repo and removed from the load list.  The
union repo will be selected.</para>

<para>The root of each repo (other than the oldest repo) will be
grafted as a child to the last commit in the dump with a preceding
commit date.  This will produce a union repository with one branch for
each part.  Running last to first, duplicate tag and branch names will
be disambiguated using the source repository name (thus, recent
duplicates will get priority over older ones). After all grafts, marks
will be renumbered.</para>

<para>The name of the new repo will be the names of all parts concatenated,
separated by '+'. It will have no source directory or preferred system
type.</para>

<para>With the option --prune, at each join D operations for every
ancestral file existing will be prepended to the root commit, then it
will be canonicalized using the rules for squashing the effect will be
that only files with properly matching M, R, and C operations in the
root survive.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>graft</command>
	[--prune]
        <emphasis>reponame</emphasis>
</term>
<listitem>
<para>For when unite doesn't give you enough control. This command may have
either of two forms, selected by the size of the selection set.  The
first argument is always required to be the name of a loaded repo.</para>

<para>If the selection set is of size 1, it must identify a single commit in
the currently chosen repo; in this case the name repo's root will
become a child of the specified commit. If the selection set is
empty, the named repo must contain one or more callouts matching a
commits in the currently chosen repo.</para>

<para>Labels and branches in the named repo are prefixed with its name; then
it is grafted to the selected one. Any other callouts in the named repo are also
resolved in the context of the currently chosen one. Finally, the
named repo is removed from the load list.</para>

<para>With the option --prune, prepend a deleteall operation into the root
of the grafted repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>path</command>
        [<emphasis>source</emphasis>]
        <command>rename</command>
        [<command>--force</command>]
        [<emphasis>target</emphasis>]
</term>
<listitem>
<para>Rename a path in every fileop of every selected commit.  The
default selection set is all commits. The first argument is interpreted as a
Python regular expression to match against paths; the second may contain
back-reference syntax.</para>

<para>Ordinarily, if the target path already exists in the fileops, or
is visible in the ancestry of the commit, this command throws an
error.  With the <option>--force</option> option, these checks
are skipped.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>paths</command>
        [<command>{sub|sup}</command>]
        [<command>dirname</command>]
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem>
<para>Takes a selection set. Without a modifier, list all paths
touched by fileops in the selection set (which defaults to the entire
repo). This reporting variant does &gt;-redirection.</para>

<para>With the 'sub' modifier, take a second argument that is a
directory name and prepend it to every path. With the 'sup' modifier,
strip any directory argument from the start of the path if it appears there;
with no argument, strip the first directory component from every path.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>merge</command>
</term>
<listitem>
<para>Create a merge link. Takes a selection set argument, ignoring all but
the lowest (source) and highest (target) members.  Creates a merge link
from the highest member (child) to the lowest (parent).</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>unmerge</command>
</term>
<listitem>
<para>Linearize a commit. Takes a selection set argument, which must resolve
to a single commit, and removes all its parents except for the first.</para>
<para>It is equivalent to <command>reparent</command>
<option>--rebase</option>
<emphasis>first_parent</emphasis>,<emphasis>commit</emphasis>, where
<emphasis>commit</emphasis> is the same selection set as used with
unmerge and <emphasis>first_parent</emphasis> is a set resolving
<emphasis>commit</emphasis>'s first parent (see the
<command>reparent</command> command below</para>
<para>The main interest of the <command>unmerge</command> is that you don't
have to find and specify the first parent yourself, saving time and avoiding
errors when nearby surgery would make a manual first parent argument
stale.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>reparent</command>
        [<emphasis>options</emphasis>...]
        [<emphasis>policy</emphasis>]
</term>
<listitem>
<para>Changes the parent list of a commit.  Takes a selection set,
zero or more option arguments, and an optional policy argument.</para>

<variablelist>
<varlistentry><term>Selection set:</term><listitem>
<para>The selection set must resolve to one or more commits.  The
selected commit with the highest event number (not necessarily the
last one selected) is the commit to modify.  The remainder of the
selected commits, if any, become its parents:  the selected commit
with the lowest event number (which is not necessarily the first one
selected) becomes the first parent, the selected commit with second
lowest event number becomes the second parent, and so on.  All
original parent links are removed.  Examples:</para>

<programlisting>
# this makes 17 the parent of 33
17,33 reparent

# this also makes 17 the parent of 33
33,17 reparent

# this makes 33 a root (parentless) commit
33 reparent

# this makes 33 an octopus merge commit.  its first parent
# is commit 15, second parent is 17, and third parent is 22
22,33,15,17 reparent
</programlisting>

</listitem></varlistentry>
<varlistentry><term>Options:</term><listitem>
<variablelist>
<varlistentry><term><option>--use-order</option></term><listitem>
<para>Use the selection order to determine which selected commit is
the commit to modify and which are the parents (and if there are
multiple parents, their order).  The last selected commit (not
necessarily the one with the highest event number) is the commit to
modify, the first selected commit (not necessarily the one with the
lowest event number) becomes the first parent, the second selected
commit becomes the second parent, and so on.  Examples:</para>

<programlisting>
# this makes 33 the parent of 17
33|17 reparent --use-order

# this makes 17 an octopus merge commit.  its first parent
# is commit 22, second parent is 33, and third parent is 15
22,33,15|17 reparent --use-order
</programlisting>

<para>Because ancestor commit events must appear before their
descendants, giving a commit with a low event number a parent with a
high event number triggers a re-sort of the events.  A re-sort assigns
different event numbers to some or all of the events.  Re-sorting only
works if the reparenting does not introduce any cycles.  To swap the
order of two commits that have an ancestor–descendant relationship
without introducing a cycle during the process, you must reparent the
descendant commit first.</para>
</listitem></varlistentry>
</variablelist>
</listitem></varlistentry>

<varlistentry><term>Policy:</term><listitem>
<para>By default, the manifest of the reparented commit is computed
before modifying it; a <literal>deleteall</literal> and some fileops
are prepended so that the manifest stays unchanged even when the first
parent has been changed.  This behavior can be changed by specifying a
policy flag:</para>

<variablelist>
<varlistentry><term><command>--rebase</command></term><listitem>
<para>Inhibits the default behavior—no <literal>deleteall</literal> is
issued and the tree contents of all descendents can be modified as a
result.</para>
</listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term><command>branch</command>
        <emphasis>branchname</emphasis>...
        {<command>rename</command>|<command>delete</command>}
        [<emphasis>arg</emphasis>]
</term>
<listitem>
<para>Rename or delete a branch (and any associated resets).  First argument
must be an existing branch name; second argument must one of the verbs
'rename' or 'delete'.</para>

<para>For a 'rename', the third argument may be any token that is a
syntactically valid branch name (but not the name of an existing
branch). For a 'delete', no third argument is required.</para>

<para>For either name, if it does not contain a '/' the prefix 'refs/heads'
is prepended.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>tag</command>
        <emphasis>tagname</emphasis>...
        <command>{move|rename|delete}</command>
        <command>[arg]</command>.
</term>
<listitem>
<para>Create, move, rename, or delete a tag.</para>

<para>Creation is a special case.  First argument is a name, which
must not be an existing tag. Takes a singleton event second argument
which must point to a commit.  A tag object pointing to the commit is
created and inserted just after the last tag in the repo (or just
after the last commit if there are no tags).  The tagger, committish,
and comment fields are copied from the commit's committer, mark, and
comment fields.</para>

<para>Otherwise, first argument must be an existing tag name; second
argument must be one of the verbs <quote>move</quote>,
<quote>rename</quote>, or <quote>delete</quote>.</para>

<para>For a <quote>move</quote>, a third argument must be a singleton
selection set. For a <quote>rename</quote>, the third argument may be
any token that is a syntactically valid tag name (but not the name of
an existing tag). For a <quote>delete</quote>, no third argument is
required.</para>

<para>The behavior of this command is complex because features which
present as tags may be any of three things: (1) True tag objects, (2)
lightweight tags, actually sequences of commits with a common
branchname beginning with <quote>refs/tags</quote> - in this case the
tag is considered to point to the last commit in the sequence, (3)
Reset objects.  These may occur in combination; in fact, stream
exporters from systems with annotation tags commonly express each of
these as a true tag object (1) pointing at the tip commit of a
sequence (2) in which the basename of the common branch field is
identical to the tag name.  An exporter that generates
lightweight-tagged commit sequences (2) may or may not generate resets
pointing at their tip commits.</para>

<para>This command tries to handle all combinations in a natural way by
doing up to three operations on any true tag, commit sequence, and
reset matching the source name. In a rename, all are renamed together.
In a delete, any matching tag or reset is deleted; then matching
branch fields are changed to match the branch of the unique descendent
of the tagged commit, if there is one.  When a tag is moved, no branch
fields are changed and a warning is issued.</para>

<para>Attempts to delete a lightweight tag may fail with the message
<quote>couldn't determine a unique successor</quote>.  When this
happens, the tag is on a commit with multiple children that have
different branch labels. There is a hole in the specification
of git fast-import streams that leaves it uncertain how branch
labels can be safely reassigned in this case; rather than do
something risky, <command>reposurgeon</command> throws a recoverable
error.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>reset</command>
        <emphasis>resetname</emphasis>...
        <command>{move|rename|delete}</command>
        <command>[arg]</command>.
</term>
<listitem>
<para>Move, rename, or delete a reset.  First argument must match an
existing reset name; second argument must be one of the verbs
<quote>move</quote>, <quote>rename</quote>, or
<quote>delete</quote>.</para>

<para>For a <quote>move</quote>, a third argument must be a singleton
selection set. For a <quote>rename</quote>, the third argument may be
any token token that matches a syntactically valid reset name (but not
the name of an existing reset). For a <quote>delete</quote>, no third
argument is required.</para>

<para>For either name, if it does not contain a <quote>/</quote> the
prefix <quote>heads/</quote> is prepended. If it does not begin with
<quote>refs/</quote>, <quote>refs/</quote> is prepended.</para>

<para>An argument matches a reset's name if it is either the entire
reference (refs/heads/FOO or refs/tags/FOO for some some value of FOO)
or the basename (e.g. FOO), or a suffix of the form heads/FOO or tags/FOO.
An unqualified basename is assumed to refer to a head.</para>

<para>When a reset is renamed, commit branch fields matching the tag are
renamed with it to match.  When a reset is deleted, matching branch
fields are changed to match the branch of the unique descendent of the
tip commit of the associated branch, if there is one.  When a reset is
moved, no branch fields are changed.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>debranch</command>
        <emphasis>source-branch</emphasis>...
        <command>[target-branch]</command>.
</term>
<listitem>
<para>Takes one or two arguments which must be the names of source and
target branches; if the second (target) argument is omitted it
defaults to <filename>refs/heads/master</filename>.  Any trailing
segment of a branch name is accepted as a synonym for it; thus
<filename>master</filename> is the same as
<filename>refs/heads/master</filename>. Does not take a selection
set.</para>

<para>The history of the source branch is merged into the history of
the target branch, becoming the history of a subdirectory with the
name of the source branch.  Any resets of the source branch are
removed.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>strip</command>
        <command>[blobs|reduce]</command>.
</term>
<listitem>
<para>Reduce the selected repository to make it a more tractable test
case. Use this when reporting bugs.</para>

<para>With the modifier 'blobs', replace each blob in the repository
with a small, self-identifying stub, leaving all metadata and DAG
topology intact. This is useful when you are reporting a bug, for
reducing large repositories to test cases of manageable size.</para>

<para>A selection set is effective only with the 'blobs' option,
defaulting to all blobs. The 'reduce' mode always acts on the entire
repository.</para>

<para>With the modifier 'reduce', perform a topological reduction that
throws out uninteresting commits.  If a commit has all file
modifications (no deletions or copies or renames) and has exactly one
ancestor and one descendant, then it may be boring.  To be fully
boring, it must also not be referred to by any tag or reset.
Interesting commits are not boring, or have a non-boring parent or
non-boring child.</para>

<para>With no modifiers, this command strips blobs.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>ignores</command>
        <command>[rename]</command>.
        <command>[translate]</command>.
        <command>[defaults]</command>.
</term>
<listitem>
<para>Intelligent handling of ignore-pattern files.
This command fails if no repository has been selected or no preferred write
type has been set for the repository.  It does not take a selection set.</para>

<para>If the rename modifier is present, this command attempts to rename all
ignore-pattern files to whatever is appropriate for the preferred type
- e.g. .gitignore for git, .hgignore for hg, etc.  This option does not
cause any translation of the ignore files it renames.</para>

<para>If the translate modifier is present, syntax translation of each ignore
file is attempted. At present, the only transformation the code knows
is to prepend a 'syntax: glob' header if the preferred type is hg.</para>

<para>If the defaults modifier is present, the command attempts to prepend
these default patterns to all ignore files. If no ignore file is
created by the first commit, it will be modified to create one
containing the defaults.  This command will error out on prefer types
that have no default ignore patterns (git and hg, in particular).  It
will also error out when it knows the import tool has already set
default patterns.</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id="reference-lifting"><title>REFERENCE LIFTING</title>

<para>This group of commands is meant for fixing up references in commits
that are in the format of older version control systems.  The general
workflow is this: first, go over the comment history and change all
old-fashioned commit references into machine-parseable cookies.  Then,
automatically turn the machine-parseable cookie into action stamps.
The point of dividing the process this way is that the first part is
hard for a machine to get right, while the second part is prone to errors
when a human does it.</para>

<para>A Subversion cookie is a comment substring of the form
[[SVN:ddddd]] (example: [[SVN:2355]] with the revision read directly
via the Subversion exporter, deduced from git-svn metadata, or
matching a $Revision$ header embedded in blob data for the
filename.</para>

<para>A CVS cookie is a comment substring of the form
[[CVS:filename:revision]] (example: [[CVS:src/README:1.23]] with the
revision matching a CVS $Id$ or $Revision$ header embedded in blob
data for the filename.</para>

<para>A mark cookie is of the form [[:dddd]] and is simply a reference
to the specified mark. You may want to hand-patch this in when one of
previous forms is inconvenient.</para>

<para>An action stamp is an RFC3339 timestamp, followed by a '!',
followed by an author email address (author rather than committer
because that timestamp is not changed when a patch is replayed on to a
branch).  It attempts to refer to a commit without being VCS-specific.
Thus, instead of "commit 304a53c2" or "r2355",
"2011-10-25T15:11:09Z!fred@foonly.com".</para>

<para>The following git aliases allow git to work directly with action
stamps.  Append it to your <filename>~/.gitconfig</filename>; if you
already have an [alias] section, leave off the first line.</para>

<!-- Keep this updated from reposurgeon-git-aliases -->
<programlisting>
<![CDATA[
[alias]
	# git stamp <commit-ish> - print a reposurgeon-style action stamp
	stamp = show -s --format='%cI!%ce'

	# git scommit <stamp> <rev-list-args> - list most recent commit that matches <stamp>.
	# Must also specify a branch to search or --all, after these arguments.
	scommit = "!f(){ d=${1%%!*}; a=${1##*!}; arg=\"--until=$d -1\"; if [ $a != $1 ]; then arg=\"$arg --committer=$a\"; fi; shift; git rev-list $arg ${1:+\"$@\"}; }; f"

	# git scommits <stamp> <rev-list-args> - as above, but list all matching commits.
	scommits = "!f(){ d=${1%%!*}; a=${1##*!}; arg=\"--until=$d --after $d\"; if [ $a != $1 ]; then arg=\"$arg --committer=$a\"; fi; shift; git rev-list $arg ${1:+\"$@\"}; }; f"

	# git smaster <stamp> - list most recent commit on master that matches <stamp>.
	smaster = "!f(){ git scommit \"$1\" master --first-parent; }; f"
	smasters = "!f(){ git scommits \"$1\" master --first-parent; }; f"

	# git shs <stamp> - show the commits on master that match <stamp>.
	shs = "!f(){ stamp=$(git smasters $1); shift; git show ${stamp:?not found} $*; }; f"

	# git slog <stamp> <log-args> - start git log at <stamp> on master
	slog = "!f(){ stamp=$(git smaster $1); shift; git log ${stamp:?not found} $*; }; f"

	# git sco <stamp> - check out most recent commit on master that matches <stamp>.
	sco = "!f(){ stamp=$(git smaster $1); shift; git checkout ${stamp:?not found} $*; }; f"
]]>
</programlisting>

<para>There is a rare case in which an action stamp
will not refer uniquely to one commit. It is theoretically possible
that the same author might check in revisions on different branches
within the one-second resolution of the timestamps in a fast-import stream.
There is nothing to be done about this; tools using action stamps need to be
aware of the possibility and throw a warning when it occurs.</para>

<para>In order to support reference lifting,
<command>reposurgeon</command> internally builds a legacy-reference
map that associates revision identifiers in older version-control
systems with commits.  The contents of this map comes from three
places: (1) cvs2svn:rev properties if the repository was read from a
Subversion dump stream, (2) $Id$ and $Revision$ headers in repository
files, and (3) the <filename>.git/cvs-revisions</filename> created by
<command>git cvsimport</command>.</para>

<para>The detailed sequence for lifting possible references is this:
first, find possible CVS and Subversion references with the
<command>references</command> or =N visibility set; then replace them
with equivalent cookies; then run <command>references lift</command>
to turn the cookies into action stamps (using the information in the
legacy-reference map) without having to do the lookup by hand.</para>

<variablelist>
<varlistentry>
<term><command>references</command>
          [<command>list</command>|<command>edit</command>|<command>lift</command>]
          [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem>
<para>With the modifier 'list', list commit and tag comments for strings
that might be CVS- or Subversion-style revision identifiers. This will
be useful when you want to replace them with equivalent cookies that
can automatically be translated into VCS-independent action
stamps. This reporting command supports &gt;-redirection.
It is equivalent to '=N list'.</para>

<para>With the modifier 'edit', edit the set where revision IDs are
found.  This version of the command supports &lt; and &gt; redirection.
This is equivalent to '=N edit'.</para>

<para>With the modifier "lift", attempt to resolve Subversion and CVS
cookies in comments into action stamps using the legacy map. An action
stamp is a timestamp/email/sequence-number combination uniquely
identifying the commit associated with that blob, as described in
<xref linkend='style'/>.</para>

<para>It is not guaranteed that every such reference will be resolved,
or even that any at all will be. Normally all references in history
from a Subversion repository will resolve, but CVS references are less
likely to be resolvable.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect2>

<refsect2 id="changelogs"><title>CHANGELOGS</title>

<para>CVS and Subversion do not have separated notions of committer
and author for changesets; when lifted to a VCS that does, like git,
their one author field is used for both.</para>

<para>However, if the project used the FSF ChangeLog convention,
many changesets will include a ChangeLog modification  listing an
author for the commit. In the common case that the changeset was
derived from a patch and committed by a project maintainer,
but the ChangeLog entry names the actual author, this information
can be recovered.</para>

<para>Use the "changelogs" command/  This takes neither arguments nor
a selection set. It mines the ChangeLog files for authorship data.</para> 

<para>It assumes such files have the basename 'ChangeLog',
and that they are in the format used by FSF projects: entry header
lines begin with YYYY-MM-DD and are followed by a fullname/address.
When a ChangeLog file modification is found in a clique, the entry
header at or before the section changed since its last revision is
parsed and the address is inserted as the commit author.</para>

<para>If the entry header contains an email address but no name, a name
will be filled in if possible by looking for the address in author
map entries.</para>

<para>Due to the limitations of the ChangeLog format, attribution
time-of-day and timezone on these author records have to made up out
of thin air.  We copy the committer's, then try various tricks to
correct the timezone, including looking in the author map if there is
one</para>

<para>Rationale: If the author is the committer and the attribution
date is the same day as the commit, this is probably wthin seconds or
minutes of right.  On a different day with the same committer this
gets the timezone right. If committer is different and day is
different we're making up data out of thin air, but it at least is no
worse than any other random choice and has the following good
properties: (1) no later than the committer date, and (2) has same
mm:ss, making it possible to match the committer date in a display
even if we don't know whether it's local or UTC.</para>

<para>The command reports statistics on how many commits were altered.</para>
</refsect2>

<refsect2 id="tarballs"><title>RELEASE TARBALLS</title>

<para>When converting a legacy repository, it sometimes happens that
there are archived releases of the project surviving from before the
date of the repository's  initial commit.  It may be desirable to
insert those releases at the front of the repository history.</para>

<para>To do this, use the "incorporate" command.  This command takes
as its single argument naming a tarball, the content of which is to be
inserted as a commit. It may be a gzipped or bzipped tarball. The
initial segment of each path is assumed to be a version directory and
stripped off. The number of segments stripped off can be set with the
option --strip=n, n defaulting to 1.</para>

<para>Takes a singleton selection set.  Normally inserts before that commit; with
the option --after, insert after it. The default selection set is the very
first commit of the repository.</para>

<para>The option --date can be used to set the commit date. It takes an argument,
which is expected to be an RFC3339 timestamp.</para>

<para>The generated commit has a committer field (the invoking user)
and gets as its commit date the modification time of the
newest file in the tarball (not the mod time of the tarball
itself). No author field is generated.  A comment recording the
tarball name is generated.</para>

<para>Note that the import stream generated by this command is - while
correct - not optimal, and may in particular contain duplicate
blobs.</para>
</refsect2>

<refsect2 id="macros"><title>VARIABLES, MACROS AND EXTENSIONS</title>

<para>Occasionally you will need to issue a large number of complex surgical
commands of very similar form, and it's convenient to be able to
package that form so you don't need to do a lot of error-prone typing.
For those occasions, <command>reposurgeon</command> supports simple
forms of named variables and macro expansion.</para>

<variablelist>
<varlistentry>
<term><command>assign</command>
        [<emphasis>name</emphasis>]
</term>
<listitem>
<para>Compute a leading selection set and assign it to a symbolic name.
It is an error to assign to a name that is already assigned, or to
any existing branch name.  Assignments may be cleared by sequence
mutations (though not ordinary deletions); you will see a warning
when this occurs.</para>

<para>With no selection set and no name, list all assignments.></para>

<para>If the option --singleton is given, the assignment will throw an error
if the selection set is not a singleton.</para>

<para>Use this to optimize out location and selection computations
that would otherwise be performed repeatedly, e.g. in macro calls.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>unassign</command>
        [<emphasis>name</emphasis>]
</term>
<listitem>
<para>Unassign a symbolic name.  Throws an error if the name is not
assigned.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>names</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem><para>List the names of all known branches and tags.  Tells
you what things are legal within angle brackets and
parentheses.</para></listitem>
</varlistentry>
<varlistentry>
<term><command>define</command>
          <emphasis>name</emphasis>
          <emphasis>body</emphasis>
</term>
<listitem>

<para>Define a macro.  The first whitespace-separated token is the
name; the remainder of the line is the body, unless it is
<quote>{</quote>, which begins a multi-line macro terminated by
a line beginning with <quote>}</quote>.</para>

<para>A later <quote>do</quote> call can invoke this macro.</para>

<para>The command <quote>define</quote> by itself without a name or
body produces a macro list.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>do</command>
          <emphasis>name</emphasis>
          <emphasis>arguments</emphasis>...
</term>
<listitem>
<para>Expand and perform a macro.  The first whitespace-separated
token is the name of the macro to be called; remaining tokens replace
{0}, {1}... in the macro definition (the conventions used are those of
the Python format method). Tokens may contain whitespace if they are
string-quoted; string quotes are stripped. Macros can call
macros.</para>

<para>If the macro expansion does not itself begin with a selection set,
whatever set was specified before the "do" keyword is available to
the command generated by the expansion.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>undefine</command>
          <emphasis>name</emphasis>]
</term>
<listitem>
<para>Undefine the named macro.</para>
</listitem>
</varlistentry>
</variablelist>

<para>Here's an example to illustrate how you might use this.  In CVS
repositories of projects that use the GNU ChangeLog convention, a very
common pre-conversion artifact is a commit with the comment "*** empty
log message ***" that modifies only a ChangeLog entry explaining the
commit immediately previous to it. The following

<programlisting>
define changelog &lt;{0}&gt; &amp; /empty log message/ squash --pushback
do changelog 2012-08-14T21:51:35Z
do changelog 2012-08-08T22:52:14Z
do changelog 2012-08-07T04:48:26Z
do changelog 2012-08-08T07:19:09Z
do changelog 2012-07-28T18:40:10Z
</programlisting>

is equivalent to the more verbose

<programlisting>
&lt;2012-08-14T21:51:35Z&gt; &amp; /empty log message/ squash --pushback
&lt;2012-08-08T22:52:14Z&gt; &amp; /empty log message/ squash --pushback
&lt;2012-08-07T04:48:26Z&gt; &amp; /empty log message/ squash --pushback
&lt;2012-08-08T07:19:09Z&gt; &amp; /empty log message/ squash --pushback
&lt;2012-07-28T18:40:10Z&gt; &amp; /empty log message/ squash --pushback
</programlisting>

but you are less likely to make difficult-to-notice errors typing the
first version.</para>

<para>(Also note how the text regexp acts as a failsafe against the
possibility of typing a wrong date that doesn't refer to a commit with
an empty comment. This was a real-world example from the CVS-to-git
conversion of groff.)</para>

<para>When even a macro is not enough, you can write and call  custom
Python extensions.</para>

<variablelist>
<varlistentry>
<term><command>exec</command>
          <emphasis>name</emphasis>
</term>
<listitem>
<para>Execute custom code from standard input (normally a file via
&lt; redirection).  Use this to set up custom extension functions for
later eval calls. The code has full access to all internal data
structures. Functions defined are accessible to later
<command>eval</command> calls.</para>

<para>This can be called in a script with the extension code in a
here-doc.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>eval</command>
          <emphasis>function-name</emphasis>
</term>
<listitem>
<para>Evaluate a line of code in the current interpreter context.
Typically this will be a call to a function defined by a previous
exec. The variables <varname>_repository</varname> and
<varname>_selection</varname> will have the obvious values.  Note that
<varname>_selection</varname> will be a list of integers, not objects.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>script</command>
        <emphasis>filename</emphasis>
        [<emphasis>arg</emphasis>...]
</term>
<listitem><para>Takes a filename and optional following arguments.
Reads each line from the file and executes it as a command.</para>

<para>During execution of the script, the script name replaces the
string $0 and the optional following arguments (if any) replace the
strings $1, $2 ... $n in the script text. This is done before
tokenization, so the $1 in a string like <quote>foo$1bar</quote> will
be expanded.  Additionally, $$ is expanded to the current process ID
(which may be useful for scripts that use tempfiles).</para>

<para>Within scripts (and only within scripts) <command>reposurgeon</command>
accepts a slightly extended syntax: First, a backslash ending a line signals
that the command continues on the next line. Any number of consecutive lines
thus escaped are concatenated, without the ending backslashes, prior to
evaluation. Second, a command that takes an input filename argument can instead
take literal following data in the syntax of a shell here-document. That is: if
the filename is replaced by "&lt;&lt;EOF", all following lines in the script up
to a terminating line consisting only of "EOF" will be read, placed in a
temporary file, and that file fed to the command and afterwards deleted. EOF
may be replaced by any string. Backslashes have no special meaning while
reading a here-document.</para>

<para>Scripts may have comments.  Any line beginning with a '#' is
ignored. If a line has a trailing position that begins with one or more
whitespace characters followed by '#', that trailing portion is
ignored.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect2>

<refsect2 id='artifact-removal'><title>ARTIFACT REMOVAL</title>

<para>Some commands automate fixing various kinds of artifacts
associated with repository conversions from older systems.</para>

<variablelist>
<varlistentry>
<term><command>authors</command>
          [<command>read</command>|<command>write</command>]
          [&lt;<command>filename</command>]
          [&gt;<command>filename</command>]
</term>
<listitem>
<para>Apply or dump author-map information for the specified selection
set, defaulting to all events.</para>

<para>Lifts from CVS and Subversion may have only usernames local to
the repository host in committer and author IDs. DVCSes want email
addresses (net-wide identifiers) and complete names. To supply the map
from one to the other, an authors file is expected to consist of
lines each beginning with a local user ID, followed by a '=' (possibly
surrounded by whitespace) followed by a full name and email address,
optionally followed by a timezone offset field.  Thus:</para>

<literallayout>
ferd = Ferd J. Foonly &lt;foonly@foo.com&gt; -0500
</literallayout>

<para>An authors file may have comment lines beginning with '#'; these
are ignored.</para>

<para>When an authors file is applied, email addresses in committer and author
metadata for which the local ID matches between &lt; and @ are replaced
according to the mapping (this handles git-svn lifts). Alternatively,
if the local ID is the entire address, this is also considered a match
(this handles what git-cvsimport and cvs2git do). If a timezone was
specified in the map entry, that person's author and committer dates
are mapped to it.</para>

<para>With the 'read' modifier, or no modifier, apply author mapping
data (from standard input or a &lt;-redirected file).  May be useful
if you are editing a repo or dump created by
<command>cvs2git</command> or by <command>git-svn</command> invoked
without -A.</para>

<para>With the 'write' modifier, write a mapping file that could be
interpreted by <command>authors read</command>, with entries for each
unique committer, author, and tagger (to standard output or a
&lt;-redirected mapping file). This may be helpful as a start on
building an authors file, though each part to the right of an equals
sign will need editing.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>branchify</command>
          [<emphasis>path-set</emphasis>]
</term>
<listitem>
<para>Specify the list of directories to be treated as potential
branches (to become tags if there are no modifications after the
creation copies) when analyzing a Subversion repo. This list is
ignored when the <option>--nobranch</option> read option is used.  It
defaults to the 'standard layout' set of directories, plus any
unrecognized directories in the repository root.</para>

<para>With no arguments, displays the current branchification set.</para>

<para>An asterisk at the end of a path in the set means 'all immediate
subdirectories of this path, unless they are part of another (longer)
path in the branchify set'.</para>

<para>Note that the branchify set is a property of the reposurgeon
interpreter, not of any individual repository, and will persist across
Subversion dumpfile reads. This may lead to unexpected results if you
forget to re-set it.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>branchify_map</command>
          [<emphasis>/regex/branch/</emphasis>...]
</term>
<listitem>
<para>Specify the list of regular expressions used for mapping the svn
branches that are detected by branchify. If none of the expressions
match the default behaviour applies. This maps a branch to the name
of the last directory, except for trunk and <quote>*</quote> which are
mapped to master and root.</para>

<para>With no arguments the current regex replacement pairs are
shown. Passing 'reset' will clear the mapping.</para>

<para>The branchify command will match each branch name against regex1
and if it matches rewrite its branch name to branch1. If not it will
try regex2 and so forth until it either found a matching regex or
there are no regexs left. The regular expressions should be in <ulink
url="http://docs.python.org/2/library/re.html">Python's</ulink>. format. The
branch name can use backreferences (see the re.sub function in the Python
documentation).</para>

<para>Note that the regular expressions are appended to 'refs/'
without either the needed 'heads/' or 'tags/'. This allows for
choosing the right kind of branch type.</para>

<para>While the syntax template above uses slashes, any first character will
be used as a delimeter (and you will need to use a different one in the
common case that the paths contain slashes).</para>

<para>Note that the branchify_map set is a property of the reposurgeon
interpreter, not of any individual repository, and will persist across
Subversion dumpfile reads. This may lead to unexpected results if you
forget to re-set it.</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id='examining-tree-states'><title>EXAMINING TREE STATES</title>

<variablelist>
<varlistentry>
<term><command>manifest</command>
        [<emphasis>regular expression</emphasis>]
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem>
<para>Takes an optional selection set argument defaulting to all commits, and
an optional Python regular expression. For each commit in the selection set,
print the mapping of all paths in that commit tree to the corresponding blob
marks, mirroring what files would be created in a checkout of the commit. If a
regular expression is given, only print "path -> mark" lines for paths matching
it. This command supports &gt; redirection.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>checkout</command>
        <emphasis>directory</emphasis>
</term>
<listitem>
<para>Takes a selection set which must resolve to a single commit, and
a second argument. The second argument is interpreted as a directory
name.  The state of the code tree at that commit is materialized beneath
the directory.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>diff</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem>
<para>Display the difference between commits. Takes a selection-set
argument which must resolve to exactly two commits. Supports output
redirection.</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id='housekeeping'><title>HOUSEKEEPING</title>

<para>These are backed up by the following housekeeping commands, none of
which take a selection set:</para>

<variablelist>
<varlistentry>
<term><command>help</command>
</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term><command>shell</command>
</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term><command>prefer</command>
        [<emphasis>repotype</emphasis>]
</term>
<listitem>
<para>With no arguments, describe capabilities of all supported
systems. With an argument (which must be the name of a supported
system) this has two effects:</para>

<para>First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).</para>

<para>Secondly, this will change reposurgeon's preferred type for output.
This means that you do a write to a directory, it will build a repo of
the preferred type rather than its original type (if it had one).</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set the
preferred type to the type of that repository.</para>

<para>In older versions of <application>reposurgeon</application> this
command changed the type of the selected repository, if there is one.
That behavior interacted badly with attempts to interpret legacy IDs
and has been removed.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>sourcetype</command>
        [<emphasis>repotype</emphasis>]
</term>
<listitem>
<para>Report (with no arguments) or select (with one argument) the current
repository's source type.  This type is normally set at
repository-read time, but may remain unset if the source was a stream
file.</para>

<para>The source type affects the interpretation of legacy IDs (for
purposes of the =N visibility set and the 'references' command) by
controlling the regular expressions used to recognize them. If no
preferred output type has been set, it may also change the output
format of stream files made from the repository.</para>

<para>The source type is reliably set whenever a live repository is
read, or when a Subversion stream or Fossil dump is interpreted but
not necessarily by other stream files. Streams generated by
<citerefentry><refentrytitle>cvs-fast-export</refentrytitle><manvolnum>1</manvolnum></citerefentry>
using the <option>--reposurgeon</option> are detected as CVS. In some
other cases, the source system is detected from the presence of magic
$-headers in contents blobs.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect2>

<refsect2 id='instrumentation'><title>INSTRUMENTATION</title>

<para>A few commands have been implemented primarily for debugging and
regression-testing purposes, but may be useful in unusual
circumstances.</para>

<para>The output of most of these commands can individually be redirected to
a named output file. Where indicated in the syntax, you can prefix the
output filename with <quote>&gt;</quote> and give it as a following
argument.</para>

<variablelist>
<varlistentry>
<term><command>index</command>
        [&gt;<emphasis>outfile</emphasis>]
</term>
<listitem>
<para>Display four columns of info on objects in the selection set:
their number, their type, the associate mark (or '-' if no mark) and a
summary field varying by type.  For a branch or tag it's the
reference; for a commit it's the commit branch; for a blob it's the
repository path of the file in the blob.</para>

<para>The default selection set for this command is =CTRU, all objects
except blobs.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>resolve</command>
        [<emphasis>label-text...</emphasis>]
</term>
<listitem><para>Does nothing but resolve a selection-set expression
and echo the resulting event-number set to standard
output. The remainder of the line after the command is used
as a label for the output.</para>

<para>Implemented mainly for regression testing, but may be useful
for exploring the selection-set language.</para></listitem>
</varlistentry>
<varlistentry>
<term><command>verbose</command>
        [<emphasis>n</emphasis>]
</term>
<listitem><para>'verbose 1' enables the progress meter and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term><command>quiet</command>
        [<emphasis>on | off</emphasis>]
</term>
<listitem><para>Without an argument, this command requests a report of the quiet
boolean; with the argument 'on' or 'off' it is changed.  When quiet is
on, time-varying report fields which would otherwise cause spurious
failures in regression testing are suppressed.</para></listitem>
</varlistentry>
<varlistentry>
<term><command>print</command>
        <emphasis>output-text...</emphasis>
</term>
<listitem><para>Does nothing but ship its argument line to standard
output. Useful in regression tests.</para></listitem>
</varlistentry>
<varlistentry>
<term><command>echo</command>
        [<emphasis>number</emphasis>]
</term>
<listitem><para>'echo 1' causes each
<command>reposurgeon</command> command to be echoed to standard
output just before its output.  This can be useful in constructing regression
tests that are easily checked by eyeball.</para></listitem>
</varlistentry>
<varlistentry>
<term><command>version</command>
        [<emphasis>version</emphasis>...]
</term>
<listitem>
<para>With no argument, display the program version and the list of
VCSes directly supported.  With argument, declare the major version
(single digit) or full version (major.minor) under which the enclosing
script was developed.  The program will error out if the major version
has changed (which means the surgical language is not backwards
compatible).</para>

<para>It is good practice to start your lift script with a version
requirement, especially if you are going to archive it for later
reference.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><command>prompt</command>
        [<emphasis>format</emphasis>...]
</term>
<listitem>
<para>Set the command prompt format to the value of the command line; with
an empty command line, display it. The prompt format is evaluated in
Python after each command with the following dictionary substitutions:</para>

<variablelist>
<varlistentry>
<term>chosen</term>
<listitem>
<para>The name of the selected repository, or None if none is currently
selected.</para>
</listitem>
</varlistentry>
</variablelist>

<para>Thus, one useful format might be 'rs[%(chosen)s]%% '.</para>

<para>More format items may be added in the future.  The default
prompt corresponds to the format 'reposurgeon%% '. The format line is
evaluated with shell quotng of tokens, so that spaces can be
included.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>history</command>
</term>
<listitem>
<para>List the commands you have entered this session.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>legacy</command>
          [<command>read</command>|<command>write</command>]
          [<command>&lt;filename</command>]
          [<command>&gt;filename</command>]
</term>
<listitem>
<para>Apply or list legacy-reference information. Does not take a
selection set. The 'read' variant reads from standard input or a
&lt;-redirected filename; the 'write' variant writes to standard
output or a &gt;-redirected filename.</para>

<para> A legacy-reference file maps reference cookies to (committer,
commit-date, sequence-number) pairs; these in turn (should) uniquely
identify a commit.  The format is two whitespace-separated fields:
the cookie followed by an action stamp identifying the commit.</para>

<para>It should not normally be necessary to use this command.  The
legacy map is automatically preserved through repository reads and
rebuilds, being stored in the file <filename>legacy-map</filename> under
the repository subdirectory..</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>set</command>
          [<command>option</command>]
</term>
<listitem>
<para>Turn on an option flag.  With no arguments, list all options</para>

<para>Most options are described in conjunction with the specific
operations that the modify. One of general interest is
<quote>compressblobs</quote>; this enables compression on the blob
files in the internal representation
<application>reposurgeon</application> uses for editing
repositories. With this option, reading and writing of repositories is
slower, but editing a repository requires less (sometimes much less)
disk space.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>clear</command>
          [<command>option</command>]
</term>
<listitem>
<para>Turn off an option flag.  With no arguments, list all options</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>profile</command>
</term>
<listitem>
<para>Enable profiling. Profile statistics are dumped to the path
given as argument. Must be one of the initial command-line arguments, and
gathers statistics only on code executed via '-'.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>timing</command>
</term>
<listitem>
<para>Display statistics on phase timing in repository analysis.
Mainly of interest to developers trying to speed up the program.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>exit</command>
</term>
<listitem>
<para>Exit, reporting the time. Included here because, while EOT will
also cleanly exit the interpreter, this command reports elapsed time
since start.</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>
</refsect1>

<refsect1 id='mercurial'><title>WORKING WITH MERCURIAL</title>
<para><application>reposurgeon</application> uses a built-in extractor
class to perform extractions from Mercurial repositories.</para>

<para>Mercurial branches are exported as branches in the exported
repository and tags are exported as tags. By default, bookmarks are
ignored. You can specify explicit handling for bookmarks by setting
<parameter>reposurgeon.bookmarks</parameter> in your
<filename>.hg/hgrc</filename>. Set the value to the prefix that
<application>reposurgeon</application> should use for
bookmarks.</para>

<para>For example, if your bookmarks represent branches, put this at
the bottom of your <filename>.hg/hgrc</filename>:</para>

<programlisting>[reposurgeon]
bookmarks=heads/
</programlisting>

<para>If you do that, it's your responsibility to ensure that branch
names do not conflict with bookmark names. You can add a prefix like
<computeroutput>bookmarks=heads/feature-</computeroutput> to
disambiguate as necessary.</para>
</refsect1>

<refsect1 id='subversion'><title>WORKING WITH SUBVERSION</title>

<para><application>reposurgeon</application> can read Subversion
dumpfiles or edit a Subversion repository (and you must point it at a
repository, not a checkout directory).  The
<application>reposurgeon</application> distribution includes a script
named <quote>repotool</quote> that you can use to make and then
incrementally update a local mirror of a remote repository for
editing or conversion purposes.</para>

<refsect2><title>READING SUBVERSION REPOSITORIES</title>

<para>Certain optional modifiers on the read command change
its behavior when reading Subversion repositories:</para>

<variablelist>
<varlistentry>
<term>--nobranch</term>
<listitem><para>Suppress branch analysis.</para></listitem>
</varlistentry>
<varlistentry>
<term>--ignore-properties</term>
<listitem><para>Suppress read-time warnings about discarded property
settings.</para></listitem>
</varlistentry>
<varlistentry>
<term>--user-ignores</term>
<listitem><para>Don't generate .gitignore files from svn:ignore
properties.  Instead, just pass through .gitignore files found in the
history.</para></listitem>
</varlistentry>
<varlistentry>
<term>--use-uuid</term>
<listitem><para>If the --use-uuid read option is set, the repository's
UUID will be used as the hostname when faking up email addresses, a la
git-svn.  Otherwise, addresses will be generated the way git cvs-import does
it, simply ciopying the username into the address field.</para>
</listitem>
</varlistentry>
</variablelist>

<para>These modifiers can go anywhere in any order on the read command
line after the read verb. They must be whitespace-separated.</para>

<para>Here are the rules used for mapping subdirectories in a
Subversion repository to branches:</para>

<orderedlist>
<listitem><para>At any given time there is a set of eligible
paths and path wildcards which declare potential branches.
See the documentation of the <command>branchify</command>
for how to alter this set, which initially consists of
{trunk, tags/*, branches/*, and '*'}.</para></listitem>

<listitem><para>A repository is considered "flat" if it has no
directory that matches a path or path wildcard in the branchify set.
All commits in a flat repository are assigned to branch master, and
what would have been branch structure becomes directory structure.  In
this case, we're done; all the other rules apply to non-flat
repos.</para>

<para>If you give the option <option>--nobranch</option>
when reading a Subversion repository, branch analysis is skipped and
the repository is treated as though flat (left as a linear sequence of
commits on refs/heads/master).  This may be useful if your repository
configuration is highly unusual and you need to do your own branch
surgery. Note that this option will disable partitioning of mixed
commits.</para></listitem>

<listitem><para>If "trunk" is eligible, it always becomes the master
branch.</para></listitem>

<listitem><para>If an element of the branchify set ends with *, each
immediate subdirectory of it is considered a potential branch.  If '*'
is in the branchify set (which is true by default) all top-level
directories other than /trunk, /tags, and /branches are also
considered potential branches.</para></listitem>

<listitem><para>Each potential branch is checked to see if it has
commits on it after the initial creation or copy.  If there are such
commits, it becomes a branch.  If not, it becomes a tag in order to
preserve the commit metadata.  (In all cases, the name of the tag or
branch is the basename of the directory.)</para></listitem>

<listitem><para>Files in the top-level directory are assigned to a
synthetic branch named 'root'.</para></listitem>
</orderedlist>

<para>Each commit that only creates or deletes directories (in
particular, copy commits for tags and branches, and commits that only
change properties) will be transformed into a tag named after the
branch, containing the date/author/comment metadata from the
commit. While this produces a desirable result for tags, non-tag
branches (including trunk) will also get root tags this way. This
apparent misfeature has been accepted so that
<application>reposurgeon</application> will never destroy
human-generated metadata that might have value; it is left up to the
user to manually remove unwanted tags.</para>

<para>Subversion branch deletions are turned into deletealls, clearing the
fileset of the import-stream branch.  When a branch
finishes with a deleteall at its tip, the deleteall is transformed
into a tag. This rule cleans up after aborted branch renames.</para>

<para>Occasionally (and usually by mistake) a branchy Subversion
repository will contain revisions that touch multiple branches. These
are handled by partitioning them into multiple import-stream commits,
one on each affected branch. The Legacy-ID of such a split commit
will have a pseudo-decimal part - for example, if Subversion revision 2317
touches three branches, the three generated commits will have IDs
2317.1, 2317.2, and 2317.3.</para>

<para>The svn:executable and svn:special properties are translated
into permission settings in the input stream; svn:executable becomes
100755 and svn:special becomes 120000 (indicating a symlink; the blob
contents will be the path to which the symlink should resolve).</para>

<para>Any cvs2svn:rev properties generated by
<application>cvs2svn</application> are incorporated into the internal map
used for reference-lifting, then discarded.</para>

<para>Normally, per-directory svn:ignore properties become .gitignore files.
Actual .gitignore files in a Subversion directory are presumed to have
been created by git-svn users separately from native Subversion ignore
properties and discarded with a warning. It is up to the user to merge
the content of such files into the target repository by hand.  But
this behavior is inverted by the --user-ignores option; if that is on,
.gitignore files are passed through and Subversion svn:ignore
properties are discarded.</para>

<para>(Regardless of the setting of the --user-ignores option,
.cvsignore files found in Subversion repositories always become
.gitignores in the translation.  The assumption is that these date
from before a CVS-to-SVN lift and should be preserved to affect
behavior when browsing that section of the repository.)</para>

<para>svn:mergeinfo properties are interpreted.  Any svn:mergeinfo property
on a revision A with a merge source range ending in revision B produces
a merge link such that B becomes a parent of A.</para>

<para>All other Subversion properties are discarded. (This may change in a
future release.) The property for which this is most likely to cause
semantic problems is svn:eol-style. However, since property-change-only
commits get turned into annotated tags, the translated tags will retain
information about setting changes.</para>

<para>The sub-second resolution on Subversion commit dates is discarded;
Git wants integer timestamps only.</para>

<para>Because fast-import format cannot represent an empty directory,
empty directories in Subversion repositories will be lost in
translation.</para>

<para>Normally, Subversion local usernames are mapped in the style of
git cvs-import; thus user "foo" becomes "foo &lt;foo&gt;", which is
sufficient to pacify git and other systems that require email
addresses.  With the option "svn_use_uuid", usernames are mapped in the
git-svn style, with the repository's UUID used as a fake domain in the
email address. Both forms can be remapped to real address using
the <command>authors read</command> command.</para>

<para>Reading a Subversion stream enables writing of the legacy map as
'legacy' passthroughs when the repo is written to a stream
file.</para>

<para><command>reposurgeon</command> tries hard to silently do the
right thing, but there are Subversion edge cases in which it emits warnings
because a human may need to intervene and perform fixups by hand. Here
are the less obvious messages it may emit:</para>

<variablelist>
<varlistentry>
<term>user-generated .gitignore</term>
<listitem>
<para>This message means means <command>reposurgeon</command> has
found a <filename>.gitignore</filename> file in the Subversion
repository it is analyzing. This probably happened because somebody
was using <command>git-svn</command> as a live gateway, and created
ignores which may or may not be congruent with those in the generated
<filename>.gitignore</filename> files that the Subversion ignore
properties will be translated into.  You'll need to make a policy
decision about which set of ignores to use in the conversion, and
possibly set the --user-ignores option on read to pass through
user-created <filename>.gitignore</filename> files; in that case this
warning will not be emitted.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>can't connect nonempty branch XXXX to origin</term>
<listitem>
<para>This is a serious error. <command>reposurgeon</command> has been
unable to find a link from a specified branch to the trunk (master)
branch.  The commit graph will not be fully connected and will need
manual repair.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>permission information may be lost</term>
<listitem>
<para>A Subversion node change on a file sets or clears properties,
but no ancestor can be found for this file. Executable or symlink
position may be set wrongly on later revisions of this
file. Subversion user-defined properties may also be scrambled or
lost. Usually this error can be ignored.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>properties set</term>
<listitem>
<para><command>reposurgeon</command> has detected a setting of a
user-defined property, or the Subversion properties
svn:externals. These properties cannot be expressed in an import
stream; the user is notified in case this is a showstopper for the
conversion or some corrective action is required, but normally this
error can be ignored.  This warning is suppressed by the
--ignore-properties option.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>branch links detected by file ops only</term>
<listitem>
<para>Branch links are normally deduced by examining Subversion directory
copy operations. A common user error (making a branch with a non-Subversion
directory copy and then doing an svn add on the contends) can defeat this.
While <command>reposurgeon</command> should detect and cope with most such
copies correctly, you should examine the commit graph to check that the
branch is rooted at the correct place.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>could not tagify root commit</term>
<listitem>
<para>The earliest commit in your Subversion repository has file operations,
rather than being a pure directory creation. This probably means your
Subversion dump file is malformed, or you may have attempted to lift
from an incremental dump. Proceed with caution.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>deleting parentless tip delete</term>
<listitem>
<para>This message may be triggered by a Subversion branch move followed by
a re-creation under the source name. Check near the indicated revision to make
sure the renamed branch is connected to master.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>mid-branch deleteall</term>
<listitem>
<para>A deleteall operation has been found in the middle of a branch
history.  This usually indicates that a Subversion tag or branch was
created by mistake, and someone later tried to undo the error by
deleting the tag/branch directory before recreating it with a copy
operation.  Examine the topology near the deleteall closely, it may
need hand-hacking. It is fairly likely that both (a) the
<command>reposurgeon</command> translation will be different from what
other translators (such as <command>git-svn</command>) produce,
and (b) it will not be immediately obvious which is right.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>lookback for XXX failed, not making branch link</term>
<listitem>
<para>Branch analysis failed, probably due to a set of file copies that
<command>reposurgeon</command> thought it should interpret as a botched
branch creation but couldn't deduce a history for.  This is a warning;
check how the directory XXX is converted, it may need post-editing
into a branch.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect2>
<refsect2><title>WRITING SUBVERSION REPOSITORIES</title>

<para><application>reposurgeon</application> has support for writing
Subversion repositories.  Due to mismatches between the ontology of
Subversion and that of git import streams, this support has some
significant limitations and bugs.</para>

<para>In summary, Subversion repository histories do not round-trip
through <application>reposurgeon</application> editing. File content
changes are preserved but some metadata is unavoidably lost.
Furthermore, writing out a DVCS history in Subversion also loses
significant portions of its metadata.  Details follow.</para>

<para>Writing a Subversion repository or dump stream discards author
information, the committer's name, and the hostname part of the commit
address; only the commit timestamp and the local part of the
committer's email address are preserved, the latter becoming the
Subversion author field.  However, reading a Subversion repository and
writing it out again will preserve the author fields.</para>

<para>Import-stream timestamps have 1-second granularity. The sub-second
parts of Subversion commit timestamps will be lost on their way through
reposurgeon.</para>

<para>Empty directories aren't represented in import
streams. Consequently, reading and writing Subversion repositories
preserves file content, but not empty directories.  It is also not
guaranteed that after editing a Subversion repository that the sequence
of directory creations and deletions relative to other operations will
be identical; the only guarantee is that enclosing directories will
be created before any files in them are.</para>

<para>When reading a Subversion repository,
<application>reposurgeon</application> discards the special
directory-copy nodes associated with branch creations.  These can't be
recreated if and when the repository is written back out to
Subversion; rather, each branch copy node from the original translates
into a branch creation plus the first set of file modifications on the
branch.</para>

<para>When reading a Subversion repository,
<application>reposurgeon</application> also automatically breaks apart
mixed-branch commits. These are not re-united if the repository
is written back out.</para>

<para>When writing to a Subversion repository, all lightweight tags
become Subversion tag copies with empty log comments, named for the
tag basename.  The committer name and timestamp are copied from the
commit the tag points to. The distinction between heads and tags is
lost.</para>

<para>Because of the preceding two points, it is not guaranteed that
even revision numbers will be stable when a Subversion repository
is read in and then written out!</para>

<para>Subversion repositories are always written with a standard
(trunk/tags/branches) layout. Thus, a repository with a nonstandard
shape that has been analyzed by <application>reposurgeon</application>
won't be written out with the same shape.</para>

<para>When writing a Subversion repository, branch merges are
translated into svn:mergeinfo properties in the simplest possible way -
as an svn:mergeinfo property of the translated merge commit listing
the merge source revisions.</para>

<para>Subversion has a concept of "flows"; that is, named segments of
history corresponding to files or directories that are created when the
path is added, cloned when the path is copied, and deleted when the
path is deleted. This information is not preserved in import streams or
the internal representation that <application>reposurgeon</application>
uses.  Thus, after editing, the flow boundaries of a Subversion history
may be arbitrarily changed. </para>
</refsect2>
</refsect1>

<refsect1 id='ignore'><title>IGNORE PATTERNS</title>

<para><command>reposurgeon</command> recognizes how supported VCSes
represent file ignores (CVS .cvsignore files lurking untranslated in
older Subversion repositories, Subversion ignore properties,
.gitignore/.hgignore/.bzrignore file in other systems) and moves
ignore declarations among these containers on repo input and
output. This will be sufficient if the ignore patterns are exact
filenames.</para>

<para>Translation may not, however, be perfect when the ignore
patterns are Unix glob patterns or regular expressions.  This
compatibility table describes which patterns will translate;
<quote>plain</quote> indicates a plain filename with no
glob or regexp syntax or negation.</para>

<para>RCS has no ignore files or patterns and is therefore not
included in the table.</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='3' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <colspec colname='c3'/>
    <colspec colname='c4'/>
    <colspec colname='c5'/>
    <colspec colname='c6'/>
    <colspec colname='c7'/>
    <colspec colname='c8'/>
    <spanspec spanname="all" namest="c2" nameend="c8" align="center"/>
    <thead>
      <row>
        <entry></entry>
        <entry align='center'>from CVS</entry>
        <entry align='center'>from svn</entry>
        <entry align='center'>from git</entry>
        <entry align='center'>from hg</entry>
        <entry align='center'>from bzr</entry>
        <entry align='center'>from darcs</entry>
        <entry align='center'>from SRC</entry>
        <entry align='center'>from bk</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry><para><emphasis role="strong">to CVS</emphasis></para></entry>
        <!-- CVS --><entry><para>all</para></entry>
        <!-- svn --><entry><para>all</para></entry>
        <!-- git --><entry><para>all except !-prefixed but nonempty</para></entry>
        <!-- hg  --><entry><para>all</para></entry>
        <!-- bzr --><entry><para>all except RE:- and !-prefixed</para></entry>
        <!--darcs--><entry><para>plain</para></entry>
        <!-- SRC --><entry><para>all</para></entry>
        <!-- bk  --><entry><para>all</para></entry>
      </row>
      <row>
        <entry><para><emphasis role="strong">to svn</emphasis></para></entry>
        <!-- CVS --><entry>all except !<para></para></entry>
        <!-- svn --><entry><para>all</para></entry>
        <!-- git --><entry><para>all except !-prefixed</para></entry>
        <!-- hg  --><entry><para>all</para></entry>
        <!-- bzr --><entry><para>all except RE:- and !-prefixed</para></entry>
        <!--darcs--><entry><para>plain</para></entry>
        <!-- SRC --><entry><para>all</para></entry>
        <!-- bk  --><entry><para>all</para></entry>
      </row>
      <row>
        <entry><para><emphasis role="strong">to git</emphasis></para></entry>
        <!-- CVS --><entry><para>all</para></entry>
        <!-- svn --><entry><para>all</para></entry>
        <!-- git --><entry><para>all</para></entry>
        <!-- hg  --><entry><para>all except !-prefixed</para></entry>
        <!-- bzr --><entry><para>all except RE:-prefixed</para></entry>
        <!--darcs--><entry><para>plain</para></entry>
        <!-- SRC --><entry><para>all</para></entry>
        <!-- bk  --><entry><para>all</para></entry>
      </row>
      <row>
        <entry><para><emphasis role="strong">to hg</emphasis></para></entry>
        <!-- CVS --><entry><para>all except !</para></entry>
        <!-- svn --><entry><para>all</para></entry>
        <!-- git --><entry><para>all except !-prefixed</para></entry>
        <!-- hg  --><entry><para>all</para></entry>
        <!-- bzr --><entry><para>all except RE:- and !-prefixed</para></entry>
        <!--darcs--><entry><para>plain</para></entry>
        <!-- SRC --><entry><para>all</para></entry>
        <!-- bk  --><entry><para>all</para></entry>
      </row>
      <row>
        <entry><para><emphasis role="strong">to bzr</emphasis></para></entry>
        <!-- CVS --><entry><para>all</para></entry>
        <!-- svn --><entry><para>all</para></entry>
        <!-- git --><entry><para>all</para></entry>
        <!-- hg  --><entry><para>all</para></entry>
        <!-- bzr --><entry><para>all</para></entry>
        <!--darcs--><entry><para>plain</para></entry>
        <!-- SRC --><entry><para>all</para></entry>
        <!-- bk  --><entry><para>all</para></entry>
      </row>
      <row>
        <entry><para><emphasis role="strong">to darcs</emphasis></para></entry>
        <!-- CVS --><entry><para>plain</para></entry>
        <!-- svn --><entry><para>plain</para></entry>
        <!-- git --><entry><para>plain</para></entry>
        <!-- hg  --><entry><para>plain</para></entry>
        <!-- bzr --><entry><para>plain</para></entry>
        <!--darcs--><entry><para>all</para></entry>
        <!-- SRC --><entry><para>all</para></entry>
        <!-- bk  --><entry><para>all</para></entry>
      </row>
      <row>
        <entry><para><emphasis role="strong">to SRC</emphasis></para></entry>
        <!-- CVS --><entry><para>all except !</para></entry>
        <!-- svn --><entry><para>all</para></entry>
        <!-- git --><entry><para>all except !-prefixed</para></entry>
        <!-- hg  --><entry><para>all</para></entry>
        <!-- bzr --><entry><para>all except RE:- and !-prefixed</para></entry>
        <!--darcs--><entry><para>plain</para></entry>
        <!-- SRC --><entry><para>all</para></entry>
        <!-- bk  --><entry><para>all</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>The hg rows and columns of the table describes compatibility to
hg's glob syntax rather than its default regular-expression syntax.
When writing to an hg repository from any other kind,
<command>reposurgeon</command> prepends to the output .hgignore a
"syntax: glob" line.</para>
</refsect1>

<refsect1 id='style'><title>TRANSLATION STYLE</title>

<para>After converting a CVS, SVN, or BitKeeper repository, check for and remove
$-cookies in the head revision(s) of the files. The full Subversion
set is $Date:, $Revision:, $Author:, $HeadURL and $Id:. CVS uses
$Author:, $Date:, $Header:, $Id:, $Log:, $Revision:, also (rarely)
$Locker:, $Name:, $RCSfile:, $Source:, and $State:.</para>

<para>When you need to specify a commit, use the action-stamp format
that <command>references lift</command> generates when it can resolve
an SVN or CVS reference in a comment. It is best that you
<emphasis>not vary from this format</emphasis>, even in trivial ways
like omitting the 'Z' or changing the 'T' or '!' or ':'. Making action
stamps uniform and machine-parseable will have good consequences for
future repository-browsing tools.</para>

<para>Sometimes, in converting a repository, you may need to insert an
explanatory comment - for example, if metadata has been garbled or
missing and you need to point to that fact. It's helpful for
repository-browsing tools if there is a uniform syntax for this that
is highly unlikely to show up in repository comments.  We recommend
enclosing translation notes in [[ ]].  This has the advantage of being
visually similar to the [ ] traditionally used for editorial comments
in text.</para>

<para>It is good practice to include, in the comment for the root
commit of the repository, a note dating and attributing the conversion
work and explaining these conventions.  Example:</para>

<blockquote>
<para>[[This repository was converted from Subversion to git on 2011-10-24
by Eric S. Raymond &lt;esr@thyrsus.com&gt;.  Here and elsewhere, conversion
notes are enclosed in double square brackets. Junk commits generated
by cvs2svn have been removed, commit references have been mapped into
a uniform VCS-independent syntax, and some comments edited into
summary-plus-continuation form.]]</para>
</blockquote>

<para>It is also good practice to include a generated tag at the
point of conversion. E.g</para>

<programlisting>
mailbox_in --create &lt;&lt;EOF
Tag-Name: git-conversion

Marks the spot at which this repository was converted from Subversion to git.
EOF
</programlisting>

</refsect1>
<refsect1 id='advanced'><title>ADVANCED EXAMPLES</title>

<programlisting>
define lastchange {
@max(=B &amp; [/ChangeLog/] &amp; /{0}/B)? list
}
</programlisting>

<para>List the last commit that refers to a ChangeLog file containing
a specified string. (The trick here is that ? extends the singleton
set consisting of the last eligible ChangeLog blob to its set of
referring commits, and <command>list</command>only notices the
commits.)</para>

</refsect1>

<refsect1 id='extensions'><title>STREAM SYNTAX EXTENSIONS</title>

<para>The event-stream parser in <quote>reposurgeon</quote> supports some
extended syntax. Exporters designed to work with <quote>reposurgeon</quote>
may have a --reposurgeon option that enables emission of extended
syntax; notably, this is true of
<citerefentry><refentrytitle>cvs-fast-export</refentrytitle><manvolnum>1</manvolnum></citerefentry>.
The remainder of this section describes these syntax extensions.  The
properties they set are (usually) preserved and re-output when the stream file
is written.</para>

<para>The token <quote>#reposurgeon</quote> at the start of a comment
line in a fast-import stream signals
<application>reposurgeon</application> that the remainder is an
extension command to be interpreted by <quote>reposurgeon</quote>.</para>

<para>One such extension command is implemented:
<command>#sourcetype</command>, which behaves identically to the
<application>reposurgeon</application> <command>sourcetype</command>
command. An exporter for a version-control system named
<quote>frobozz</quote> could, for example, say

<programlisting>
#reposurgeon sourcetype frobozz
</programlisting>
</para>

<para>Within a commit, a magic comment of the form
<quote>#legacy-id</quote> declares a legacy ID from the stream file's
source version-control system.</para>

<para>Also accepted is the bzr syntax for setting per-commit
properties. While parsing commit syntax, a line beginning with the
token <quote>property</quote> must contibue with a
whitespace-separated property-name token. If it is then followed by a
newline it is taken to set that boolean-valued property to true. Otherwise
it must be followed by a numeric token specifying a data length, a
space, following data (which may contain newlines) and a terminating
newline. For example:

<programlisting>
commit refs/heads/master
mark :1
committer Eric S. Raymond &lt;esr@thyrsus.com&gt; 1289147634 -0500
data 16
Example commit.

property legacy-id 2 r1
M 644 inline README
</programlisting>
</para>

<para>Unlike other extensions, bzr properties are only preserved on
stream output if the preferred type is bzr, because any importer other
than bzr's will choke on them.</para>

</refsect1>

<refsect1 id='changes'><title>INCOMPATIBLE LANGUAGE CHANGES</title>

<para>In versions before 3.23, <quote>prefer</quote> changed the
repository type as well as the preferred output format.</para>

<para>In versions before 3.0, the general command syntax put the
command verb first, then the selection set (if any) then modifiers
(VSO).  It has changed to optional selection set first, then command
verb, then modifiers (SVO). The change made parsing simpler, allowed
abolishing some noise keywords, and recapitulates a successful design
pattern in some other Unix tools - notably
<citerefentry><refentrytitle>sed</refentrytitle><manvolnum>1</manvolnum></citerefentry>.</para>

<para>In versions before 3.0, path expressions only matched
commits, not commits and the associated blobs as well. The names
of the <quote>a</quote> and <quote>c</quote> flags were different.</para>

<para>In <command>reposurgeon</command> versions before 3.0, the
delete command had the semantics of squash;  also, the policy flags
did not require a <quote>--</quote> prefix. The <quote>--delete</quote>
flag was named <quote>obliterate</quote>.</para>

<para>In <command>reposurgeon</command> versions before 3.0, read and
write optionally took file arguments rather than requiring redirects
(and the write command never wrote into directories). This was changed
in order to allow these commands to have modifiers. These modifiers
replaced several global options that no longer exist.</para>

<para>In <command>reposurgeon</command> versions before 3.0, the
earliest factor in a unite command always kept its tag and branch
names unaltered. The new rule for resolving name conflicts, giving
priority to the latest factor, produces more natural behavior when
uniting two repositories end to end; the master branch of the second
(later) one keeps its name.</para>

<para>In <command>reposurgeon</command> versions before 3.0, the tagify
command expected policies as trailing arguments to alter its behaviour. The new
syntax uses similarly named options with leading dashes, that can appear
anywhere after the tagify command</para>

<para>In versions before 2.9. the syntax of "authors", "legacy",
"list", and "mailbox_{in|out}" was different (and "legacy" was
"fossils"). They took plain filename arguments rather that using
redirect &lt; and &gt;.</para>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: In DVCses that use commit hashes, editing with
<command>reposurgeon</command> never changes the hash of a commit
object unless (a) you edit the commit, or (b) it is a descendant of an
edited commit in a VCS that includes parent hashes in the input of a
child object's hash (git and hg both do this).</para>

<para>Guarantee: <command>reposurgeon</command> only requires
main memory proportional to the size of a repository's metadata
history, not its entire content history. (Exception: the data from
inline content is held in memory.)</para>

<para>Guarantee: In the worst case, <command>reposurgeon</command>
makes its own copy of every content blob in the repository's history
and thus uses intermediate disk space approximately equal to the size
of a repository's content history. However, when the repository to be
edited is presented as a stream file, <command>reposurgeon</command>
requires no or only very little extra disk space to represent it; the
internal representation of content blobs is a (seek-offset, length)
pair pointing into the stream file.</para>

<para>Guarantee: <command>reposurgeon</command> never modifies
the contents of a repository it reads, nor deletes any repository. The
results of surgery are always expressed in a new repository.</para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <command>reposurgeon</command> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <command>reposurgeon</command> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Guarantee: <command>reposurgeon</command> handles the bzr
commit-properties extension, correctly passing through property
items including those with embedded newlines. (Such properties
are also editable in the mailbox format.)</para>

<para>Limitation: Because <command>reposurgeon</command>
relies on other programs to generate and interpret the fast-import command
stream, it is subject to bugs in those programs.</para>

<para>Limitation: bzr suffers from deep confusion over whether its
unit of work is a repository or a floating branch that might have been
cloned from a repo or created from scratch, and might or might not be
destined to be merged to a repo one day. Its exporter only works on
branches, but its importer creates repos.  Thus, a rebuild operation
will produce a subdirectory structure that differs from what you
expect.  Look for your content under the subdirectory 'trunk'.</para>

<para>Limitation: under git, signed tags are imported verbatim. However, any
operation that modifies any commit upstream of the target of the
tag will invalidate it.</para>

<para>Limitation: Stock git (at least as of version 1.7.3.2) will choke on
property extension commands. Accordingly, <command>reposurgeon</command>
omits them when rebuilding a repo with git type.</para>

<para>Limitation: Converting an hg repo that uses bookmarks (not
branches) to git can lose information; the branch ref that git assigns
to each commit may not be the same as the hg bookmark that was active
when the commit was originally made under hg.  Unfortunately, this is
a real ontological mismatch, not a problem that can be fixed by
cleverness in <command>reposurgeon</command>.</para>

<para>Limitation: Converting an hg repo that uses branches to git can
lose information because git does not store an explicit branch as part
of commit metadata, but colors commits with branch or tag names on the
fly using a specific coloring algorithm, which might not match the explicit
branch assignments to commits in the original hg repo. Reposurgeon
preserves the hg branch information when reading an hg repo, so it is
available from within reposurgeon itself, but there is no way to preserve
it if the repo is written to git.</para>

<para>Limitation: While the Subversion read-side support is in good shape,
the write-side support is more of a sketch or proof-of-concept than a
robust implementation;  it only works on very simple cases and does
not round-trip. It may improve in future releases.</para>

<para>Limitation: Not all BitKeeper versions have the fast-import and
fast-export commands that <command>reposurgeon</command> requires.
They are present back to the 7.3 opensource version.</para>

<para>Limitation: <command>reposurgeon</command> may misbehave under a
filesystem which smashes case in filenames, or which nominally
preserves case but maps names differing only by case to the same
filesystem node (Mac OS X behaves like this by default).  Problems
will arise if any two paths in a repo differ by case only. To avoid
the problem on a Mac, do all your surgery on an HFS+ file system
formatted with case sensitivity specifically enabled.</para>

<para>Limitation: If whitespace followed by # appears in a string or
regexp command argument, it will be misinterpreted as the beginning of
a line-ending comment and screw up parsing.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<command>reposurgeon</command>.</para>
</refsect1>

<refsect1 id='requirements'><title>REQUIREMENTS</title>

<para><command>reposurgeon</command> relies on importers and exporters
associated with the VCSes it supports.</para>

<variablelist>
<varlistentry>
<term>git</term>
<listitem><para>Core git supports both export and import.</para></listitem>
</varlistentry>
<varlistentry>
<term>bzr</term>
<listitem><para>Requires bzr plus the bzr-fast-import plugin.</para></listitem>
</varlistentry>
<varlistentry>
<term>hg</term>
<listitem>
<para>Requires core hg, the hg-fastimport plugin, and the third-party
hg-fast-export.py script.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>svn</term>
<listitem>
<para>Stock Subversion commands support export and import.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>darcs</term>
<listitem>
<para>Stock darcs commands support export and import.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>CVS</term>
<listitem>
<para>Requires cvs-fast-export. Note that the quality of CVS lifts may
be poor, with individual lifts requiring serious hand-hacking. This
is due to inherent problems with CVS's file-oriented model.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>RCS</term>
<listitem>
<para>Requires cvs-fast-export (yes, that's not a typo; cvs-fast-export
handles RCS collections as well). The caveat for CVS applies.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect1>

<refsect1 id='canonicalization'><title>CANONICALIZATION RULES</title>

<para>It is expected that <command>reposurgeon</command> will
be extended with more deletion policies. Policy authors may
need to know more about how a commit's file operation sequence
is reduced to normal form after operations from deleted commits
are prepended to it.</para>

<para>Recall that each commit has a list of file operations, each a M
(modify), D (delete), R (rename), C (copy), or 'deleteall' (delete all
files). Only M operations have associated blobs.  Normally there is
only one M operation per individual file in a commit's operation
list.</para>

<para>To understand how the reduction process works, it's enough to
understand the case where all the operation in the list are working
on the same file. Sublists of operations referring to different
files don't affect each other and reducing them can be thought
of as separate operations.  Also, a "deleteall" acts as a D for
everything and cancels all operations before it in the list. </para>

<para>The reduction process walks through the list from the beginning
looking for adjacent pairs of operations it can compose.  The following table
describes all possible cases and all but one of the reductions.</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='2' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <tbody>
      <row>
        <entry align='center'>M + D &rarr; D</entry>
        <entry align='left'><para>If a file is modified
        then deleted, the result is as though it had been
        deleted. If the M was the only modify for the file, it's
        removed too.</para></entry>
      </row>
      <row>
        <entry align='center'>M a + R a b &rarr; R a b + M b</entry>
        <entry align='left'><para>The purpose of this transformation is
        to push renames toward the beginning of the list,
        where they may become adjacent to another R or C they can
        be composed with. If the M is the only modify operation for
        this file, the rename is dropped.</para></entry>
      </row>
      <row>
        <entry align='center'>M a + C a b</entry>
        <entry align='left'><para>No reduction.</para></entry>
      </row>
      <row>
        <entry align='center'>M b + R a b &rarr; nothing</entry>
        <entry align='left'><para>Should be impossible, and may
        indicate repository corruption.</para></entry>
      </row>
      <row>
        <entry align='center'>M b + C a b &rarr; nothing</entry>
        <entry align='left'><para>The copy undoes the
        modification.</para></entry>
      </row>
      <row>
        <entry align='center'>D + M &rarr; M</entry>
        <entry align='left'><para>If a file is deleted and modified,
        the result is as though the deletion had not taken place
        (because M operations store entire files, not
        deltas).</para></entry>
      </row>
      <row>
        <entry align='center'>D + {D|R|C}</entry>
        <entry align='left'><para>These cases should be impossible
        and would suggest the repository has been corrupted.</para></entry>
      </row>
      <row>
        <entry align='center'>R a b + D a</entry>
        <entry align='left'><para>Should never happen, and is
        another case that would suggest repository corruption.</para></entry>
      </row>
      <row>
        <entry align='center'>R a b + D b &rarr; D a</entry>
        <entry align='left'><para>The delete removes the just-renamed file.</para></entry>
      </row>
      <row>
        <entry align='center'>{R|C} + M</entry>
        <entry align='left'><para>No reduction.</para></entry>
      </row>
      <row>
        <entry align='center'>R a b + R b c &rarr; R a c</entry>
        <entry align='left'><para>The b terms have to match for these
        operations to have made sense when they lived in separate
        commits; if they don't, it indicates repository
        corruption.</para></entry>
      </row>
      <row>
        <entry align='center'>R a b + C b c</entry>
        <entry align='left'><para>No reduction.</para></entry>
      </row>
      <row>
        <entry align='center'>C a b + D a &rarr; R a b</entry>
        <entry align='left'><para>Copy followed by delete of the source is a rename.</para></entry>
      </row>
      <row>
        <entry align='center'>C a b + D b &rarr; nothing</entry>
        <entry align='left'><para>This delete undoes the copy.</para></entry>
      </row>
      <row>
        <entry align='center'>C a b + R a c</entry>
        <entry align='left'><para>No reduction.</para></entry>
      </row>
      <row>
        <entry align='center'>C a b + R b c &rarr; C a c</entry>
        <entry align='left'><para>Copy followed by a rename of the
        target reduces to single copy</para></entry>
      </row>
      <row>
        <entry align='center'>C + C</entry>
        <entry align='left'><para>No reduction.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

</refsect1>

<refsect1 id='recovery'><title>CRASH RECOVERY</title>

<para>This section will become relevant only if
<command>reposurgeon</command> or something underneath it in the
software and hardware stack crashes while in the middle of writing out
a repository, in particular if the target directory of the rebuild is
your current directory.</para>

<para>The tool has two conflicting objectives. On the one hand, we
never want to risk clobbering a pre-existing repo.  On the other hand,
we want to be able to run this tool in a directory with a repo and
modify it in place.</para>

<para>We resolve this dilemma by playing a game of three-directory monte.</para>

<procedure>
<step><para>First, we build the repo in a freshly-created staging
directory.  If your target directory is named
<filename>/path/to/foo</filename>, the staging directory will be a
peer named <filename>/path/to/foo-stageNNNN</filename>, where NNNN is
a cookie derived from <command>reposurgeon</command>'s process
ID.</para></step>

<step>
<para>We then make an empty backup directory.  This directory will
be named <filename>/path/to/foo.~N~</filename>, where N is incremented
so as not to conflict with any existing backup directories.
<command>reposurgeon</command> never, under any circumstances,
ever deletes a backup directory.</para>

<para>So far, all operations are safe; the worst that can happen up to
this point if the process gets interrupted is that the staging and
backup directories get left behind.</para>
</step>

<step><para>The critical region begins. We first move everything in the
target directory to the backup directory.</para></step>

<step><para>Then we move everything in the staging directory to the
target.</para></step>

<step><para>We finish off by restoring untracked files in the target
directory from the backup directory. That ends the critical
region.</para></step>
</procedure>

<para>During the critical region, all signals that can be ignored are
ignored.</para>
</refsect1>

<refsect1 id='returns'><title>ERROR RETURNS</title>
<para>Returns 1 on fatal error, 0 otherwise.  In batch mode all errors
are fatal.</para>
</refsect1>

<refsect1 id='see_also'><title>SEE ALSO</title>
<para>
<citerefentry><refentrytitle>bzr</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
<citerefentry><refentrytitle>cvs</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
<citerefentry><refentrytitle>darcs</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
<citerefentry><refentrytitle>git</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
<citerefentry><refentrytitle>hg</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
<citerefentry><refentrytitle>rcs</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
<citerefentry><refentrytitle>svn</refentrytitle><manvolnum>1</manvolnum></citerefentry>.
<citerefentry><refentrytitle>bk</refentrytitle><manvolnum>1</manvolnum></citerefentry>.
</para>
</refsect1>
<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@thyrsus.com</email>; project page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>.</para>
</refsect1>
</refentry>
