#!/usr/bin/env python
#
# Brute-force Subversion-to-git conversion by history replay.
# See the manual page for deytils.
#
#TODO: Ignores after initial defaults.
#TODO: Write tests
#TODO: Translate to Go. Low priority, what it cals is slow.
#TODO: Handle mergeinfos better.
#
# By ESR, October 2019.  Some of this code was part of the original Python
# implementation of reposurgeon.
#
# Requires Python 2.7.2 or newer.  Also runs under 3.x - preserve this property!
#
# SPDX-License-Identifier: BSD-2-Clause
from __future__ import print_function

import getopt, os, shutil, subprocess, sys, tempfile, time

master_encoding = 'latin-1'

if str is bytes:  # Python 2
    polystr = str
    polybytes = bytes

else:  # Python 3

    def polystr(o):
        "Polymorphic string factory function"
        if isinstance(o, str):
            return o
        if not isinstance(o, bytes):
            return str(o)
        return str(o, encoding=master_encoding)

    def polybytes(s):
        "Polymorphic string encoding function"
        if isinstance(s, bytes):
            return s
        if not isinstance(s, str):
            return bytes(s)
        return bytes(s, encoding=master_encoding)

# Simulation of Subversion default ignores
subversion_default_ignores = """\
# A simulation of Subversion default ignores, generated by repoplayer
/*.o
/*.lo
/*.la
/*.al
/*.libs
/*.so
/*.so.[0-9]*
/*.a
/*.pyc
/*.pyo
/*.rej
/*~
/*.#*
/.*.swp
/.DS_store
.svn
"""

def croak(msg):
    sys.stderr.write("repoplayer: %s\n" % msg)
    sys.exit(1)

def capture(command):
    "Run a specified command, capturing the output."
    try:
        content = subprocess.check_output(command, shell=True, stderr=sys.stderr)
    except (subprocess.CalledProcessError, OSError) as oe:
        croak("execution of '%s' failed: %s" % (command, oe))
    return polystr(content)

def doOrDie(command):
    if os.system(command) != 0:
        print("repoplayer: '%s' failed" % command)
        raise OSError

def humanize(d):
    "Return a human-friendly description of elapsed time"
    human = ""
    if d >= 3600:
        human += "%dh" % (int(d) // 3600)
        d %= 3600
    if d >= 60:
        human += "%dm" % (int(d) // 60)
        d %= 60
    human += ("%.3fs" % d)
    return human

class Baton:
    "Ship progress indications to stdout."
    def __init__(self, prompt, endmsg='done', enable=False):
        self.prompt = prompt
        self.endmsg = endmsg
        self.lastlen = 0
        self.erase = False
        self.countfmt = None
        self.counter = 0
        if enable:
            self.stream = sys.stdout
        else:
            self.stream = None
        self.count = 0
        self.time = 0
    def __enter__(self):
        if self.stream:
            self.stream.write(self.prompt + "...[\b")
            if os.isatty(self.stream.fileno()):
                self.stream.write(" \b")
            self.stream.flush()
        self.count = 0
        self.time = time.time()
        return self
    def startcounter(self, countfmt, initial=1):
        self.countfmt = countfmt
        self.counter = initial
    def bumpcounter(self):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if self.countfmt:
                update = self.countfmt % self.counter
                self.stream.write(update + ("\b" * len(update)))
                self.stream.flush()
            else:
                self.twirl()
        self.counter = self.counter + 1
    def endcounter(self):
        if self.stream:
            w = len(self.countfmt % self.count)
            self.stream.write((" " * w) + ("\b" * w))
            self.stream.flush()
        self.countfmt = None
    def twirl(self, ch=None):
        "One twirl of the baton."
        if self.stream is None:
            return
        if self.erase:
            self.stream.write("\b" * self.lastlen)
            self.stream.write(" " * self.lastlen)
            self.stream.write("\b" * self.lastlen)
            self.erase = True
        if os.isatty(self.stream.fileno()):
            if ch:
                self.lastlen = len(ch)
                self.stream.write(ch)
                self.stream.flush()
                self.erase = "%" in ch
                if self.erase:
                    time.sleep(0.1)
            else:
                self.lastlen = 1
                self.erase = False
                if self.counter > 0 and (self.counter % (100 * 1000)) == 0:
                    self.stream.write("!")
                elif self.counter > 0 and (self.counter % (10 * 1000)) == 0:
                    self.stream.write("*")
                elif self.counter > 0 and (self.counter % (1 * 1000)) == 0:
                    self.stream.write("+")
                else:
                    self.stream.write("-/|\\"[self.count % 4])
                    self.erase = True
                self.stream.flush()
                self.counter += 1
    def __exit__(self, extype, value_unused, traceback_unused):
        if extype == KeyboardInterrupt:
            self.endmsg = "interrupted"
        #if extype == Fatal:
        #    self.endmsg = "aborted by error"
        if self.stream:
            self.stream.write("]\b...(%s sec) %s.\n" \
                              % (humanize(time.time() - self.time), self.endmsg))
        return False

def initializeReplay(repodir, checkoutdir):
    "Initialize a conversion replay."
    repodir = os.path.realpath(repodir)
    # The beginning of the horrible hack.  Create a single directory
    # that is both a Subversion checkout directory and an empty
    # git repository.
    doOrDie("svn %s co file://%s %s" % (suppression, repodir, checkoutdir))
    doOrDie("git init %s %s" % (suppression, checkoutdir))
    here = os.getcwd()
    try:
        os.chdir(checkoutdir)
        with open(".gitignore", "w") as wp:
            wp.write(subversion_default_ignores)
        with open(".git/info/exclude", "w") as wp:
            wp.write(".svn\n")
        doOrDie("git add .gitignore; git commit %s -a -m 'Simulate Subversion ignores.'" % suppression)
        maxRevision = int(capture("svn info --show-item revision"))
    finally:
        os.chdir(here)
    print("repoplayer: %d Subversion revisions found, converting in %s." % (maxRevision, checkoutdir))
    return maxRevision

def updateFrom(minRevision):
    "Apply updates in a mixed repository."
    with Baton("repoplayer", enable=not quiet) as baton:
        baton.startcounter("%%d of %d" % (maxRevision+1))
        for revision in range(minRevision, maxRevision+1):
            doOrDie("svn update -r%d %s" % (revision, suppression))
            # Parse the log entry.  Here's an example header line to make the code clearer:
            # r372 | selinger-guest | 2006-03-04 12:47:49 -0500 (Sat, 04 Mar 2006) | 2 lines
            logentry = capture("svn log --use-merge-history -r%d" % revision)
            lines = logentry.split("\n")
            # Line 0 is dashes
            (rev, author, date, _) = tuple([polystr(x.strip()) for x in lines[1].split(b"|")])
            if author == "(no author)":
                author = "no-author"
            author = "%s <%s@unknown.net>" % (author, author)
            date = date[:date.index("(")-1]
            body = polystr("\n".join(lines[2:-2]))
            body += "\n\nLegacy-ID: %s\n" % rev[1:]
            with tempfile.NamedTemporaryFile(mode="w") as wp:
                wp.write(polybytes(body))
                wp.flush()
                doOrDie("git commit %s --author='%s' --date='%s' --allow-empty --allow-empty-message -a -F %s" \
                        % (suppression, author, date, wp.name))
            baton.bumpcounter()
        baton.endcounter()


if __name__ == '__main__':
    try:
        (options, arguments) = getopt.getopt(sys.argv[1:], "qtv")
    except getopt.GetoptError as e:
        print(e)
        sys.exit(1)
    suppression = "-q"
    usetmp = False
    quiet = False
    for (switch, val) in options:
        if switch == '-q':
            quiet = True
        if switch == '-t':
            usetmp = True
        if switch == '-v':
            suppression = ""
    if len(arguments) == 0:
        croak("a repository directory name is required.")

    repodir = arguments[0]
    stem = os.path.basename(repodir)
    if not os.path.exists(repodir) or not os.path.isdir(repodir):
        croak("no such directory as " + repodir)
    try:
        startFrom = os.getcwd()
        if len(arguments) >= 2 and not os.path.exists(arguments[1]) and not usetmp:
            checkoutdir = arguments[1]
        elif usetmp:
            checkoutdir = tempfile.mkdtemp()
        elif os.path.exists(repodir + "/.svn") and os.path.exists(repodir + "/.git"):
            os.chdir(repodir)
            before = int(capture("svn info --show-item revision"))
            print("replayer: %d revisions before updating..." % before)
            doOrDie("svn %s update" % suppression)
            after = int(capture("svn info --show-item revision"))
            print("replayer: %d revisions after updating." % before)
            if before == after:
                print("replayer: conversion is up to date.")
            else:
                updateFrom(before+1)
                final = int(capture("svn info --show-item revision"))
                print("replayer: conversion updated to r%d." % final)
            sys.exit(0)
        else:
            print("repoplayer: is confused")
            sys.exit(1)
        if suppression == "":
            print("repoplayer: conversion of %s in %s" % (repodir, checkoutdir))
        maxRevision = initializeReplay(repodir, checkoutdir)
        os.chdir(checkoutdir)
        updateFrom(1)
        if usetmp:
            shutil.rmtree(".svn")
            os.chdir(startFrom)
            os.rename(checkoutdir, stem + "-git")
        else:
            print("repoplayer: %s is a mixed repository" % checkoutdir)
    except OSError as oe:
        print(oe)

# end
