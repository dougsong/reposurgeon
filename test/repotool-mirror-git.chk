feature done
blob
mark :1
data 53
#!/ysr/bin/env python
#
# rs - a repository surgeon.

reset refs/tags/lightweight-sample
commit refs/tags/lightweight-sample
mark :2
author Eric S. Raymond <esr@thyrsus.com> 1287754582 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287754582 -0400
data 22
The adventure begins.
M 100644 :1 rs

blob
mark :3
data 621
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, cid, comment, branch, parents):
        self.timestamp = timestamp
        self.id = cid
        self.comment = comment
        self.branch = branch
        self.parents = parents

class GitSlicer:
    "Repo-slicing methods for the Git version-control system"
    def __init__(repo):
        pass

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

commit refs/tags/lightweight-sample
mark :4
author Eric S. Raymond <esr@thyrsus.com> 1287755564 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287755564 -0400
data 28
Beginnings of core classes.
from :2
M 100755 :3 rs

blob
mark :5
data 1329
= Reposurgeon Designer's Notes =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that version-control
systems don't want to let you do, such as (a) editing past comments and 
metadata, (b) excising commits, and (c) coalescing commits. The motivation
for reposurgeon was to help with artifacts and sca r tisue created by 
repository conversions.

The reposurgeon tool depends on being able to map all the version-control
systems it knows about into a common data model.  Here are the components 
of the model:

1. A sequence of commit objects.  The primary key for these objects is
the date of the commit. Each commit represents an ebtire state of
some file tree.

2. A map of the is-a-parent-of relationship. A commit may have multiplre 
parents; the map implies a DAG (directed acyclic graph) of commits.

3. A list of branch heads.  This is a mapping from names to tip 
revisions in the DAG.

4. A list of tags (name-to-commit mappings).

This model is intended to capture the common semantics of distributed
version-control systems: the three specific tarhets are git, hg, and
Subversion (more may be added in future).

It is a design constraint that all reposurgeon operations either prserve
all VCS-specific metadata thety are not told to modify or warn you when
they cannot.





commit refs/tags/lightweight-sample
mark :6
author Eric S. Raymond <esr@thyrsus.com> 1287759014 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287759014 -0400
data 27
Beginning of design notes.
from :4
M 100644 :5 theory.txt

blob
mark :7
data 1022
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, comment, parents):
        self.timestamp = timestamp   # Primary key
        self.comment = comment       # Commit comment
        self.parents = parents       # List of parent nodes
        self.branch = branch         # branch name (deduced optimization hack)

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings

class GitSlicer:
    "Repo-slicing methods for the Git version-control system"
    def __init__(repo):
        pass

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

blob
mark :8
data 1329
= Reposurgeon Designer's Notes =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that version-control
systems don't want to let you do, such as (a) editing past comments and 
metadata, (b) excising commits, and (c) coalescing commits. The motivation
for reposurgeon was to help with artifacts and scar tisue created by 
repository conversions.

The reposurgeon tool depends on being able to map all the version-control
systems it knows about into a common data model.  Here are the components 
of the model:

1. A sequence of commit objects.  The primary key for these objects is
the date of the commit. Each commit represents an ebtire state of
some file tree.

2. A map of the is-a-parent-of relationship. A commit may have multiplre 
parents; the map implies a DAG (directed acyclic graph) of commits.

3. A list of branch heads.  This is a mapping from names to tip 
revisions in the DAG.

4. A list of tags (name-to-commit mappings).

This model is intended to capture the common semantics of distributed
version-control systems: the three specific tarhets are git, hg, and
Subversion (more may be added in future).

It is a design constraint that all reposurgeon operations either preserve
all VCS-specific metadata thety are not told to modify or warn you when
they cannot.





commit refs/tags/lightweight-sample
mark :9
author Eric S. Raymond <esr@thyrsus.com> 1287768418 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287768418 -0400
data 40
Sync data structures with design notes.
from :6
M 100755 :7 rs
M 100644 :8 theory.txt

blob
mark :10
data 2339
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, author, committer, comment, parents):
        self.timestamp = timestamp   # Primary key
        self.author = author         # Aujtor of commit
        self.committer = committer   # Person responsible for committing it.
        self.comment = comment       # Commit comment
        self.parents = parents       # List of parent nodes
        self.branch = branch         # branch name (deduced optimization hack)

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.__marks = []
    def fast_import(fp):
        "Initialize repo object from fast import."
        os.mkdir(".rs")     # May throw os.error
        os.mkdir(".rs/history")
        mark = None
        for line in fp:
            if line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line)
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                continue     # FIXME
            elif line.startswith("commit"):
                continue     # FIXME
            elif line.startswith("reset"):
                continue     # FIXME
            elif line.startswith("tag"):
                continue     # FIXME
            else:
                raise RepoSurgeonException("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

commit refs/tags/lightweight-sample
mark :11
author Eric S. Raymond <esr@thyrsus.com> 1287919107 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287919107 -0400
data 31
Skeleton of fast-import logic.
from :9
M 100755 :10 rs

blob
mark :12
data 4234
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, author, committer, comment, parents):
        self.timestamp = timestamp   # Primary key
        self.author = author         # Aujtor of commit
        self.committer = committer   # Person responsible for committing it.
        self.comment = comment       # Commit comment
        self.parents = parents       # List of parent nodes
        self.branch = branch         # branch name (deduced optimization hack)

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.nmarks = 0
    def fast_import(fp):
        "Initialize repo object from fast-import stream."
        os.mkdir(".rs")     # May throw OSError
        os.mkdir(".rs/history")
        tags_to_marks = {}
        import_line = 0
        def error(msg):
            raise RepoSurgeonException(msg + (" at line " + `import_line`)
        def read_data(dp):
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            else:
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueError:
                    raise error("bad count in data")
            else:
                    raise error("malformed data header")
            return
        for line in fp:
            import_line += 1
            if line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                nextline = fp.readline()
                import_line += 1
                if readline.startwith("mark"):
                    mark = nextline[5:].strip()
                    read_data(open(".rs/blob" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    error("missing mark after blob")
            elif line.startswith("data"):
                error("unexpected data object")
            elif line.startswith("commit"):
                continue     # FIXME
            elif line.startswith("reset"):
                tagname = line[4:].strip()
                nextline = fp.readline()
                import_line += 1
                if nextline.startswith("from"):
                    tags_to_marks[tagname] = nextline[5:].strip()
                else:
                    error("missing from after reset")
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                nextline = fp.readline()
                import_line += 1
                if nextline.startswith("from"):
                    tags_to_marks[tagname] = nextline[5:].strip()
                else:
                    error("missing from after tag")
                self.read_data(open(".rs/tag" + tagname, "w")).close()
            else:
                raise error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

commit refs/tags/lightweight-sample
mark :13
author Eric S. Raymond <esr@thyrsus.com> 1287925789 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287925789 -0400
data 47
Fast-import reading except for commit objects.
from :11
M 100755 :12 rs

blob
mark :14
data 8457
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance pof a person acting on the repo."
    def __init__(self, name, email, when):
        self,name = name
        self.email = email
        self.when = when
    def __repr__(self):
        return self.name + " " + self.email + " " + self.when

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = None          # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, fp):
        "Initialize repo object from fast-import stream."
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header")
            return
        def readline():
            if linebuffers:
                return linebuffers.pop()
            else:
                self.import_line += 1
                return fp.readline()
        def pushback(line):
            self.linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                nextline = readline()
                if line.startswith("mark"):
                    mark = nextline[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = currentbranch
                ncommits += 1
                inlinecount = 0
                while True:
                    nextline = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = nextline[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            (name, email, when) = line.split()
                            commit.author = Action(name, email, when)
                        except ValueSelf.Error:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            (name, email, when) = line.split()
                            commit.committer = Action(name, email, when)
                        except ValueSelf.Error:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = self.read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.ancestors.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.filemap.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.filemap.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            fileop.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            fileop.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                nextline = readline()
                if nextline.startswith("from"):
                    refs_to_marks[currentbranch] = nextline[5:].strip()
                else:
                    self.error("missing from after reset")
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                nextline = readline()
                if nextline.startswith("from"):
                    refs_to_marks[tagname] = nextline[5:].strip()
                else:
                    self.error("missing from after tag")
                self.read_data(open(".rs/tag-" + tagname, "w")).close()
            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv.pop(0)
    (options, arguments) = getopt.getopt(sys.argv[2:], "")
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        repo = GenericRepo()
        try:
            if not arguments:
                repo.fast_import(sys.stdin)
            else:
                fatal("rs: unsupported load mode")
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/tags/lightweight-sample
mark :15
author Eric S. Raymond <esr@thyrsus.com> 1287956274 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287956274 -0400
data 30
First commands are executing.
from :13
M 100755 :14 rs

blob
mark :16
data 8874
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance pof a person acting on the repo."
    def __init__(self, name, email, when):
        self.name = name
        self.email = email
        self.when = when
    def __repr__(self):
        return self.name + " " + self.email + " " + self.when

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, argv):
        "Initialize repo object from fast-import stream."
        verbose = False
        (options, arguments) = getopt.getopt(argv[1:], "v")
        for (opt, arg) in options:
            if opt == '-v':
                verbose = True
        if not arguments:
            fp = sys.stdin
        else:
            error("load subcommand does not take arguments", atline=False)
        print "Foo!", argv, options, verbose
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            if verbose:
                print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            line = line.replace(" <", "|").replace("> ", "|")
                            (name, email, when) = line[7:].strip().split("|")
                            commit.author = Action(name, email, when)
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            line = line.replace(" <", "|").replace("> ", "|")
                            (name, email, when) = line[10:].strip().split("|")
                            commit.committer = Action(name, email, when)
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.filemap.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.filemap.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[tagname] = line[5:].strip()
                else:
                    self.error("missing from after tag")
                read_data(open(".rs/tag-" + tagname, "w")).close()
            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv[0]
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        try:
            repo = GenericRepo()
            repo.fast_import(sys.argv)
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/tags/lightweight-sample
mark :17
author Eric S. Raymond <esr@thyrsus.com> 1287991809 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287991809 -0400
data 36
Options processing for subcommands.
from :15
M 100755 :16 rs

blob
mark :18
data 9978
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance pof a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, argv):
        "Initialize repo object from fast-import stream."
        verbose = False
        (options, arguments) = getopt.getopt(argv[1:], "v")
        for (opt, arg) in options:
            if opt == '-v':
                verbose = True
        if not arguments:
            fp = sys.stdin
        else:
            error("load subcommand does not take arguments", atline=False)
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv[0]
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        try:
            repo = GenericRepo()
            repo.fast_import(sys.argv)
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/tags/lightweight-sample
mark :19
author Eric S. Raymond <esr@thyrsus.com> 1287995066 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287995066 -0400
data 31
First parse of an entire dump.
from :17
M 100755 :18 rs

blob
mark :20
data 9975
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, argv):
        "Initialize repo object from fast-import stream."
        verbose = False
        (options, arguments) = getopt.getopt(argv[1:], "v")
        for (opt, arg) in options:
            if opt == '-v':
                verbose = True
        if not arguments:
            fp = sys.stdin
        else:
            error("load subcommand does not take arguments", atline=False)
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv[0]
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        try:
            repo = Repository()
            repo.fast_import(sys.argv)
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/tags/lightweight-sample
mark :21
author Eric S. Raymond <esr@thyrsus.com> 1288009568 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288009568 -0400
data 26
Typo fix and name change.
from :19
M 100755 :20 rs

blob
mark :22
data 1499
= Reposurgeon Theory of Operation =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that
version-control systems don't want to let you do, such as (a) editing
past comments and metadata, (b) excising commits, (c) coalescing
commits, and (d) removing files and subtrees from repo history. The
original motivation for reposurgeon was to clean up artifacts
created by repository conversions.

To keep reposurgeon simple and flexible, it does not do its own
repository reading and writing.  Instead, it relies on being able to
parse and emit the dump format created by git-fast-export and read by
git-fast-import.  This means that it can be used on any
version-control system that that has both fast-export and fast-import
utilities.  This set includes git itself, hg, bzr, and Subversion. As
version-control systems add support for the fast-import format, their
reppositories will automatically become editable by repoosurgeon see 
the https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools[Git 
Wiki tools page] for a large collection of such tools.

It is a design constraint that all reposurgeon operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.  Users should, however, be aware
of limitations in the ability of the fast-import format to capture 
repository state. Presently the most significant such limitation is
that the dumps do not capture git lightweight tags.





commit refs/tags/lightweight-sample
mark :23
author Eric S. Raymond <esr@thyrsus.com> 1288009592 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288009592 -0400
data 27
Upate theory of operation.
from :21
M 100644 :22 theory.txt

blob
mark :24
data 12567
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def load_repo(source):
    "Load a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist"
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.page = 1
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_load(self, line):
        if not line:
            line = '.';
        self.repo = load_repo(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :25
author Eric S. Raymond <esr@thyrsus.com> 1288031844 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288031844 -0400
data 38
First successful interpreted command.
from :23
M 100755 :24 rs

blob
mark :26
data 12575
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def load_repo(source):
    "Load a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist"
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.page = 1
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_load(self, line):
        if not line:
            line = '.';
        self.repo = load_repo(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :27
data 2028
= Reposurgeon Theory of Operation =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that
version-control systems don't want to let you do, such as (a) editing
past comments and metadata, (b) excising commits, (c) coalescing
commits, and (d) removing files and subtrees from repo history. The
original motivation for reposurgeon was to clean up artifacts
created by repository conversions.

To keep reposurgeon simple and flexible, it does not do its own
repository reading and writing.  Instead, it relies on being able to
parse and emit the dump format created by git-fast-export and read by
git-fast-import.  This means that it can be used on any
version-control system that that has both fast-export and fast-import
utilities.  This set includes git itself, hg, and bzr. 

Subversion/RCS/CVS aren't directly supported because exporting from
them requires fixups of usernames in the committer information to full
email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform dump files and cope with the export/import himself.

As version-control systems add support for the fast-import format,
their reppositories will automatically become editable by repoosurgeon
see the
https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools[Git
Wiki tools page] for a large collection of such tools.

It is a design constraint that all reposurgeon operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.  Users should, however, be aware
of limitations in the ability of the fast-import format to capture 
repository state. Presently the most significant such known 
limitations are:

* Under git, dumps do not capture git lightweight tags.

* Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.





commit refs/tags/lightweight-sample
mark :28
author Eric S. Raymond <esr@thyrsus.com> 1288032988 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288032988 -0400
data 22
Document limitations.
from :25
M 100755 :26 rs
M 100644 :27 theory.txt

blob
mark :29
data 12893
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def load_repo(source):
    "Load a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist"
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.page = 1
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_load(self, line):
        if not line:
            line = '.';
        self.repo = load_repo(line)
        print "rs: %d commits, %d blobs, %d marks, %d tags" % \
              (len(self.repo.commits),
               self.repo.nblobs,
               self.repo.nmarks,
               len(self.repo.tags))
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :30
author Eric S. Raymond <esr@thyrsus.com> 1288033905 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288033905 -0400
data 32
Fix a bug, add instrumentation.
from :28
M 100755 :29 rs

blob
mark :31
data 13693
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source):
    "Read a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(target):
    "Write a repository using fast-export."
    pass

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        self.repo.fast_export(sys.stdout)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :32
author Eric S. Raymond <esr@thyrsus.com> 1288035346 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288035346 -0400
data 43
Partial fast-export (everything but blobs.
from :30
M 100755 :31 rs

blob
mark :33
data 14364
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source):
    "Read a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(target):
    "Write a repository using fast-export."
    pass

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        self.repo.fast_export(sys.stdout)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :34
author Eric S. Raymond <esr@thyrsus.com> 1288049092 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288049092 -0400
data 30
Blob dumping appears to work.
from :32
M 100755 :33 rs

blob
mark :35
data 14865
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :36
author Eric S. Raymond <esr@thyrsus.com> 1288057381 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288057381 -0400
data 40
We interpret command-ine arguments now.
from :34
M 100755 :35 rs

blob
mark :37
data 15019
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob\nmark %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :38
author Eric S. Raymond <esr@thyrsus.com> 1288058277 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288058277 -0400
data 53
We're pretty close to round-tripping a git dump now.
from :36
M 100755 :37 rs

blob
mark :39
data 15203
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.refs_to_branches = {}
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[7:].strip()
                line = readline()
                if line.startswith("from"):
                    self.refs_to_branches[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob\nmark %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        branches = self.refs_to_branches.keys()
        for branch in branches:
            fp.write("reset %s\nmark %s\n\n" % (branch, self.refs_to_branches[branch]))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :40
author Eric S. Raymond <esr@thyrsus.com> 1288068011 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288068011 -0400
data 53
Checkpoint before tring to write only requred marks.
from :38
M 100755 :39 rs

blob
mark :41
data 15448
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.refs_to_branches = {}
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    self.refs_to_branches[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob\nmark %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        branches = self.refs_to_branches.keys()
        for branch in branches:
            fp.write("reset %s\nfrom %s\n\n" % (branch, self.refs_to_branches[branch]))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :42
author Eric S. Raymond <esr@thyrsus.com> 1288069444 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288069444 -0400
data 62
This round-trips everything except the lightweight tag stuff.
from :40
M 100755 :41 rs

blob
mark :43
data 15549
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __repr__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __repr__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(repr(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :44
author Eric S. Raymond <esr@thyrsus.com> 1288082031 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288082031 -0400
data 40
OK, now we have perfect round-tripping.
from :42
M 100755 :43 rs

blob
mark :45
data 465
			rs - a repository surgeon

eposurgeon enables risky operations that version-control systems don't
want to let you do, such as (a) editing past comments and metadata,
(b) excising commits, (c) coalescing commits, and (d) removing files
and subtrees from repo history. The original motivation for
reposurgeon was to clean up artifacts created by repository
conversions.

To test the correctness of this software, change to the 'test' subdirectory
and type 'make'.

blob
mark :46
data 15565
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __repr__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __repr__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(repr(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :47
data 362
# Test-suite makefile for rs

all: roundtrip

# Test that all dumpfiles round-trip properly
# Test suceeds if there is no output.
roundtrip:
	echo "Testing round-tripping of dump file. No diff output is good news."
	for file in *.dump; do \
	    ../rs "read -;write -" <$$file >/tmp/rs$$$$; \
	    diff -u $${file} /tmp/rs$$$$; \
	    rm -f /tmp/rs$$$$; \
	done

blob
mark :48
data 183504
blob
mark :1
data 53
#!/ysr/bin/env python
#
# rs - a repository surgeon.

reset refs/heads/master
commit refs/heads/master
mark :2
author Eric S. Raymond <esr@thyrsus.com> 1287754582 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287754582 -0400
data 22
The adventure begins.
M 100644 :1 rs

blob
mark :3
data 621
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, cid, comment, branch, parents):
        self.timestamp = timestamp
        self.id = cid
        self.comment = comment
        self.branch = branch
        self.parents = parents

class GitSlicer:
    "Repo-slicing methods for the Git version-control system"
    def __init__(repo):
        pass

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

commit refs/heads/master
mark :4
author Eric S. Raymond <esr@thyrsus.com> 1287755564 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287755564 -0400
data 28
Beginnings of core classes.
from :2
M 100755 :3 rs

blob
mark :5
data 1329
= Reposurgeon Designer's Notes =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that version-control
systems don't want to let you do, such as (a) editing past comments and 
metadata, (b) excising commits, and (c) coalescing commits. The motivation
for reposurgeon was to help with artifacts and sca r tisue created by 
repository conversions.

The reposurgeon tool depends on being able to map all the version-control
systems it knows about into a common data model.  Here are the components 
of the model:

1. A sequence of commit objects.  The primary key for these objects is
the date of the commit. Each commit represents an ebtire state of
some file tree.

2. A map of the is-a-parent-of relationship. A commit may have multiplre 
parents; the map implies a DAG (directed acyclic graph) of commits.

3. A list of branch heads.  This is a mapping from names to tip 
revisions in the DAG.

4. A list of tags (name-to-commit mappings).

This model is intended to capture the common semantics of distributed
version-control systems: the three specific tarhets are git, hg, and
Subversion (more may be added in future).

It is a design constraint that all reposurgeon operations either prserve
all VCS-specific metadata thety are not told to modify or warn you when
they cannot.





commit refs/heads/master
mark :6
author Eric S. Raymond <esr@thyrsus.com> 1287759014 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287759014 -0400
data 27
Beginning of design notes.
from :4
M 100644 :5 theory.txt

blob
mark :7
data 1022
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, comment, parents):
        self.timestamp = timestamp   # Primary key
        self.comment = comment       # Commit comment
        self.parents = parents       # List of parent nodes
        self.branch = branch         # branch name (deduced optimization hack)

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings

class GitSlicer:
    "Repo-slicing methods for the Git version-control system"
    def __init__(repo):
        pass

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

blob
mark :8
data 1329
= Reposurgeon Designer's Notes =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that version-control
systems don't want to let you do, such as (a) editing past comments and 
metadata, (b) excising commits, and (c) coalescing commits. The motivation
for reposurgeon was to help with artifacts and scar tisue created by 
repository conversions.

The reposurgeon tool depends on being able to map all the version-control
systems it knows about into a common data model.  Here are the components 
of the model:

1. A sequence of commit objects.  The primary key for these objects is
the date of the commit. Each commit represents an ebtire state of
some file tree.

2. A map of the is-a-parent-of relationship. A commit may have multiplre 
parents; the map implies a DAG (directed acyclic graph) of commits.

3. A list of branch heads.  This is a mapping from names to tip 
revisions in the DAG.

4. A list of tags (name-to-commit mappings).

This model is intended to capture the common semantics of distributed
version-control systems: the three specific tarhets are git, hg, and
Subversion (more may be added in future).

It is a design constraint that all reposurgeon operations either preserve
all VCS-specific metadata thety are not told to modify or warn you when
they cannot.





commit refs/heads/master
mark :9
author Eric S. Raymond <esr@thyrsus.com> 1287768418 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287768418 -0400
data 40
Sync data structures with design notes.
from :6
M 100755 :7 rs
M 100644 :8 theory.txt

blob
mark :10
data 2339
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, author, committer, comment, parents):
        self.timestamp = timestamp   # Primary key
        self.author = author         # Aujtor of commit
        self.committer = committer   # Person responsible for committing it.
        self.comment = comment       # Commit comment
        self.parents = parents       # List of parent nodes
        self.branch = branch         # branch name (deduced optimization hack)

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.__marks = []
    def fast_import(fp):
        "Initialize repo object from fast import."
        os.mkdir(".rs")     # May throw os.error
        os.mkdir(".rs/history")
        mark = None
        for line in fp:
            if line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line)
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                continue     # FIXME
            elif line.startswith("commit"):
                continue     # FIXME
            elif line.startswith("reset"):
                continue     # FIXME
            elif line.startswith("tag"):
                continue     # FIXME
            else:
                raise RepoSurgeonException("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

commit refs/heads/master
mark :11
author Eric S. Raymond <esr@thyrsus.com> 1287919107 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287919107 -0400
data 31
Skeleton of fast-import logic.
from :9
M 100755 :10 rs

blob
mark :12
data 4234
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, author, committer, comment, parents):
        self.timestamp = timestamp   # Primary key
        self.author = author         # Aujtor of commit
        self.committer = committer   # Person responsible for committing it.
        self.comment = comment       # Commit comment
        self.parents = parents       # List of parent nodes
        self.branch = branch         # branch name (deduced optimization hack)

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.nmarks = 0
    def fast_import(fp):
        "Initialize repo object from fast-import stream."
        os.mkdir(".rs")     # May throw OSError
        os.mkdir(".rs/history")
        tags_to_marks = {}
        import_line = 0
        def error(msg):
            raise RepoSurgeonException(msg + (" at line " + `import_line`)
        def read_data(dp):
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            else:
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueError:
                    raise error("bad count in data")
            else:
                    raise error("malformed data header")
            return
        for line in fp:
            import_line += 1
            if line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                nextline = fp.readline()
                import_line += 1
                if readline.startwith("mark"):
                    mark = nextline[5:].strip()
                    read_data(open(".rs/blob" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    error("missing mark after blob")
            elif line.startswith("data"):
                error("unexpected data object")
            elif line.startswith("commit"):
                continue     # FIXME
            elif line.startswith("reset"):
                tagname = line[4:].strip()
                nextline = fp.readline()
                import_line += 1
                if nextline.startswith("from"):
                    tags_to_marks[tagname] = nextline[5:].strip()
                else:
                    error("missing from after reset")
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                nextline = fp.readline()
                import_line += 1
                if nextline.startswith("from"):
                    tags_to_marks[tagname] = nextline[5:].strip()
                else:
                    error("missing from after tag")
                self.read_data(open(".rs/tag" + tagname, "w")).close()
            else:
                raise error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

commit refs/heads/master
mark :13
author Eric S. Raymond <esr@thyrsus.com> 1287925789 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287925789 -0400
data 47
Fast-import reading except for commit objects.
from :11
M 100755 :12 rs

blob
mark :14
data 8457
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance pof a person acting on the repo."
    def __init__(self, name, email, when):
        self,name = name
        self.email = email
        self.when = when
    def __repr__(self):
        return self.name + " " + self.email + " " + self.when

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = None          # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, fp):
        "Initialize repo object from fast-import stream."
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header")
            return
        def readline():
            if linebuffers:
                return linebuffers.pop()
            else:
                self.import_line += 1
                return fp.readline()
        def pushback(line):
            self.linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                nextline = readline()
                if line.startswith("mark"):
                    mark = nextline[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = currentbranch
                ncommits += 1
                inlinecount = 0
                while True:
                    nextline = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = nextline[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            (name, email, when) = line.split()
                            commit.author = Action(name, email, when)
                        except ValueSelf.Error:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            (name, email, when) = line.split()
                            commit.committer = Action(name, email, when)
                        except ValueSelf.Error:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = self.read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.ancestors.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.filemap.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.filemap.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            fileop.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            fileop.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                nextline = readline()
                if nextline.startswith("from"):
                    refs_to_marks[currentbranch] = nextline[5:].strip()
                else:
                    self.error("missing from after reset")
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                nextline = readline()
                if nextline.startswith("from"):
                    refs_to_marks[tagname] = nextline[5:].strip()
                else:
                    self.error("missing from after tag")
                self.read_data(open(".rs/tag-" + tagname, "w")).close()
            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv.pop(0)
    (options, arguments) = getopt.getopt(sys.argv[2:], "")
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        repo = GenericRepo()
        try:
            if not arguments:
                repo.fast_import(sys.stdin)
            else:
                fatal("rs: unsupported load mode")
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/heads/master
mark :15
author Eric S. Raymond <esr@thyrsus.com> 1287956274 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287956274 -0400
data 30
First commands are executing.
from :13
M 100755 :14 rs

blob
mark :16
data 8874
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance pof a person acting on the repo."
    def __init__(self, name, email, when):
        self.name = name
        self.email = email
        self.when = when
    def __repr__(self):
        return self.name + " " + self.email + " " + self.when

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, argv):
        "Initialize repo object from fast-import stream."
        verbose = False
        (options, arguments) = getopt.getopt(argv[1:], "v")
        for (opt, arg) in options:
            if opt == '-v':
                verbose = True
        if not arguments:
            fp = sys.stdin
        else:
            error("load subcommand does not take arguments", atline=False)
        print "Foo!", argv, options, verbose
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            if verbose:
                print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            line = line.replace(" <", "|").replace("> ", "|")
                            (name, email, when) = line[7:].strip().split("|")
                            commit.author = Action(name, email, when)
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            line = line.replace(" <", "|").replace("> ", "|")
                            (name, email, when) = line[10:].strip().split("|")
                            commit.committer = Action(name, email, when)
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.filemap.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.filemap.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[tagname] = line[5:].strip()
                else:
                    self.error("missing from after tag")
                read_data(open(".rs/tag-" + tagname, "w")).close()
            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv[0]
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        try:
            repo = GenericRepo()
            repo.fast_import(sys.argv)
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/heads/master
mark :17
author Eric S. Raymond <esr@thyrsus.com> 1287991809 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287991809 -0400
data 36
Options processing for subcommands.
from :15
M 100755 :16 rs

blob
mark :18
data 9978
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance pof a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, argv):
        "Initialize repo object from fast-import stream."
        verbose = False
        (options, arguments) = getopt.getopt(argv[1:], "v")
        for (opt, arg) in options:
            if opt == '-v':
                verbose = True
        if not arguments:
            fp = sys.stdin
        else:
            error("load subcommand does not take arguments", atline=False)
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv[0]
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        try:
            repo = GenericRepo()
            repo.fast_import(sys.argv)
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/heads/master
mark :19
author Eric S. Raymond <esr@thyrsus.com> 1287995066 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287995066 -0400
data 31
First parse of an entire dump.
from :17
M 100755 :18 rs

blob
mark :20
data 9975
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, argv):
        "Initialize repo object from fast-import stream."
        verbose = False
        (options, arguments) = getopt.getopt(argv[1:], "v")
        for (opt, arg) in options:
            if opt == '-v':
                verbose = True
        if not arguments:
            fp = sys.stdin
        else:
            error("load subcommand does not take arguments", atline=False)
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv[0]
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        try:
            repo = Repository()
            repo.fast_import(sys.argv)
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/heads/master
mark :21
author Eric S. Raymond <esr@thyrsus.com> 1288009568 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288009568 -0400
data 26
Typo fix and name change.
from :19
M 100755 :20 rs

blob
mark :22
data 1499
= Reposurgeon Theory of Operation =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that
version-control systems don't want to let you do, such as (a) editing
past comments and metadata, (b) excising commits, (c) coalescing
commits, and (d) removing files and subtrees from repo history. The
original motivation for reposurgeon was to clean up artifacts
created by repository conversions.

To keep reposurgeon simple and flexible, it does not do its own
repository reading and writing.  Instead, it relies on being able to
parse and emit the dump format created by git-fast-export and read by
git-fast-import.  This means that it can be used on any
version-control system that that has both fast-export and fast-import
utilities.  This set includes git itself, hg, bzr, and Subversion. As
version-control systems add support for the fast-import format, their
reppositories will automatically become editable by repoosurgeon see 
the https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools[Git 
Wiki tools page] for a large collection of such tools.

It is a design constraint that all reposurgeon operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.  Users should, however, be aware
of limitations in the ability of the fast-import format to capture 
repository state. Presently the most significant such limitation is
that the dumps do not capture git lightweight tags.





commit refs/heads/master
mark :23
author Eric S. Raymond <esr@thyrsus.com> 1288009592 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288009592 -0400
data 27
Upate theory of operation.
from :21
M 100644 :22 theory.txt

blob
mark :24
data 12567
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def load_repo(source):
    "Load a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist"
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.page = 1
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_load(self, line):
        if not line:
            line = '.';
        self.repo = load_repo(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :25
author Eric S. Raymond <esr@thyrsus.com> 1288031844 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288031844 -0400
data 38
First successful interpreted command.
from :23
M 100755 :24 rs

blob
mark :26
data 12575
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def load_repo(source):
    "Load a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist"
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.page = 1
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_load(self, line):
        if not line:
            line = '.';
        self.repo = load_repo(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :27
data 2028
= Reposurgeon Theory of Operation =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that
version-control systems don't want to let you do, such as (a) editing
past comments and metadata, (b) excising commits, (c) coalescing
commits, and (d) removing files and subtrees from repo history. The
original motivation for reposurgeon was to clean up artifacts
created by repository conversions.

To keep reposurgeon simple and flexible, it does not do its own
repository reading and writing.  Instead, it relies on being able to
parse and emit the dump format created by git-fast-export and read by
git-fast-import.  This means that it can be used on any
version-control system that that has both fast-export and fast-import
utilities.  This set includes git itself, hg, and bzr. 

Subversion/RCS/CVS aren't directly supported because exporting from
them requires fixups of usernames in the committer information to full
email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform dump files and cope with the export/import himself.

As version-control systems add support for the fast-import format,
their reppositories will automatically become editable by repoosurgeon
see the
https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools[Git
Wiki tools page] for a large collection of such tools.

It is a design constraint that all reposurgeon operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.  Users should, however, be aware
of limitations in the ability of the fast-import format to capture 
repository state. Presently the most significant such known 
limitations are:

* Under git, dumps do not capture git lightweight tags.

* Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.





commit refs/heads/master
mark :28
author Eric S. Raymond <esr@thyrsus.com> 1288032988 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288032988 -0400
data 22
Document limitations.
from :25
M 100755 :26 rs
M 100644 :27 theory.txt

blob
mark :29
data 12893
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def load_repo(source):
    "Load a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist"
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.page = 1
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_load(self, line):
        if not line:
            line = '.';
        self.repo = load_repo(line)
        print "rs: %d commits, %d blobs, %d marks, %d tags" % \
              (len(self.repo.commits),
               self.repo.nblobs,
               self.repo.nmarks,
               len(self.repo.tags))
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :30
author Eric S. Raymond <esr@thyrsus.com> 1288033905 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288033905 -0400
data 32
Fix a bug, add instrumentation.
from :28
M 100755 :29 rs

blob
mark :31
data 13693
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source):
    "Read a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(target):
    "Write a repository using fast-export."
    pass

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        self.repo.fast_export(sys.stdout)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :32
author Eric S. Raymond <esr@thyrsus.com> 1288035346 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288035346 -0400
data 43
Partial fast-export (everything but blobs.
from :30
M 100755 :31 rs

blob
mark :33
data 14364
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source):
    "Read a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(target):
    "Write a repository using fast-export."
    pass

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        self.repo.fast_export(sys.stdout)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :34
author Eric S. Raymond <esr@thyrsus.com> 1288049092 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288049092 -0400
data 30
Blob dumping appears to work.
from :32
M 100755 :33 rs

blob
mark :35
data 14865
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :36
author Eric S. Raymond <esr@thyrsus.com> 1288057381 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288057381 -0400
data 40
We interpret command-ine arguments now.
from :34
M 100755 :35 rs

blob
mark :37
data 15019
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob\nmark %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :38
author Eric S. Raymond <esr@thyrsus.com> 1288058277 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288058277 -0400
data 53
We're pretty close to round-tripping a git dump now.
from :36
M 100755 :37 rs

blob
mark :39
data 15203
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.refs_to_branches = {}
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[7:].strip()
                line = readline()
                if line.startswith("from"):
                    self.refs_to_branches[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob\nmark %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        branches = self.refs_to_branches.keys()
        for branch in branches:
            fp.write("reset %s\nmark %s\n\n" % (branch, self.refs_to_branches[branch]))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :40
author Eric S. Raymond <esr@thyrsus.com> 1288068011 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288068011 -0400
data 53
Checkpoint before tring to write only requred marks.
from :38
M 100755 :39 rs

blob
mark :41
data 15448
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.refs_to_branches = {}
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    self.refs_to_branches[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob\nmark %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        branches = self.refs_to_branches.keys()
        for branch in branches:
            fp.write("reset %s\nfrom %s\n\n" % (branch, self.refs_to_branches[branch]))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :42
author Eric S. Raymond <esr@thyrsus.com> 1288069444 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288069444 -0400
data 62
This round-trips everything except the lightweight tag stuff.
from :40
M 100755 :41 rs

reset refs/heads/master
from :42

reset refs/tags/foo
from :42


commit refs/tags/lightweight-sample
mark :49
author Eric S. Raymond <esr@thyrsus.com> 1288083745 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288083745 -0400
data 36
Add and document a regression test.
from :44
M 100644 :45 READ[ME].txt
M 100755 :46 rs
M 100644 :47 test/Makefile
M 100644 :48 test/simple.dump

blob
mark :50
data 1969
= Reposurgeon Theory of Operation =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that
version-control systems don't want to let you do, such as (a) editing
past comments and metadata, (b) excising commits, (c) coalescing
commits, and (d) removing files and subtrees from repo history. The
original motivation for reposurgeon was to clean up artifacts
created by repository conversions.

To keep reposurgeon simple and flexible, it does not do its own
repository reading and writing.  Instead, it relies on being able to
parse and emit the dump format created by git-fast-export and read by
git-fast-import.  This means that it can be used on any
version-control system that that has both fast-export and fast-import
utilities.  This set includes git itself, hg, and bzr. 

Subversion/RCS/CVS aren't directly supported because exporting from
them requires fixups of usernames in the committer information to full
email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform dump files and cope with the export/import himself.

As version-control systems add support for the fast-import format,
their repositories will automatically become editable by reposurgeon
see the
https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools[Git
Wiki tools page] for a large collection of such tools.

It is a design constraint that all reposurgeon operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.  Users should, however, be aware
of limitations in the ability of the fast-import format to capture 
repository state. Presently the most significant such known 
limitations are:

* Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.





commit refs/tags/lightweight-sample
mark :51
author Eric S. Raymond <esr@thyrsus.com> 1288083882 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288083882 -0400
data 53
git-fast-export captures lightweight tags after all.
from :49
M 100644 :50 theory.txt

blob
mark :52
data 15686
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __repr__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __repr__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(repr(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :53
author Eric S. Raymond <esr@thyrsus.com> 1288087302 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288087302 -0400
data 34
Re-enable command interpretation.
from :51
M 100755 :52 rs

blob
mark :54
data 15680
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :55
author Eric S. Raymond <esr@thyrsus.com> 1288087772 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288087772 -0400
data 13
repr -> str.
from :53
M 100755 :54 rs

blob
mark :56
data 364
# Test-suite makefile for rs

all: roundtrip

# Test that all dumpfiles round-trip properly
# Test suceeds if there is no output.
roundtrip:
	@echo "Testing round-tripping of dump file. No diff output is good news."
	@for file in *.dump; do \
	    ../rs "read -;write -" <$$file >/tmp/rs$$$$; \
	    diff -u $${file} /tmp/rs$$$$; \
	    rm -f /tmp/rs$$$$; \
	done

commit refs/tags/lightweight-sample
mark :57
author Eric S. Raymond <esr@thyrsus.com> 1288087832 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288087832 -0400
data 37
Quiet the regression tests a little.
from :55
M 100644 :56 test/Makefile

blob
mark :58
data 15311
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :59
author Eric S. Raymond <esr@thyrsus.com> 1288088010 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288088010 -0400
data 28
Pass through mystery lines.
from :57
M 100755 :58 rs

blob
mark :60
data 16156
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :61
author Eric S. Raymond <esr@thyrsus.com> 1288092270 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288092270 -0400
data 28
Add do_shell and some help.
from :59
M 100755 :60 rs

blob
mark :62
data 20
*.1
*.html
MANIFEST

blob
mark :63
data 717
#
# makefile for reposugeon
#
VERS=1.0

SOURCES = README COPYING reposurgeon reposurgeon.xml reposurgeon.6 Makefile reposurgeon.spec

all: reposurgeon.1

reposurgeon.1: reposurgeon.xml
	xmlto man reposurgeon.xml

reposurgeon.html: reposurgeon.xml
	xmlto html-nochunks reposurgeon.xml

clean:
	rm -f *~ *.1 *.html MANIFEST SHIPPER.*

reposurgeon-$(VERS).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:reposurgeon-$(VERS)/: >MANIFEST
	@(cd ..; ln -s reposurgeon reposurgeon-$(VERS))
	(cd ..; tar -czvf reposurgeon/reposurgeon-$(VERS).tar.gz `cat reposurgeon/MANIFEST`)
	@(cd ..; rm reposurgeon-$(VERS))

dist: reposurgeon-$(VERS).tar.gz

release: reposurgeon-$(VERS).tar.gz reposurgeon.html
	shipper -u -m -t; make clean

blob
mark :64
data 5972
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>rs</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose' option.</para>

<para>Here are the available commands:</para>

<variablelist>
<varlistentry><term>help</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry><term>version</term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry><term>verbose</term>
<listitem><para>'verbose 1' enables progress and statistics messages,
'verbose 0' disables them. 
</para></listitem>
</varlistentry>
<varlistentry><term>shell</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry><term>read</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


blob
mark :65
data 16419
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes))
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :66
author Eric S. Raymond <esr@thyrsus.com> 1288093185 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288093185 -0400
data 65
Add doccumentation, a makefile, help commands, and shell escape.
from :61
M 100644 :62 .gitignore
M 100644 :63 Makefile
M 100644 :64 reposurgeon.xml
M 100755 :65 rs

blob
mark :67
data 823
#
# makefile for reposugeon
#
VERS=VERS=$(shell sed <reposurgeon -n -e '/version=\(.*\)/s//\1/p')

SOURCES = README COPYING reposurgeon reposurgeon.xml reposurgeon.6 Makefile reposurgeon.spec

all: reposurgeon.1

reposurgeon.1: reposurgeon.xml
	xmlto man reposurgeon.xml

reposurgeon.html: reposurgeon.xml
	xmlto html-nochunks reposurgeon.xml

clean:
	rm -f *~ *.1 *.html MANIFEST SHIPPER.*

reposurgeon-$(VERS).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:reposurgeon-$(VERS)/: >MANIFEST
	@(cd ..; ln -s reposurgeon reposurgeon-$(VERS))
	(cd ..; tar -czvf reposurgeon/reposurgeon-$(VERS).tar.gz `cat reposurgeon/MANIFEST`)
	@(cd ..; rm reposurgeon-$(VERS))

version:
	@echo $(VERS)

test:
	cd test; make

dist: reposurgeon-$(VERS).tar.gz

release: reposurgeon-$(VERS).tar.gz reposurgeon.html
	shipper -u -m -t; make clean

blob
mark :68
data 373
# Test-suite makefile for rs

all: roundtrip

# Test that all dumpfiles round-trip properly
# Test suceeds if there is no output.
roundtrip:
	@echo "Testing round-tripping of dump file. No diff output is good news."
	@for file in *.dump; do \
	    ../reposurgeon "read -;write -" <$$file >/tmp/rs$$$$; \
	    diff -u $${file} /tmp/rs$$$$; \
	    rm -f /tmp/rs$$$$; \
	done

commit refs/tags/lightweight-sample
mark :69
author Eric S. Raymond <esr@thyrsus.com> 1288093585 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288093585 -0400
data 13
Name change.
from :66
M 100644 :67 Makefile
M 100755 :65 reposurgeon
D rs
M 100644 :68 test/Makefile

blob
mark :70
data 824
#
# makefile for reposugeon
#
VERS=VERS=$(shell sed <reposurgeon -n -e '/version=\(.*\)/s//\1/p')

SOURCES = README COPYING reposurgeon reposurgeon.xml reposurgeon.6 Makefile reposurgeon.spec

all: reposurgeon.1

reposurgeon.1: reposurgeon.xml
	xmlto man reposurgeon.xml

reposurgeon.html: reposurgeon.xml
	xmlto html-nochunks reposurgeon.xml

clean:
	rm -f *~ *.1 *.html MANIFEST SHIPPER.*

reposurgeon-$(VERS).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:reposurgeon-$(VERS)/: >MANIFEST
	@(cd ..; ln -s reposurgeon reposurgeon-$(VERS))
	(cd ..; tar -czvf reposurgeon/reposurgeon-$(VERS).tar.gz `cat reposurgeon/MANIFEST`)
	@(cd ..; rm reposurgeon-$(VERS))

version:
	@echo $(VERS)

check:
	cd test; make

dist: reposurgeon-$(VERS).tar.gz

release: reposurgeon-$(VERS).tar.gz reposurgeon.html
	shipper -u -m -t; make clean

commit refs/tags/lightweight-sample
mark :71
author Eric S. Raymond <esr@thyrsus.com> 1288093728 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288093728 -0400
data 27
Avoid an aliasing problem.
from :69
M 100644 :70 Makefile

blob
mark :72
data 825
#
# makefile for reposurgeon
#
VERS=VERS=$(shell sed <reposurgeon -n -e '/version=\(.*\)/s//\1/p')

SOURCES = README COPYING reposurgeon reposurgeon.xml reposurgeon.6 Makefile reposurgeon.spec

all: reposurgeon.1

reposurgeon.1: reposurgeon.xml
	xmlto man reposurgeon.xml

reposurgeon.html: reposurgeon.xml
	xmlto html-nochunks reposurgeon.xml

clean:
	rm -f *~ *.1 *.html MANIFEST SHIPPER.*

reposurgeon-$(VERS).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:reposurgeon-$(VERS)/: >MANIFEST
	@(cd ..; ln -s reposurgeon reposurgeon-$(VERS))
	(cd ..; tar -czvf reposurgeon/reposurgeon-$(VERS).tar.gz `cat reposurgeon/MANIFEST`)
	@(cd ..; rm reposurgeon-$(VERS))

version:
	@echo $(VERS)

check:
	cd test; make

dist: reposurgeon-$(VERS).tar.gz

release: reposurgeon-$(VERS).tar.gz reposurgeon.html
	shipper -u -m -t; make clean

blob
mark :73
data 16481
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"reposurgeon: could not find a repository under %s" % source
            return None
        if verbose:
            print "reposurgeon: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes))
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :74
data 5981
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose' option.</para>

<para>Here are the available commands:</para>

<variablelist>
<varlistentry><term>help</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry><term>version</term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry><term>verbose</term>
<listitem><para>'verbose 1' enables progress and statistics messages,
'verbose 0' disables them. 
</para></listitem>
</varlistentry>
<varlistentry><term>shell</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry><term>read</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/lightweight-sample
mark :75
author Eric S. Raymond <esr@thyrsus.com> 1288093891 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288093891 -0400
data 26
Follow up on name change.
from :71
M 100644 :72 Makefile
M 100644 :74 reposurgeon.xml
M 100755 :73 reposurgeon

blob
mark :76
data 808
#
# makefile for reposurgeon
#
VERS=VERS=$(shell sed <reposurgeon -n -e '/version=\(.*\)/s//\1/p')

SOURCES = README COPYING reposurgeon reposurgeon.xml reposurgeon.1 Makefile

all: reposurgeon.1

reposurgeon.1: reposurgeon.xml
	xmlto man reposurgeon.xml

reposurgeon.html: reposurgeon.xml
	xmlto html-nochunks reposurgeon.xml

clean:
	rm -f *~ *.1 *.html MANIFEST SHIPPER.*

reposurgeon-$(VERS).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:reposurgeon-$(VERS)/: >MANIFEST
	@(cd ..; ln -s reposurgeon reposurgeon-$(VERS))
	(cd ..; tar -czvf reposurgeon/reposurgeon-$(VERS).tar.gz `cat reposurgeon/MANIFEST`)
	@(cd ..; rm reposurgeon-$(VERS))

version:
	@echo $(VERS)

check:
	cd test; make

dist: reposurgeon-$(VERS).tar.gz

release: reposurgeon-$(VERS).tar.gz reposurgeon.html
	shipper -u -m -t; make clean

commit refs/tags/lightweight-sample
mark :77
author Eric S. Raymond <esr@thyrsus.com> 1288093998 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288093998 -0400
data 22
There is no specfile.
from :75
M 100644 :76 Makefile

blob
mark :78
data 18449
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        if verbose:
            if preferred:
                print "reposurgeon: looking for a %s repo..."
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            # FIXME: preference is not implemented
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % source
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % source
            return None
        elif verbose:
            print "reposurgeon: recognized %s repository under %s" % (foundname, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, preferred, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    elif os.path.isdir(source):
        # FIXME
        print >>sys.stderr, "reposurgeon: directory writes are not yet supported."
    elif os.path.exists(source):
        print >>sys.stderr, "reposurgeon: file %s already exists" % source
    else:
        repo.fast_export(open(source, "w"))

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes))
    def do_prefer(self):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(map(lambda x: x[0], vcstypes))
            if line.lower() in map(lambda x: x.lower(), known):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.verbose:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Write out the results of repo surgery."
        # FIXME: Default to . if we read from a directory
        if not line:
            line = '-'
        write_repo(self.repo, line, self.preferred, self.verbose)
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :79
data 6606
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose' option.</para>

<para>Here are the available commands:</para>

<variablelist>
<varlistentry>
<term>help</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term>version</term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term>verbose</term>
<listitem><para>'verbose 1' enables progress and statistics messages,
'verbose 0' disables them. 
</para></listitem>
</varlistentry>
<varlistentry>
<term>shell</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term>prefer</term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>read</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/lightweight-sample
mark :80
author Eric S. Raymond <esr@thyrsus.com> 1288100146 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288100146 -0400
data 22
Implemented 'prefer'.
from :77
M 100644 :79 reposurgeon.xml
M 100755 :78 reposurgeon

blob
mark :81
data 18498
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
    "bzr" : (".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    }

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        if verbose:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % source
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % source
            return None
        elif verbose:
            print "reposurgeon: recognized %s repository under %s" % (foundname, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, preferred, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    elif os.path.isdir(source):
        # FIXME
        print >>sys.stderr, "reposurgeon: directory writes are not yet supported."
    elif os.path.exists(source):
        print >>sys.stderr, "reposurgeon: file %s already exists" % source
    else:
        repo.fast_export(open(source, "w"))

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.verbose:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Write out the results of repo surgery."
        # FIXME: Default to . if we read from a directory
        if not line:
            line = '-'
        write_repo(self.repo, line, self.preferred, self.verbose)
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :82
author Eric S. Raymond <esr@thyrsus.com> 1288101062 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288101062 -0400
data 38
Fix buggy implementation of "prefer".
from :80
M 100755 :81 reposurgeon

blob
mark :83
data 18416
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
    "bzr" : (".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    }

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        if verbose:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % source
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % source
            return None
        elif verbose:
            print "reposurgeon: recognized %s repository under %s" % (foundname, source)
        try:
            repo = Repository()
            repo.type = foundname 
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def write_repo(repo, target, preferred, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    elif os.path.isdir(source):
        # FIXME
        print >>sys.stderr, "reposurgeon: directory writes are not yet supported."
    elif os.path.exists(source):
        print >>sys.stderr, "reposurgeon: file %s already exists" % source
    else:
        repo.fast_export(open(source, "w"))

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        if self.repo and self.verbose:
            print "reposurgeon: previously data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
        if self.repo and self.verbose:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            if self.preferred:
                line = "."
            else:
                line = '-'
        write_repo(self.repo, line, self.preferred, self.verbose)
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :84
author Eric S. Raymond <esr@thyrsus.com> 1288101602 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288101602 -0400
data 47
Set the write default type more intelligently.
from :82
M 100755 :83 reposurgeon

blob
mark :85
data 21562
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
    "bzr" : (".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    }

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        if verbose:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % source
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % source
            return None
        elif verbose:
            print "reposurgeon: recognized %s repository under %s" % (foundname, source)
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp)
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed"
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % savedir
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
        if self.repo and self.verbose:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :86
data 7339
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose' option.</para>

<para>Here are the available commands:</para>

<variablelist>
<varlistentry>
<term>help</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term>version</term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term>verbose</term>
<listitem><para>'verbose 1' enables progress and statistics messages,
'verbose 0' disables them. 
</para></listitem>
</varlistentry>
<varlistentry>
<term>shell</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term>prefer</term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>read</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term>write</term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term>rebuild</term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/annotated-sample
mark :87
author Eric S. Raymond <esr@thyrsus.com> 1288112612 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288112612 -0400
data 46
Try to get the write and rebuild logic right.
from :84
M 100644 :86 reposurgeon.xml
M 100755 :85 reposurgeon

blob
mark :88
data 23221
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
    "bzr" : (".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: importing from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: importing from %s" % source))
    else:
        if verbose:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % source
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % source
            return None
        elif verbose:
            print "reposurgeon: recognized %s repository under %s" % (foundname, source)
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: importing from repo"));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed"
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % savedir
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
        else:
            print "reposurgeon: no repository loaded."
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :89
author Eric S. Raymond <esr@thyrsus.com> 1288113962 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288113962 -0400
data 36
Add twirling-batob progress meters.
from :87
M 100755 :88 reposurgeon

blob
mark :90
data 23623
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
    "bzr" : (".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :91
data 7581
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose 1' option.</para>

<para>Here are the available commands:</para>

<variablelist>
<varlistentry>
<term>help</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term>version</term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term>verbose</term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term>shell</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term>prefer</term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>read</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term>stats</term>
<listitem><para>
Report size statistics and import/export method information after reading
a repo or stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term>write</term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term>rebuild</term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/annotated-sample
mark :92
author Eric S. Raymond <esr@thyrsus.com> 1288115880 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288115880 -0400
data 35
Cut verbosity, improve statistics.
from :89
M 100644 :91 reposurgeon.xml
M 100755 :90 reposurgeon

blob
mark :93
data 24447
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :94
data 7922
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose 1' option.</para>

<para>Here are the available commands:</para>

<variablelist>
<varlistentry>
<term>help</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term>version</term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term>verbose</term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term>shell</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term>prefer</term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>read</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term>stats</term>
<listitem><para>
Report size statistics and import/export method information after reading
a repo or stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term>write</term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term>rebuild</term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
<varlistentry>
<term>view</term>
<listitem><para>
View a repo through the default GUI browser for its version control
system.  Note that this does not show the edited state held by
<application>reposurgeon</application> in core; it is mainly useful
for doing a quick eyeball check ofter a rebuild command.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/annotated-sample
mark :95
author Eric S. Raymond <esr@thyrsus.com> 1288117441 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288117441 -0400
data 26
Added the 'view' command.
from :92
M 100644 :94 reposurgeon.xml
M 100755 :93 reposurgeon

blob
mark :96
data 26358
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :97
data 10897
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose 1' option.</para>

<para>Here are the available and planned surgical commands:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>delete</command></cmdsynopsis></term>
<listitem>
<para>Delete a span of commits.  Requires a commit-range argument.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>expunge</command></cmdsynopsis></term>
<listitem>
<para>Expunge a file from the repo history.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>coalesce</command></cmdsynopsis></term>
<listitem>
<para>Scan the history for runs of commits with identical comments close to
each other in time (this is a common form of scar tissues in
repository up-conversions from older file-oriented version-control systems).
Merge these cliques.</para>

<para>The required first argument is a commit range to operate on.  The optional
second argument, if present, is a maximum time separation in seconds;
the default is 90 seconds.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>edit</command></cmdsynopsis></term>
<listitem>
<para>Edit a blob or commit or tag, identified by date or mark or tag
name.</para>
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
</variablelist>

<para>A commit range is either a single commit identifier or a pair
of them separated by "..".  A commit identifier is a mark number
(preceded by ':'). There are some commands that help you find interesting
mark numbers:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>index</command> <arg choice="opt">+b</arg></cmdsynopsis></term>
<listitem>
<para>Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob.</para>

<para>Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
<option>+b</option> option enables display of blobs.</para>
</listitem>
</varlistentry>
</variablelist>

<para>These are backed up by the following housekeeping commands:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>help</command></cmdsynopsis></term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>version</command></cmdsynopsis></term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>verbose</command></cmdsynopsis></term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>shell</command></cmdsynopsis></term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>prefer</command></cmdsynopsis></term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>read</command></cmdsynopsis></term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>stats</command></cmdsynopsis></term>
<listitem><para>
Report size statistics and import/export method information after reading
a repo or stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>write</command></cmdsynopsis></term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>rebuild</command></cmdsynopsis></term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>view</command></cmdsynopsis></term>
<listitem><para>
View a repo through the default GUI browser for its version control
system.  Note that this does not show the edited state held by
<application>reposurgeon</application> in core; it is mainly useful
for doing a quick eyeball check ofter a rebuild command.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/annotated-sample
mark :98
author Eric S. Raymond <esr@thyrsus.com> 1288160374 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288160374 -0400
data 53
Implement and document 'index'; document some plans.
from :95
M 100644 :97 reposurgeon.xml
M 100755 :96 reposurgeon

blob
mark :99
data 32121
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        # First, parse a visibility spec
        Unknown = type("")
        visible = set([Commit, Tag, Branch, Unknown])
        modmode = None
        while line and line[0] in "+-=Bctbx":
            if line[0] == "+":
                modmode = '+'
                line = line[1:]
            elif line[0] == '-':
                modmode = '-'
                line = line[1:]
            elif line[0] == '=':
                modmode = '+'
                visible = set([])
                line = line[1:]
            elif line[0] == 'B':
                if modmode == '+':
                    visible.add(Blob)
                elif modmode == '-' and Blob in visible:
                    visible.remove(Blob)
                line = line[1:]
            elif line[0] == 'c':
                if modmode == '+':
                    visible.add(Commit)
                elif modmode == '-' and Commit in visible:
                    visible.remove(Commit)
                line = line[1:]
            elif line[0] == 't':
                if modmode == '+':
                    visible.add(Tag)
                elif modmode == '-' and Tag in visible:
                    visible.remove(Tag)
                line = line[1:]
            elif line[0] == 'b':
                if modmode == '+':
                    visible.add(Branch)
                elif modmode == '-' and Branch in visible:
                    visible.remove(Branch)
                line = line[1:]
            elif line[0] == 'u':
                if modmode == '+':
                    visible.add(Unknown)
                elif modmode == '-' and Unknown in visible:
                    visible.remove(Unknown)
                line = line[1:]
            elif line[0].isspace():
                # Leave the space in place to signal that parsing is over
                break
            elif line[0] == '&':
                line = line[1:]
                break
            elif modmode:
                print >>sys.stderr,"reposurgeon: illegal char in visibity spec."
                while line and line[0].isspace():
                    line = line[1:]
        # Now compute a span
        span = []
        seenspanner = False
        while line and not line[0].isspace() and not len(span) == 2:
            # First, literal command numbers (1-origin)
            match = re.match("[0-9]+", line)
            if match:
                number = match.group()
                span.append(int(number)-1)
                line = line[len(number):]
                continue
            # Next, mark references
            match = re.match(":[0-9]+", line)
            if match:
                markref = match.group()
                line = line[len(markref):]
                for (i, cmd) in enumerate(self.repo.commands):
                    if type(cmd) == Unknown:
                        continue
                    elif cmd.hasattr("mark") and cmd.mark == markref:
                        span.append(i)
                        break
                else:
                    print >>sys.stderr,"reposurgeon: mark %s not found." % markref
                    while line and line[0].isspace():
                        line = line[1:]
                    return line
                continue
            # $ means last commit, a la ed(1).
            if line.startswith("$"):
                span.append(len(self.repo.commands)-1)
                line = line[1:]
                continue
            # Either "," or ".." is acceptable as span punctuation
            if line.startswith("..") or line.startswith(","): 
                if not span:
                    print >>sys.stderr,"reposurgeon: start of span is missing."
                    while line and line[0].isspace():
                        line = line[1:]
                    return line
                seenspanner = True
                if line.startswith(".."):
                    line = line[2:]
                if line.startswith(","):
                    line = line[1:]
                continue
            # Anything else is an error
            print >>sys.stderr,"reposurgeon: can't parse span specification."
            while line and line[0].isspace():
                line = line[1:]
                return line
            break
        # Done parsing the span.  Barf on trailing garbage
        if line and not line[0].isspace():
            print >>sys.stderr,"reposurgeon: trailing garbage on span specification."
            while line and line[0].isspace():
                line = line[1:]
                return line
        # Sanity checks
        if seenspanner and len(span) < 2:
            print >>sys.stderr,"reposurgeon: incomplete span."
            while line and line[0].isspace():
                line = line[1:]
                return line
        if len(span) == 0:
            span = [0, len(self.repo.objects)-1]
        elif len(span) == 1:
            span.append(span[0])
        (spanstart, spanend) = span 
        if spanstart < 0 or spanend > len(self.repo.objects)-1:
            print >>sys.stderr,"reposurgeon: span start or end out of range."
            return line
        # Now compose the actual selection
        self.selection = []
        for i in range(spanstart, spanend+1):
            cmd = self.repo.commands[i]
            if type(cmd) == Unkown and Unknown in visibility:
                self.selection.append(i)
            elif cmd.__class__ in visibility:
                self.selection.append(i)
        # We're done, return the unconsumed portion of the line
        return line
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :100
author Eric S. Raymond <esr@thyrsus.com> 1288173615 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288173615 -0400
data 37
First try at an expression language.
from :98
M 100755 :99 reposurgeon

blob
mark :101
data 31908
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        if self.verbose >= 2:
            print "reposurgeon: precmd() sees %s" % `line`
        # First, parse a visibility spec
        Unknown = type("")
        visible = set([Commit, Tag, Branch, Unknown])
        modmode = None
        while line and line[0] in "+-=Bctbx&":
            if line[0] == "+":
                modmode = '+'
                line = line[1:]
            elif line[0] == '-':
                modmode = '-'
                line = line[1:]
            elif line[0] == '=':
                modmode = '+'
                visible = set([])
                line = line[1:]
            elif line[0] == 'B':
                if modmode == '+':
                    visible.add(Blob)
                elif modmode == '-' and Blob in visible:
                    visible.remove(Blob)
                line = line[1:]
            elif line[0] == 'c':
                if modmode == '+':
                    visible.add(Commit)
                elif modmode == '-' and Commit in visible:
                    visible.remove(Commit)
                line = line[1:]
            elif line[0] == 't':
                if modmode == '+':
                    visible.add(Tag)
                elif modmode == '-' and Tag in visible:
                    visible.remove(Tag)
                line = line[1:]
            elif line[0] == 'b':
                if modmode == '+':
                    visible.add(Branch)
                elif modmode == '-' and Branch in visible:
                    visible.remove(Branch)
                line = line[1:]
            elif line[0] == 'u':
                if modmode == '+':
                    visible.add(Unknown)
                elif modmode == '-' and Unknown in visible:
                    visible.remove(Unknown)
                line = line[1:]
            elif line[0].isspace() or line[0] == '&':
                line = line[1:]
                break
            elif modmode:
                print >>sys.stderr,"reposurgeon: illegal char in visibility spec."
        if self.verbose >= 2:
            print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `line`)
        # Now compute a selection
        selection = []
        seenspanner = False
        while line and not line[0].isspace() and not line[0].isalpha():
            seenspanner = False 
            # First, literal command numbers (1-origin)
            match = re.match("[0-9]+", line)
            if match:
                number = match.group()
                selection.append(int(number)-1)
                line = line[len(number):]
                continue
            # Next, mark references
            match = re.match(":[0-9]+", line)
            if match:
                markref = match.group()
                line = line[len(markref):]
                for (i, cmd) in enumerate(self.repo.commands):
                    if type(cmd) == Unknown:
                        continue
                    elif hasattr(cmd, "mark") and cmd.mark == markref:
                        selection.append(i)
                        break
                    elif hasattr(cmd, "committish") and cmd.committish == markref:
                        selection.append(i)
                        break
                else:
                    print >>sys.stderr,"reposurgeon: mark %s not found." % markref
                    while line and line[0].isspace():
                        line = line[1:]
                    return line
                continue
            # $ means last commit, a la ed(1).
            if line.startswith("$"):
                selection.append(len(self.repo.commands)-1)
                line = line[1:]
                continue
            # Comma just delimits a location spec
            if line.startswith(","):
                continue
            # Following ".." means a span
            if line.startswith(".."):
                seenspanner = True
                if selection:
                    line = line[2:]
                    continue
                else:
                    print >>sys.stderr,"reposurgeon: start of span is missing."
                    return line
            # Anything else is an error
            print >>sys.stderr,"reposurgeon: can't parse selection at %s." % `line`
            return line
        # Sanity checks
        if seenspanner:
            print >>sys.stderr,"reposurgeon: incomplete selection."
            return line
        if len(selection) == 0:
            selection = [0, len(self.repo.commands)-1]
        for number in selection:
            if number < 0 or number > len(self.repo.commands)-1:
                print >>sys.stderr,"reposurgeon: command number out of range."
                return line
        # Now compose the actual selection
        self.selection = []
        for i in selection:
            cmd = self.repo.commands[i]
            if type(cmd) == Unknown and Unknown in visible:
                self.selection.append(i)
            elif cmd.__class__ in visible:
                self.selection.append(i)
        # We're done, return the unconsumed portion of the line
        return line
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 2
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :102
author Eric S. Raymond <esr@thyrsus.com> 1288179718 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288179718 -0400
data 67
Numbers, mark lookup, and $ are working.  Span punctuation is not.
from :100
M 100755 :101 reposurgeon

blob
mark :103
data 32448
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        # First, parse a visibility spec
        Unknown = type("")
        visible = set([Commit, Tag, Branch, Unknown])
        modmode = None
        while line and line[0] in "+-=Bctbx&":
            if line[0] == "+":
                modmode = '+'
                line = line[1:]
            elif line[0] == '-':
                modmode = '-'
                line = line[1:]
            elif line[0] == '=':
                modmode = '+'
                visible = set([])
                line = line[1:]
            elif line[0] == 'B':
                if modmode == '+':
                    visible.add(Blob)
                elif modmode == '-' and Blob in visible:
                    visible.remove(Blob)
                line = line[1:]
            elif line[0] == 'c':
                if modmode == '+':
                    visible.add(Commit)
                elif modmode == '-' and Commit in visible:
                    visible.remove(Commit)
                line = line[1:]
            elif line[0] == 't':
                if modmode == '+':
                    visible.add(Tag)
                elif modmode == '-' and Tag in visible:
                    visible.remove(Tag)
                line = line[1:]
            elif line[0] == 'b':
                if modmode == '+':
                    visible.add(Branch)
                elif modmode == '-' and Branch in visible:
                    visible.remove(Branch)
                line = line[1:]
            elif line[0] == 'u':
                if modmode == '+':
                    visible.add(Unknown)
                elif modmode == '-' and Unknown in visible:
                    visible.remove(Unknown)
                line = line[1:]
            elif line[0].isspace() or line[0] == '&':
                line = line[1:]
                break
            elif modmode:
                print >>sys.stderr,"reposurgeon: illegal char in visibility spec."
        if self.verbose >= 2:
            print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `line`)
        # Now compute a selection
        selection = []
        while line and not line[0].isspace() and not line[0].isalpha():
            # First, literal command numbers (1-origin)
            match = re.match("[0-9]+", line)
            if match:
                number = match.group()
                selection.append(int(number)-1)
                line = line[len(number):]
                continue
            # Next, mark references
            match = re.match(":[0-9]+", line)
            if match:
                markref = match.group()
                line = line[len(markref):]
                for (i, cmd) in enumerate(self.repo.commands):
                    if type(cmd) == Unknown:
                        continue
                    elif hasattr(cmd, "mark") and cmd.mark == markref:
                        selection.append(i)
                        break
                    elif hasattr(cmd, "committish") and cmd.committish == markref:
                        selection.append(i)
                        break
                else:
                    print >>sys.stderr,"reposurgeon: mark %s not found." % markref
                    while line and line[0].isspace():
                        line = line[1:]
                    return line
                continue
            # $ means last commit, a la ed(1).
            if line.startswith("$"):
                selection.append(len(self.repo.commands)-1)
                line = line[1:]
                continue
            # Comma just delimits a location spec
            if line.startswith(","):
                continue
            # Following ".." means a span
            if line.startswith(".."):
                if selection:
                    selection.append("..")
                    line = line[2:]
                    continue
                else:
                    print >>sys.stderr,"reposurgeon: start of span is missing."
                    return line
            # Anything else is an error
            print >>sys.stderr,"reposurgeon: can't parse selection at %s." % `line`
            return line
        if self.verbose >= 2:
            print "reposurgeon: location list is %s with %s left" % (selection, `line`)
        # Resolve spans
        resolved = []
        spanning = last = 0
        for elt in selection:
            if elt == '..':
                spanning = True
            else:
                if spanning:
                    resolved += range(last+1, elt+1)
                    spanning = False
                else:
                    resolved.append(elt)
                last = elt
        selection = resolved
        if self.verbose >= 2:
            print "reposurgeon: resolved list is %s with %s left" % (selection, `line`)
        # Sanity checks
        if len(selection) == 0:
            selection = [0, len(self.repo.commands)-1]
        elif selection and selection[-1] == '..':
            print >>sys.stderr,"reposurgeon: incomplete selection."
            return line
        for elt in selection:
            if elt < 0 or elt > len(self.repo.commands)-1:
                print >>sys.stderr,"reposurgeon: command number %s out of range." % elt
                return line
        # Now compose the actual selection
        self.selection = []
        for i in selection:
            cmd = self.repo.commands[i]
            if type(cmd) == Unknown and Unknown in visible:
                self.selection.append(i)
            elif cmd.__class__ in visible:
                self.selection.append(i)
        # We're done, return the unconsumed portion of the line
        return line
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :104
author Eric S. Raymond <esr@thyrsus.com> 1288181252 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288181252 -0400
data 28
Span resolution is working.
from :102
M 100755 :103 reposurgeon

blob
mark :105
data 35910
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = [0, len(self.repo.commands)-1]
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if not self.peek() == '|':
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if not self.peek() == '&':
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in "+-=":
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Branch, Unknown])
            modmode = None
            while self.peek() in "+-=Bctbu":
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'c':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 't':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'b':
                    if modmode == '+':
                        visible.add(Branch)
                    elif modmode == '-' and Branch in visible:
                        visible.remove(Branch)
                elif c == 'u':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ":0123456789$":
            polyrange = None
        else:
            selection = []
            while self.peek() in ":0123456789.,$":
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 2
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :106
author Eric S. Raymond <esr@thyrsus.com> 1288193458 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288193458 -0400
data 40
New recursive evaluator almost working.
from :104
M 100755 :105 reposurgeon

blob
mark :107
data 35992
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = [0, len(self.repo.commands)-1]
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in "+-=":
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Branch, Unknown])
            modmode = None
            while self.peek() in "+-=Bctbu":
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'c':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 't':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'b':
                    if modmode == '+':
                        visible.add(Branch)
                    elif modmode == '-' and Branch in visible:
                        visible.remove(Branch)
                elif c == 'u':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ":0123456789$":
            polyrange = None
        else:
            selection = []
            while self.peek() in ":0123456789.,$":
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 2
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :108
author Eric S. Raymond <esr@thyrsus.com> 1288194165 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288194165 -0400
data 49
OK, thismakes the binary logical operators work.
from :106
M 100755 :107 reposurgeon

blob
mark :109
data 36130
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = [0, len(self.repo.commands)-1]
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Branch, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'c':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 't':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'b':
                    if modmode == '+':
                        visible.add(Branch)
                    elif modmode == '-' and Branch in visible:
                        visible.remove(Branch)
                elif c == 'u':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 2
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :110
author Eric S. Raymond <esr@thyrsus.com> 1288194826 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288194826 -0400
data 29
No hang on commandless line.
from :108
M 100755 :109 reposurgeon

blob
mark :111
data 36088
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = [0, len(self.repo.commands)-1]
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 2
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :112
data 15009
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> invocation line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose 1' option.</para>

<para>A git-fast-import stream consists of a sequence of commands
which must be executed in the specified sequence to build the repo;
to avoiid confusion with <application>reposurgeon</application> commands
we will refer to the stream commands here as <emphasis>events</emphasis>.
These events are implicitly numbered from 1 upwards.  Most commands
require specifying a selection of event sequence numbers so
<application>reposurgeon</application> will know which events to
modify or delete.</para>

<para>When a command takes a selection-set argument, it will
<emphasis>precede</emphasis> the command keyword; other arguments will
follow. It is often possible to omit the selection-set argument and
have it default to something reasonable, usuaally the entire event 
sequence.</para>

<para>Here are some motivating examples.  The commands will be
explained in more detail after the description of selection
syntax.</para>

<programlisting>
:15 edit                     ;; edit the object associated with mark :15

29..71 index                 ;; list summary index of events 20..71

=t &amp; 1..:97 delete            ;; delete tags from event 1 to mark 15
</programlisting>

<para>The selection-set specification syntax is an expression-oriented 
minilanguage.  The most basic term in this language is a 
<firstterm>location</firstterm>. The following sorts of primitive locations
are supported:</para>

<variablelist>
<varlistentry>
<term><firstterm>event numbers</firstterm></term>
<listitem><para>A plain numeric literal is interpreted as a 1-origin
event-sequence number.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>marks</firstterm></term>
<listitem><para>A numeric literal preceded by a colon is interpreted
as a mark; see the format documentation for explanation of the 
semantics of marks.</para></listitem>
</varlistentry>
</variablelist>

<para>These may be grouped into sets in the following ways:</para>

<variablelist>
<varlistentry>
<term><firstterm>ranges</firstterm></term>
<listitem><para>A range is two locations separated by "..", and is
the set of events begining at the left-hand location and ending at the
right-hand location (inclusive).</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>lists</firstterm></term>
<listitem><para>Comma-separated lists of locations and ranges are 
accepted, with the obvious meaning.</para></listitem>
</varlistentry>
</variablelist>

<para>There are some other ways to construct event sets:</para>

<variablelist>
<varlistentry>
<term><firstterm>visibility sets</firstterm></term>
<listitem>
<para>A visibility set is an expression specifying a set of event
types. It will consist of a leading plus, minus, or equal sign,
followed by type letters. These are the type letters:</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='7' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <colspec colname='c3'/>
    <tbody>
      <row>
        <entry align='center'>B</entry>
        <entry align='center'>blobs</entry>
	<entry><para>Most default selection sets exclude blobs; they
	have to be manipulated through the commits they are attached
	to.</para></entry>
      </row>
      <row>
        <entry align='center'>C</entry>
        <entry align='center'>commits</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>T</entry>
        <entry align='center'>tags</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>R</entry>
        <entry align='center'>resets</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>U</entry>
        <entry align='center'>Unknown</entry>
	<entry><para>All event types types simply passed through,
	including comments, <command>progress</command> commands, 
        and <command>checkpoint</command> commands.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>The = prefix specifies exactly the set of types following; the +
prefix adds to the default set for the command; and the - prefix
subtracts from that set.</para>

</listitem>
</varlistentry>
</variablelist>

<para>Set expressions bay be combined with the operators | and &amp;;
these are, respectively, set uniomn and intersection.</para>

<para>Here are the available and planned surgical commands:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>index</command> <arg choice="opt">+b</arg></cmdsynopsis></term>
<listitem>
<para>Display four columns of info on objects in the selection set:
their number, their type, the associate mark (or '-' if no mark) and a
summary field varying by type.  For a branch or tag it's the
reference; for a commit it's the commit branch; for a blob it's the
repository path of the file in the blob.</para>

<para>The default selection set for this command is =ctbu, all objects
except blobs.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>delete</command></cmdsynopsis></term>
<listitem>
<para>Delete a selection set of commits.  The default selection set
for this command is empty.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>expunge</command></cmdsynopsis></term>
<listitem>
<para>Expunge a file from the repo history. Does not take a selection
set.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>coalesce</command></cmdsynopsis></term>
<listitem>
<para>Scan the selection set for runs of commits with identical
comments close to each other in time (this is a common form of scar
tissues in repository up-conversions from older file-oriented
version-control systems).  Merge these cliques.</para>

<para>The required first argument is a selection set to operate on.
The optional second argument, if present, is a maximum time separation
in seconds; the default is 90 seconds.</para>

<para>The default selection set for this command is =c, all commits.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>edit</command></cmdsynopsis></term>
<listitem>
<para>Edit a selection set of commands.</para>
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
</variablelist>

<para>These are backed up by the following housekeeping commands, none of 
which take a selection set:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>help</command></cmdsynopsis></term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>version</command></cmdsynopsis></term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>verbose</command></cmdsynopsis></term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>shell</command></cmdsynopsis></term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>prefer</command></cmdsynopsis></term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>read</command></cmdsynopsis></term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>stats</command></cmdsynopsis></term>
<listitem><para>
Report size statistics and import/export method information after reading
a repo or stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>write</command></cmdsynopsis></term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>rebuild</command></cmdsynopsis></term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>view</command></cmdsynopsis></term>
<listitem><para>
View a repo through the default GUI browser for its version control
system.  Note that this does not show the edited state held by
<application>reposurgeon</application> in core; it is mainly useful
for doing a quick eyeball check ofter a rebuild command.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/annotated-sample
mark :113
author Eric S. Raymond <esr@thyrsus.com> 1288199857 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288199857 -0400
data 41
Document the new selection-set language.
from :110
M 100644 :112 reposurgeon.xml
M 100755 :111 reposurgeon

blob
mark :114
data 15054
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> invocation line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose 1' option.</para>

<para>A git-fast-import stream consists of a sequence of commands
which must be executed in the specified sequence to build the repo;
to avoiid confusion with <application>reposurgeon</application> commands
we will refer to the stream commands here as <emphasis>events</emphasis>.
These events are implicitly numbered from 1 upwards.  Most commands
require specifying a selection of event sequence numbers so
<application>reposurgeon</application> will know which events to
modify or delete.</para>

<para>When a command takes a selection-set argument, it will
<emphasis>precede</emphasis> the command keyword; other arguments will
follow. It is often possible to omit the selection-set argument and
have it default to something reasonable, usuaally the entire event 
sequence.</para>

<para>Here are some motivating examples.  The commands will be
explained in more detail after the description of selection
syntax.</para>

<programlisting>
:15 edit                     ;; edit the object associated with mark :15

29..71 index                 ;; list summary index of events 20..71

=t &amp; 1..:97 delete            ;; delete tags from event 1 to mark 15
</programlisting>

<para>The selection-set specification syntax is an expression-oriented 
minilanguage.  The most basic term in this language is a 
<firstterm>location</firstterm>. The following sorts of primitive locations
are supported:</para>

<variablelist>
<varlistentry>
<term><firstterm>event numbers</firstterm></term>
<listitem><para>A plain numeric literal is interpreted as a 1-origin
event-sequence number.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>marks</firstterm></term>
<listitem><para>A numeric literal preceded by a colon is interpreted
as a mark; see the format documentation for explanation of the 
semantics of marks.</para></listitem>
</varlistentry>
</variablelist>

<para>These may be grouped into sets in the following ways:</para>

<variablelist>
<varlistentry>
<term><firstterm>ranges</firstterm></term>
<listitem><para>A range is two locations separated by "..", and is
the set of events begining at the left-hand location and ending at the
right-hand location (inclusive).</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>lists</firstterm></term>
<listitem><para>Comma-separated lists of locations and ranges are 
accepted, with the obvious meaning.</para></listitem>
</varlistentry>
</variablelist>

<para>There are some other ways to construct event sets:</para>

<variablelist>
<varlistentry>
<term><firstterm>visibility sets</firstterm></term>
<listitem>
<para>A visibility set is an expression specifying a set of event
types. It will consist of a leading plus, minus, or equal sign,
followed by type letters. These are the type letters:</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='3' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <colspec colname='c3'/>
    <tbody>
      <row>
        <entry align='center'>B</entry>
        <entry align='center'>blobs</entry>
	<entry><para>Most default selection sets exclude blobs; they
	have to be manipulated through the commits they are attached
	to.</para></entry>
      </row>
      <row>
        <entry align='center'>C</entry>
        <entry align='center'>commits</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>T</entry>
        <entry align='center'>tags</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>R</entry>
        <entry align='center'>resets</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>U</entry>
        <entry align='center'>Unknown</entry>
	<entry><para>All event types types simply passed through,
	including comments, <command>progress</command> commands, 
        and <command>checkpoint</command> commands.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>The = prefix specifies exactly the set of types following; the +
prefix adds to the default set for the command; and the - prefix
subtracts from that set.</para>

</listitem>
</varlistentry>
</variablelist>

<para>Set expressions bay be combined with the operators | and &amp;;
these are, respectively, set uniomn and intersection.</para>

<para>Here are the available and planned surgical commands:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>index</command></cmdsynopsis></term>
<listitem>
<para>Display four columns of info on objects in the selection set:
their number, their type, the associate mark (or '-' if no mark) and a
summary field varying by type.  For a branch or tag it's the
reference; for a commit it's the commit branch; for a blob it's the
repository path of the file in the blob.</para>

<para>The default selection set for this command is =CTRU, all objects
except blobs.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>delete</command></cmdsynopsis></term>
<listitem>
<para>Delete a selection set of commits.  The default selection set
for this command is empty.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>expunge</command></cmdsynopsis></term>
<listitem>
<para>Expunge a file from the repo history. Does not take a selection
set.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>coalesce</command></cmdsynopsis></term>
<listitem>
<para>Scan the selection set for runs of commits with identical
comments close to each other in time (this is a common form of scar
tissues in repository up-conversions from older file-oriented
version-control systems).  Merge these cliques.</para>

<para>The optional second argument, if present, is a maximum time
separation in seconds; the default is 90 seconds.</para>

<para>The default selection set for this command is =C, all
commits. Occasionally you may want to restrict it, for example to
avoid coalescing unrelated "*** empty log message ***" commits from
CVS lifts.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>edit</command></cmdsynopsis></term>
<listitem>
<para>Edit a selection set of events.</para>
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
</variablelist>

<para>These are backed up by the following housekeeping commands, none of 
which take a selection set:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>help</command></cmdsynopsis></term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>version</command></cmdsynopsis></term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>verbose</command></cmdsynopsis></term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>shell</command></cmdsynopsis></term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>prefer</command></cmdsynopsis></term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>read</command></cmdsynopsis></term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>stats</command></cmdsynopsis></term>
<listitem><para>
Report size statistics and import/export method information after reading
a repo or stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>write</command></cmdsynopsis></term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>rebuild</command></cmdsynopsis></term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>view</command></cmdsynopsis></term>
<listitem><para>
View a repo through the default GUI browser for its version control
system.  Note that this does not show the edited state held by
<application>reposurgeon</application> in core; it is mainly useful
for doing a quick eyeball check ofter a rebuild command.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/heads/master
mark :115
author Eric S. Raymond <esr@thyrsus.com> 1288200336 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288200336 -0400
data 21
Documentation fixes.
from :113
M 100644 :114 reposurgeon.xml

blob
mark :116
data 35714
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s") % os.path.relpath(source)
            return None
        elif hitcount > 1:
            complain("too many repos under %s") % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = None
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        elif self.selection is None:
            self.selection = range(len(self.repo.commands))
        for (i, command) in enumerate(self.selection):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :117
author Eric S. Raymond <esr@thyrsus.com> 1288202060 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288202060 -0400
data 51
Minor refactoring step, and lower the debug level.
from :115
M 100755 :116 reposurgeon

blob
mark :118
data 35715
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s") % os.path.relpath(source)
            return None
        elif hitcount > 1:
            complain("too many repos under %s") % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = None
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdout)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        elif self.selection is None:
            self.selection = range(len(self.repo.commands))
        for (i, command) in enumerate(self.selection):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :119
author Eric S. Raymond <esr@thyrsus.com> 1288202462 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288202462 -0400
data 67
Fix brown-paper-bag bug that broke the round-trip regression test.
from :117
M 100755 :118 reposurgeon

blob
mark :120
data 35992
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s") % os.path.relpath(source)
            return None
        elif hitcount > 1:
            complain("too many repos under %s") % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            # A FIFO version wouldn't block our reads until
            # the entire file is written - faster, and makes our baton
            # spinner useful -- if it worked.
            #tfname = os.path.join("/tmp/reposurgeon"+`os.getpid()`)
            #os.mkfifo(tfname)
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = None
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdout)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        elif self.selection is None:
            self.selection = range(len(self.repo.commands))
        for (i, command) in enumerate(self.selection):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :121
author Eric S. Raymond <esr@thyrsus.com> 1288203721 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288203721 -0400
data 27
Document a failed attempt.
from :119
M 100755 :120 reposurgeon

blob
mark :122
data 36097
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s") % os.path.relpath(source)
            return None
        elif hitcount > 1:
            complain("too many repos under %s") % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            # A FIFO version wouldn't block our reads until
            # the entire file is written - faster, and makes our baton
            # spinner useful -- if it worked.
            #tfname = os.path.join("/tmp/reposurgeon"+`os.getpid()`)
            #os.mkfifo(tfname)
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = None
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdout)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        elif self.selection is None:
            self.selection = range(len(self.repo.commands))
        for (i, command) in enumerate(self.selection):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        interpreter.use_rawinput = False
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.use_rawinput = True
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                    interpreter.use_rawinput = False
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :123
author Eric S. Raymond <esr@thyrsus.com> 1288204205 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288204205 -0400
data 37
Cut down on expensive input editing.
from :121
M 100755 :122 reposurgeon

blob
mark :124
data 36129
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s") % os.path.relpath(source)
            return None
        elif hitcount > 1:
            complain("too many repos under %s") % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            # A FIFO version wouldn't block our reads until
            # the entire file is written - faster, and makes our baton
            # spinner useful -- if it worked.
            #tfname = os.path.join("/tmp/reposurgeon"+`os.getpid()`)
            #os.mkfifo(tfname)
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def set_selection_set(self, line, default=None):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = default
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdout)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        self.set_selection_set(line, range(len(self.repo.commands)))
        for (i, command) in enumerate(self.selection):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        set_selection_set(line)
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        interpreter.use_rawinput = False
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.use_rawinput = True
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                    interpreter.use_rawinput = False
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :125
data 15353
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> invocation line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose 1' option.</para>

<para>A git-fast-import stream consists of a sequence of commands
which must be executed in the specified sequence to build the repo;
to avoiid confusion with <application>reposurgeon</application> commands
we will refer to the stream commands here as <emphasis>events</emphasis>.
These events are implicitly numbered from 1 upwards.  Most commands
require specifying a selection of event sequence numbers so
<application>reposurgeon</application> will know which events to
modify or delete.</para>

<para>When a command takes a selection-set argument, it will
immediately follow the command keyword; other arguments will
follow. It is often possible to omit the selection-set argument and
have it default to something reasonable.</para>

<para>Here are some motivating examples.  The commands will be
explained in more detail after the description of selection
syntax.</para>

<programlisting>
edit :15                     ;; edit the object associated with mark :15

index 29..71                 ;; list summary index of events 20..71

delete =t &amp; 1..:97           ;; delete tags from event 1 to mark 15
</programlisting>

<para>The selection-set specification syntax is an expression-oriented 
minilanguage.  The most basic term in this language is a 
<firstterm>location</firstterm>. The following sorts of primitive locations
are supported:</para>

<variablelist>
<varlistentry>
<term><firstterm>event numbers</firstterm></term>
<listitem><para>A plain numeric literal is interpreted as a 1-origin
event-sequence number.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>marks</firstterm></term>
<listitem><para>A numeric literal preceded by a colon is interpreted
as a mark; see the format documentation for explanation of the 
semantics of marks.</para></listitem>
</varlistentry>
</variablelist>

<para>These may be grouped into sets in the following ways:</para>

<variablelist>
<varlistentry>
<term><firstterm>ranges</firstterm></term>
<listitem><para>A range is two locations separated by "..", and is
the set of events begining at the left-hand location and ending at the
right-hand location (inclusive).</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>lists</firstterm></term>
<listitem><para>Comma-separated lists of locations and ranges are 
accepted, with the obvious meaning.</para></listitem>
</varlistentry>
</variablelist>

<para>There are some other ways to construct event sets:</para>

<variablelist>
<varlistentry>
<term><firstterm>visibility sets</firstterm></term>
<listitem>
<para>A visibility set is an expression specifying a set of event
types. It will consist of a leading plus, minus, or equal sign,
followed by type letters. These are the type letters:</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='3' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <colspec colname='c3'/>
    <tbody>
      <row>
        <entry align='center'>B</entry>
        <entry align='center'>blobs</entry>
	<entry><para>Most default selection sets exclude blobs; they
	have to be manipulated through the commits they are attached
	to.</para></entry>
      </row>
      <row>
        <entry align='center'>C</entry>
        <entry align='center'>commits</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>T</entry>
        <entry align='center'>tags</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>R</entry>
        <entry align='center'>resets</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>U</entry>
        <entry align='center'>Unknown</entry>
	<entry><para>All event types types simply passed through,
	including comments, <command>progress</command> commands, 
        and <command>checkpoint</command> commands.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>The = prefix specifies exactly the set of types following; the +
prefix adds to the default set for the command; and the - prefix
subtracts from that set.</para>

</listitem>
</varlistentry>
</variablelist>

<para>Set expressions bay be combined with the operators | and &amp;;
these are, respectively, set uniomn and intersection.</para>

<para>Here are the available and planned surgical commands:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>index</command></cmdsynopsis></term>
<listitem>
<para>Display four columns of info on objects in the selection set:
their number, their type, the associate mark (or '-' if no mark) and a
summary field varying by type.  For a branch or tag it's the
reference; for a commit it's the commit branch; for a blob it's the
repository path of the file in the blob.</para>

<para>The default selection set for this command is =CTRU, all objects
except blobs.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>delete</command></cmdsynopsis></term>
<listitem>
<para>Delete a selection set of commits.  The default selection set
for this command is empty.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>expunge</command></cmdsynopsis></term>
<listitem>
<para>Expunge a file from the repo history. Does not take a selection
set.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>coalesce</command></cmdsynopsis></term>
<listitem>
<para>Scan the selection set for runs of commits with identical
comments close to each other in time (this is a common form of scar
tissues in repository up-conversions from older file-oriented
version-control systems).  Merge these cliques.</para>

<para>The optional second argument, if present, is a maximum time
separation in seconds; the default is 90 seconds.</para>

<para>The default selection set for this command is =C, all
commits. Occasionally you may want to restrict it, for example to
avoid coalescing unrelated "*** empty log message ***" commits from
CVS lifts.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>edit</command></cmdsynopsis></term>
<listitem>
<para>Edit a selection set of events.</para>
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
</variablelist>

<para>These are backed up by the following housekeeping commands, none of 
which take a selection set:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>help</command></cmdsynopsis></term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>resolve</command></cmdsynopsis></term>
<listitem><para>Does nothing but resolve a selection-set expression
and echo the resulting event-number set to standard
output. Implemented mainly for recression testing, but may be useful
for exploring the selection-set language.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>version</command></cmdsynopsis></term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>verbose</command></cmdsynopsis></term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>shell</command></cmdsynopsis></term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>prefer</command></cmdsynopsis></term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>read</command></cmdsynopsis></term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>stats</command></cmdsynopsis></term>
<listitem><para>
Report size statistics and import/export method information after reading
a repo or stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>write</command></cmdsynopsis></term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>rebuild</command></cmdsynopsis></term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>view</command></cmdsynopsis></term>
<listitem><para>
View a repo through the default GUI browser for its version control
system.  Note that this does not show the edited state held by
<application>reposurgeon</application> in core; it is mainly useful
for doing a quick eyeball check ofter a rebuild command.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/heads/master
mark :126
author Eric S. Raymond <esr@thyrsus.com> 1288205012 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288205012 -0400
data 183
Switch selection sets from prefix to postfix.

The prefix position what triggering some obscure bug in the Python cmd
class; the symptom was that "$ verbose" wouldn't parse properly.
from :123
M 100644 :125 reposurgeon.xml
M 100755 :124 reposurgeon

blob
mark :127
data 36212
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s") % os.path.relpath(source)
            return None
        elif hitcount > 1:
            complain("too many repos under %s") % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            # A FIFO version wouldn't block our reads until
            # the entire file is written - faster, and makes our baton
            # spinner useful -- if it worked.
            #tfname = os.path.join("/tmp/reposurgeon"+`os.getpid()`)
            #os.mkfifo(tfname)
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def set_selection_set(self, line, default=None):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = default
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdout)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        default = map(lambda x: x[0], filter(lambda (n, o): not isinstance(o, Blob), enumerate(self.repo.commands)))
        self.set_selection_set(line, default)
        for i in self.selection:
            command = self.repo.commands[i]
            if isinstance(command, Blob):
                print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        set_selection_set(line)
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        interpreter.use_rawinput = False
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.use_rawinput = True
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                    interpreter.use_rawinput = False
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :128
author Eric S. Raymond <esr@thyrsus.com> 1288206185 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288206185 -0400
data 55
Compute the correct default set for the index command.
from :126
M 100755 :127 reposurgeon

reset refs/remotes/origin/master
from :128

tag annotated-sample
from :113
tagger Eric S. Raymond <esr@thyrsus.com> 1288206780 -0400
data 66
We want an anntated tag in the repo for regression-test purposes.

done
