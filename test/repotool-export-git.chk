feature done
blob
mark :1
original-oid a579432e2ef32a1946830dc77352740e11d8d395
data 53
#!/ysr/bin/env python
#
# rs - a repository surgeon.

reset refs/tags/lightweight-sample
commit refs/tags/lightweight-sample
mark :2
original-oid 2f4b8023a10339353f39abad3a4db8ee9bab892a
author Eric S. Raymond <esr@thyrsus.com> 1287754582 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287754582 -0400
data 22
The adventure begins.
M 100644 :1 rs

blob
mark :3
original-oid f44ddf8fc8580a1aa321cb6f41bcc410f6f7bb2f
data 621
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, cid, comment, branch, parents):
        self.timestamp = timestamp
        self.id = cid
        self.comment = comment
        self.branch = branch
        self.parents = parents

class GitSlicer:
    "Repo-slicing methods for the Git version-control system"
    def __init__(repo):
        pass

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

commit refs/tags/lightweight-sample
mark :4
original-oid 4305dc3181875df45615be97f428d1aa861363e7
author Eric S. Raymond <esr@thyrsus.com> 1287755564 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287755564 -0400
data 28
Beginnings of core classes.
from :2
M 100755 :3 rs

blob
mark :5
original-oid 20bc255a3563c14a2fccf807f7dff17018404c79
data 1329
= Reposurgeon Designer's Notes =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that version-control
systems don't want to let you do, such as (a) editing past comments and 
metadata, (b) excising commits, and (c) coalescing commits. The motivation
for reposurgeon was to help with artifacts and sca r tisue created by 
repository conversions.

The reposurgeon tool depends on being able to map all the version-control
systems it knows about into a common data model.  Here are the components 
of the model:

1. A sequence of commit objects.  The primary key for these objects is
the date of the commit. Each commit represents an ebtire state of
some file tree.

2. A map of the is-a-parent-of relationship. A commit may have multiplre 
parents; the map implies a DAG (directed acyclic graph) of commits.

3. A list of branch heads.  This is a mapping from names to tip 
revisions in the DAG.

4. A list of tags (name-to-commit mappings).

This model is intended to capture the common semantics of distributed
version-control systems: the three specific tarhets are git, hg, and
Subversion (more may be added in future).

It is a design constraint that all reposurgeon operations either prserve
all VCS-specific metadata thety are not told to modify or warn you when
they cannot.





commit refs/tags/lightweight-sample
mark :6
original-oid 1a9cc00aaf986d70cf7658d7655fe07d3772f5ee
author Eric S. Raymond <esr@thyrsus.com> 1287759014 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287759014 -0400
data 27
Beginning of design notes.
from :4
M 100644 :5 theory.txt

blob
mark :7
original-oid 5021e4c1f50dacdbd14efb414801f5288d73573b
data 1022
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, comment, parents):
        self.timestamp = timestamp   # Primary key
        self.comment = comment       # Commit comment
        self.parents = parents       # List of parent nodes
        self.branch = branch         # branch name (deduced optimization hack)

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings

class GitSlicer:
    "Repo-slicing methods for the Git version-control system"
    def __init__(repo):
        pass

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

blob
mark :8
original-oid 665f22587972aa9fdd53c5eb96ba882b0ff7c22c
data 1329
= Reposurgeon Designer's Notes =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that version-control
systems don't want to let you do, such as (a) editing past comments and 
metadata, (b) excising commits, and (c) coalescing commits. The motivation
for reposurgeon was to help with artifacts and scar tisue created by 
repository conversions.

The reposurgeon tool depends on being able to map all the version-control
systems it knows about into a common data model.  Here are the components 
of the model:

1. A sequence of commit objects.  The primary key for these objects is
the date of the commit. Each commit represents an ebtire state of
some file tree.

2. A map of the is-a-parent-of relationship. A commit may have multiplre 
parents; the map implies a DAG (directed acyclic graph) of commits.

3. A list of branch heads.  This is a mapping from names to tip 
revisions in the DAG.

4. A list of tags (name-to-commit mappings).

This model is intended to capture the common semantics of distributed
version-control systems: the three specific tarhets are git, hg, and
Subversion (more may be added in future).

It is a design constraint that all reposurgeon operations either preserve
all VCS-specific metadata thety are not told to modify or warn you when
they cannot.





commit refs/tags/lightweight-sample
mark :9
original-oid 9ed4e187431f7f059050b0ff30375a78bd4fe558
author Eric S. Raymond <esr@thyrsus.com> 1287768418 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287768418 -0400
data 40
Sync data structures with design notes.
from :6
M 100755 :7 rs
M 100644 :8 theory.txt

blob
mark :10
original-oid bd0060fd878be4744cd0ba04ca2aa0d03fb309cf
data 2339
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, author, committer, comment, parents):
        self.timestamp = timestamp   # Primary key
        self.author = author         # Aujtor of commit
        self.committer = committer   # Person responsible for committing it.
        self.comment = comment       # Commit comment
        self.parents = parents       # List of parent nodes
        self.branch = branch         # branch name (deduced optimization hack)

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.__marks = []
    def fast_import(fp):
        "Initialize repo object from fast import."
        os.mkdir(".rs")     # May throw os.error
        os.mkdir(".rs/history")
        mark = None
        for line in fp:
            if line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line)
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                continue     # FIXME
            elif line.startswith("commit"):
                continue     # FIXME
            elif line.startswith("reset"):
                continue     # FIXME
            elif line.startswith("tag"):
                continue     # FIXME
            else:
                raise RepoSurgeonException("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

commit refs/tags/lightweight-sample
mark :11
original-oid bab06351a2344174b480cadd41f1113b3dd933aa
author Eric S. Raymond <esr@thyrsus.com> 1287919107 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287919107 -0400
data 31
Skeleton of fast-import logic.
from :9
M 100755 :10 rs

blob
mark :12
original-oid 8b6f5ea5d1c4706c2269137b695e2491d4397284
data 4234
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, author, committer, comment, parents):
        self.timestamp = timestamp   # Primary key
        self.author = author         # Aujtor of commit
        self.committer = committer   # Person responsible for committing it.
        self.comment = comment       # Commit comment
        self.parents = parents       # List of parent nodes
        self.branch = branch         # branch name (deduced optimization hack)

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.nmarks = 0
    def fast_import(fp):
        "Initialize repo object from fast-import stream."
        os.mkdir(".rs")     # May throw OSError
        os.mkdir(".rs/history")
        tags_to_marks = {}
        import_line = 0
        def error(msg):
            raise RepoSurgeonException(msg + (" at line " + `import_line`)
        def read_data(dp):
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            else:
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueError:
                    raise error("bad count in data")
            else:
                    raise error("malformed data header")
            return
        for line in fp:
            import_line += 1
            if line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                nextline = fp.readline()
                import_line += 1
                if readline.startwith("mark"):
                    mark = nextline[5:].strip()
                    read_data(open(".rs/blob" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    error("missing mark after blob")
            elif line.startswith("data"):
                error("unexpected data object")
            elif line.startswith("commit"):
                continue     # FIXME
            elif line.startswith("reset"):
                tagname = line[4:].strip()
                nextline = fp.readline()
                import_line += 1
                if nextline.startswith("from"):
                    tags_to_marks[tagname] = nextline[5:].strip()
                else:
                    error("missing from after reset")
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                nextline = fp.readline()
                import_line += 1
                if nextline.startswith("from"):
                    tags_to_marks[tagname] = nextline[5:].strip()
                else:
                    error("missing from after tag")
                self.read_data(open(".rs/tag" + tagname, "w")).close()
            else:
                raise error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

commit refs/tags/lightweight-sample
mark :13
original-oid 29f5f77c358733853b9ed062c4ddc7daa545e1d1
author Eric S. Raymond <esr@thyrsus.com> 1287925789 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287925789 -0400
data 47
Fast-import reading except for commit objects.
from :11
M 100755 :12 rs

blob
mark :14
original-oid 4f3396fb8b72eb278ffe5070a6d11b15a6532c50
data 8457
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance pof a person acting on the repo."
    def __init__(self, name, email, when):
        self,name = name
        self.email = email
        self.when = when
    def __repr__(self):
        return self.name + " " + self.email + " " + self.when

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = None          # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, fp):
        "Initialize repo object from fast-import stream."
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header")
            return
        def readline():
            if linebuffers:
                return linebuffers.pop()
            else:
                self.import_line += 1
                return fp.readline()
        def pushback(line):
            self.linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                nextline = readline()
                if line.startswith("mark"):
                    mark = nextline[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = currentbranch
                ncommits += 1
                inlinecount = 0
                while True:
                    nextline = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = nextline[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            (name, email, when) = line.split()
                            commit.author = Action(name, email, when)
                        except ValueSelf.Error:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            (name, email, when) = line.split()
                            commit.committer = Action(name, email, when)
                        except ValueSelf.Error:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = self.read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.ancestors.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.filemap.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.filemap.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            fileop.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            fileop.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                nextline = readline()
                if nextline.startswith("from"):
                    refs_to_marks[currentbranch] = nextline[5:].strip()
                else:
                    self.error("missing from after reset")
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                nextline = readline()
                if nextline.startswith("from"):
                    refs_to_marks[tagname] = nextline[5:].strip()
                else:
                    self.error("missing from after tag")
                self.read_data(open(".rs/tag-" + tagname, "w")).close()
            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv.pop(0)
    (options, arguments) = getopt.getopt(sys.argv[2:], "")
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        repo = GenericRepo()
        try:
            if not arguments:
                repo.fast_import(sys.stdin)
            else:
                fatal("rs: unsupported load mode")
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/tags/lightweight-sample
mark :15
original-oid beefc0b2d82d34c89e1093e63efb25f5c0b7f6a3
author Eric S. Raymond <esr@thyrsus.com> 1287956274 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287956274 -0400
data 30
First commands are executing.
from :13
M 100755 :14 rs

blob
mark :16
original-oid fe70b0fd1ac9cb6d39ec33a7f0e44e6f08a5f620
data 8874
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance pof a person acting on the repo."
    def __init__(self, name, email, when):
        self.name = name
        self.email = email
        self.when = when
    def __repr__(self):
        return self.name + " " + self.email + " " + self.when

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, argv):
        "Initialize repo object from fast-import stream."
        verbose = False
        (options, arguments) = getopt.getopt(argv[1:], "v")
        for (opt, arg) in options:
            if opt == '-v':
                verbose = True
        if not arguments:
            fp = sys.stdin
        else:
            error("load subcommand does not take arguments", atline=False)
        print "Foo!", argv, options, verbose
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            if verbose:
                print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            line = line.replace(" <", "|").replace("> ", "|")
                            (name, email, when) = line[7:].strip().split("|")
                            commit.author = Action(name, email, when)
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            line = line.replace(" <", "|").replace("> ", "|")
                            (name, email, when) = line[10:].strip().split("|")
                            commit.committer = Action(name, email, when)
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.filemap.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.filemap.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[tagname] = line[5:].strip()
                else:
                    self.error("missing from after tag")
                read_data(open(".rs/tag-" + tagname, "w")).close()
            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv[0]
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        try:
            repo = GenericRepo()
            repo.fast_import(sys.argv)
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/tags/lightweight-sample
mark :17
original-oid 3bbbcbd4cbf810888d18b6feec0527885b0c4c2b
author Eric S. Raymond <esr@thyrsus.com> 1287991809 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287991809 -0400
data 36
Options processing for subcommands.
from :15
M 100755 :16 rs

blob
mark :18
original-oid 651f10695a9ab2a38e3acbc64a1224e1d4fdb79f
data 9978
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance pof a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, argv):
        "Initialize repo object from fast-import stream."
        verbose = False
        (options, arguments) = getopt.getopt(argv[1:], "v")
        for (opt, arg) in options:
            if opt == '-v':
                verbose = True
        if not arguments:
            fp = sys.stdin
        else:
            error("load subcommand does not take arguments", atline=False)
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv[0]
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        try:
            repo = GenericRepo()
            repo.fast_import(sys.argv)
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/tags/lightweight-sample
mark :19
original-oid b05bbefe48c25969e5d33ddab9c00b6a92aef16c
author Eric S. Raymond <esr@thyrsus.com> 1287995066 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287995066 -0400
data 31
First parse of an entire dump.
from :17
M 100755 :18 rs

blob
mark :20
original-oid 8b6c877576c8c2856dfb55967835df33e8589e78
data 9975
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, argv):
        "Initialize repo object from fast-import stream."
        verbose = False
        (options, arguments) = getopt.getopt(argv[1:], "v")
        for (opt, arg) in options:
            if opt == '-v':
                verbose = True
        if not arguments:
            fp = sys.stdin
        else:
            error("load subcommand does not take arguments", atline=False)
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv[0]
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        try:
            repo = Repository()
            repo.fast_import(sys.argv)
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/tags/lightweight-sample
mark :21
original-oid 7061b12e77a7cb2a85ae20a93ed23155043af608
author Eric S. Raymond <esr@thyrsus.com> 1288009568 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288009568 -0400
data 26
Typo fix and name change.
from :19
M 100755 :20 rs

blob
mark :22
original-oid 39b284af98c3fec8a0c37729df4fab127588de59
data 1499
= Reposurgeon Theory of Operation =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that
version-control systems don't want to let you do, such as (a) editing
past comments and metadata, (b) excising commits, (c) coalescing
commits, and (d) removing files and subtrees from repo history. The
original motivation for reposurgeon was to clean up artifacts
created by repository conversions.

To keep reposurgeon simple and flexible, it does not do its own
repository reading and writing.  Instead, it relies on being able to
parse and emit the dump format created by git-fast-export and read by
git-fast-import.  This means that it can be used on any
version-control system that that has both fast-export and fast-import
utilities.  This set includes git itself, hg, bzr, and Subversion. As
version-control systems add support for the fast-import format, their
reppositories will automatically become editable by repoosurgeon see 
the https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools[Git 
Wiki tools page] for a large collection of such tools.

It is a design constraint that all reposurgeon operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.  Users should, however, be aware
of limitations in the ability of the fast-import format to capture 
repository state. Presently the most significant such limitation is
that the dumps do not capture git lightweight tags.





commit refs/tags/lightweight-sample
mark :23
original-oid 531f6a25a7304b744289aa1fcc2ac53b58ad37eb
author Eric S. Raymond <esr@thyrsus.com> 1288009592 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288009592 -0400
data 27
Upate theory of operation.
from :21
M 100644 :22 theory.txt

blob
mark :24
original-oid ef2c296ecfbc92813fe79518f3b3b5ef1f330642
data 12567
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def load_repo(source):
    "Load a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist"
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.page = 1
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_load(self, line):
        if not line:
            line = '.';
        self.repo = load_repo(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :25
original-oid 6c0ee9e9e9bea3d40101bd2940f9d20d4fa36399
author Eric S. Raymond <esr@thyrsus.com> 1288031844 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288031844 -0400
data 38
First successful interpreted command.
from :23
M 100755 :24 rs

blob
mark :26
original-oid 119b156bd74eeb2d7a56a733deda01d0eb850af3
data 12575
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def load_repo(source):
    "Load a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist"
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.page = 1
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_load(self, line):
        if not line:
            line = '.';
        self.repo = load_repo(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :27
original-oid d1114642f48024bb4242940316fa8c1156f3501f
data 2028
= Reposurgeon Theory of Operation =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that
version-control systems don't want to let you do, such as (a) editing
past comments and metadata, (b) excising commits, (c) coalescing
commits, and (d) removing files and subtrees from repo history. The
original motivation for reposurgeon was to clean up artifacts
created by repository conversions.

To keep reposurgeon simple and flexible, it does not do its own
repository reading and writing.  Instead, it relies on being able to
parse and emit the dump format created by git-fast-export and read by
git-fast-import.  This means that it can be used on any
version-control system that that has both fast-export and fast-import
utilities.  This set includes git itself, hg, and bzr. 

Subversion/RCS/CVS aren't directly supported because exporting from
them requires fixups of usernames in the committer information to full
email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform dump files and cope with the export/import himself.

As version-control systems add support for the fast-import format,
their reppositories will automatically become editable by repoosurgeon
see the
https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools[Git
Wiki tools page] for a large collection of such tools.

It is a design constraint that all reposurgeon operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.  Users should, however, be aware
of limitations in the ability of the fast-import format to capture 
repository state. Presently the most significant such known 
limitations are:

* Under git, dumps do not capture git lightweight tags.

* Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.





commit refs/tags/lightweight-sample
mark :28
original-oid e463ad0b332c085d7ccd4b905166d3c3ad1e8477
author Eric S. Raymond <esr@thyrsus.com> 1288032988 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288032988 -0400
data 22
Document limitations.
from :25
M 100755 :26 rs
M 100644 :27 theory.txt

blob
mark :29
original-oid bba17e7c44ee8df3b83fa3d8f43939598f0b9a92
data 12893
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def load_repo(source):
    "Load a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist"
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.page = 1
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_load(self, line):
        if not line:
            line = '.';
        self.repo = load_repo(line)
        print "rs: %d commits, %d blobs, %d marks, %d tags" % \
              (len(self.repo.commits),
               self.repo.nblobs,
               self.repo.nmarks,
               len(self.repo.tags))
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :30
original-oid 4b5e7a743df5417e0de6cbfeb019b0099edd3e24
author Eric S. Raymond <esr@thyrsus.com> 1288033905 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288033905 -0400
data 32
Fix a bug, add instrumentation.
from :28
M 100755 :29 rs

blob
mark :31
original-oid 36ac0dec2cb08a19d1876d7818daccf54a91eda5
data 13693
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source):
    "Read a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(target):
    "Write a repository using fast-export."
    pass

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        self.repo.fast_export(sys.stdout)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :32
original-oid b629b38523fb8c11a3e27cee35104f869af2eba4
author Eric S. Raymond <esr@thyrsus.com> 1288035346 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288035346 -0400
data 43
Partial fast-export (everything but blobs.
from :30
M 100755 :31 rs

blob
mark :33
original-oid 657f34f4e3fdce639bf870eb65419996e3581b72
data 14364
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source):
    "Read a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(target):
    "Write a repository using fast-export."
    pass

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        self.repo.fast_export(sys.stdout)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :34
original-oid 62d35e0421c2e4edeffd01911abee19c62498817
author Eric S. Raymond <esr@thyrsus.com> 1288049092 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288049092 -0400
data 30
Blob dumping appears to work.
from :32
M 100755 :33 rs

blob
mark :35
original-oid 86e71181874a6ed90c52edef3559dec8f4c23a80
data 14865
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :36
original-oid 1de32e17432ae5d811285ea57bdd1a8d06364063
author Eric S. Raymond <esr@thyrsus.com> 1288057381 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288057381 -0400
data 40
We interpret command-ine arguments now.
from :34
M 100755 :35 rs

blob
mark :37
original-oid 8825966f50ae91c60a36b7b60afc03a9b4619ac0
data 15019
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob\nmark %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :38
original-oid f52211c2dfe28d975dae449f52cee26de4f8d335
author Eric S. Raymond <esr@thyrsus.com> 1288058277 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288058277 -0400
data 53
We're pretty close to round-tripping a git dump now.
from :36
M 100755 :37 rs

blob
mark :39
original-oid 5bbfe4ad071bd6df763afc86d4cd1d26a7acb770
data 15203
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.refs_to_branches = {}
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[7:].strip()
                line = readline()
                if line.startswith("from"):
                    self.refs_to_branches[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob\nmark %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        branches = self.refs_to_branches.keys()
        for branch in branches:
            fp.write("reset %s\nmark %s\n\n" % (branch, self.refs_to_branches[branch]))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :40
original-oid fc1f7520d4b8d5eed82492c196e350b02c57635a
author Eric S. Raymond <esr@thyrsus.com> 1288068011 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288068011 -0400
data 53
Checkpoint before tring to write only requred marks.
from :38
M 100755 :39 rs

blob
mark :41
original-oid 70c93779ca6860e39a061da3182f746623505fb4
data 15448
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.refs_to_branches = {}
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    self.refs_to_branches[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob\nmark %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        branches = self.refs_to_branches.keys()
        for branch in branches:
            fp.write("reset %s\nfrom %s\n\n" % (branch, self.refs_to_branches[branch]))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :42
original-oid 1fb40e38dd6ec242668cb94471063d873f9ca7b2
author Eric S. Raymond <esr@thyrsus.com> 1288069444 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288069444 -0400
data 62
This round-trips everything except the lightweight tag stuff.
from :40
M 100755 :41 rs

blob
mark :43
original-oid 1323ffc3dd66e1e2607c4e478af84f4bae7c59b5
data 15549
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __repr__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __repr__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(repr(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :44
original-oid 596d9f63dacaf804eef09e1abf1fd9c35df9b9ef
author Eric S. Raymond <esr@thyrsus.com> 1288082031 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288082031 -0400
data 40
OK, now we have perfect round-tripping.
from :42
M 100755 :43 rs

blob
mark :45
original-oid 624e463794fb4a60c7f647a15da7c3296cf51d71
data 465
			rs - a repository surgeon

eposurgeon enables risky operations that version-control systems don't
want to let you do, such as (a) editing past comments and metadata,
(b) excising commits, (c) coalescing commits, and (d) removing files
and subtrees from repo history. The original motivation for
reposurgeon was to clean up artifacts created by repository
conversions.

To test the correctness of this software, change to the 'test' subdirectory
and type 'make'.

blob
mark :46
original-oid 1540a1d0b433608a18cb4bc914de1d8b0c977c35
data 15565
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __repr__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __repr__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(repr(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :47
original-oid aa825b4718d2b66629615bba84d1c0d543ce7632
data 362
# Test-suite makefile for rs

all: roundtrip

# Test that all dumpfiles round-trip properly
# Test suceeds if there is no output.
roundtrip:
	echo "Testing round-tripping of dump file. No diff output is good news."
	for file in *.dump; do \
	    ../rs "read -;write -" <$$file >/tmp/rs$$$$; \
	    diff -u $${file} /tmp/rs$$$$; \
	    rm -f /tmp/rs$$$$; \
	done

blob
mark :48
original-oid 5313c64ee1ac8d4d6f0f8d92ea04fd6acefec714
data 183504
blob
mark :1
data 53
#!/ysr/bin/env python
#
# rs - a repository surgeon.

reset refs/heads/master
commit refs/heads/master
mark :2
author Eric S. Raymond <esr@thyrsus.com> 1287754582 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287754582 -0400
data 22
The adventure begins.
M 100644 :1 rs

blob
mark :3
data 621
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, cid, comment, branch, parents):
        self.timestamp = timestamp
        self.id = cid
        self.comment = comment
        self.branch = branch
        self.parents = parents

class GitSlicer:
    "Repo-slicing methods for the Git version-control system"
    def __init__(repo):
        pass

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

commit refs/heads/master
mark :4
author Eric S. Raymond <esr@thyrsus.com> 1287755564 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287755564 -0400
data 28
Beginnings of core classes.
from :2
M 100755 :3 rs

blob
mark :5
data 1329
= Reposurgeon Designer's Notes =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that version-control
systems don't want to let you do, such as (a) editing past comments and 
metadata, (b) excising commits, and (c) coalescing commits. The motivation
for reposurgeon was to help with artifacts and sca r tisue created by 
repository conversions.

The reposurgeon tool depends on being able to map all the version-control
systems it knows about into a common data model.  Here are the components 
of the model:

1. A sequence of commit objects.  The primary key for these objects is
the date of the commit. Each commit represents an ebtire state of
some file tree.

2. A map of the is-a-parent-of relationship. A commit may have multiplre 
parents; the map implies a DAG (directed acyclic graph) of commits.

3. A list of branch heads.  This is a mapping from names to tip 
revisions in the DAG.

4. A list of tags (name-to-commit mappings).

This model is intended to capture the common semantics of distributed
version-control systems: the three specific tarhets are git, hg, and
Subversion (more may be added in future).

It is a design constraint that all reposurgeon operations either prserve
all VCS-specific metadata thety are not told to modify or warn you when
they cannot.





commit refs/heads/master
mark :6
author Eric S. Raymond <esr@thyrsus.com> 1287759014 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287759014 -0400
data 27
Beginning of design notes.
from :4
M 100644 :5 theory.txt

blob
mark :7
data 1022
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, comment, parents):
        self.timestamp = timestamp   # Primary key
        self.comment = comment       # Commit comment
        self.parents = parents       # List of parent nodes
        self.branch = branch         # branch name (deduced optimization hack)

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings

class GitSlicer:
    "Repo-slicing methods for the Git version-control system"
    def __init__(repo):
        pass

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

blob
mark :8
data 1329
= Reposurgeon Designer's Notes =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that version-control
systems don't want to let you do, such as (a) editing past comments and 
metadata, (b) excising commits, and (c) coalescing commits. The motivation
for reposurgeon was to help with artifacts and scar tisue created by 
repository conversions.

The reposurgeon tool depends on being able to map all the version-control
systems it knows about into a common data model.  Here are the components 
of the model:

1. A sequence of commit objects.  The primary key for these objects is
the date of the commit. Each commit represents an ebtire state of
some file tree.

2. A map of the is-a-parent-of relationship. A commit may have multiplre 
parents; the map implies a DAG (directed acyclic graph) of commits.

3. A list of branch heads.  This is a mapping from names to tip 
revisions in the DAG.

4. A list of tags (name-to-commit mappings).

This model is intended to capture the common semantics of distributed
version-control systems: the three specific tarhets are git, hg, and
Subversion (more may be added in future).

It is a design constraint that all reposurgeon operations either preserve
all VCS-specific metadata thety are not told to modify or warn you when
they cannot.





commit refs/heads/master
mark :9
author Eric S. Raymond <esr@thyrsus.com> 1287768418 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287768418 -0400
data 40
Sync data structures with design notes.
from :6
M 100755 :7 rs
M 100644 :8 theory.txt

blob
mark :10
data 2339
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, author, committer, comment, parents):
        self.timestamp = timestamp   # Primary key
        self.author = author         # Aujtor of commit
        self.committer = committer   # Person responsible for committing it.
        self.comment = comment       # Commit comment
        self.parents = parents       # List of parent nodes
        self.branch = branch         # branch name (deduced optimization hack)

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.__marks = []
    def fast_import(fp):
        "Initialize repo object from fast import."
        os.mkdir(".rs")     # May throw os.error
        os.mkdir(".rs/history")
        mark = None
        for line in fp:
            if line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line)
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                continue     # FIXME
            elif line.startswith("commit"):
                continue     # FIXME
            elif line.startswith("reset"):
                continue     # FIXME
            elif line.startswith("tag"):
                continue     # FIXME
            else:
                raise RepoSurgeonException("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

commit refs/heads/master
mark :11
author Eric S. Raymond <esr@thyrsus.com> 1287919107 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287919107 -0400
data 31
Skeleton of fast-import logic.
from :9
M 100755 :10 rs

blob
mark :12
data 4234
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands

class GenericCommit:
    "Generic commit object."
    def __init__(self, timestamp, author, committer, comment, parents):
        self.timestamp = timestamp   # Primary key
        self.author = author         # Aujtor of commit
        self.committer = committer   # Person responsible for committing it.
        self.comment = comment       # Commit comment
        self.parents = parents       # List of parent nodes
        self.branch = branch         # branch name (deduced optimization hack)

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.nmarks = 0
    def fast_import(fp):
        "Initialize repo object from fast-import stream."
        os.mkdir(".rs")     # May throw OSError
        os.mkdir(".rs/history")
        tags_to_marks = {}
        import_line = 0
        def error(msg):
            raise RepoSurgeonException(msg + (" at line " + `import_line`)
        def read_data(dp):
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            else:
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueError:
                    raise error("bad count in data")
            else:
                    raise error("malformed data header")
            return
        for line in fp:
            import_line += 1
            if line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                nextline = fp.readline()
                import_line += 1
                if readline.startwith("mark"):
                    mark = nextline[5:].strip()
                    read_data(open(".rs/blob" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    error("missing mark after blob")
            elif line.startswith("data"):
                error("unexpected data object")
            elif line.startswith("commit"):
                continue     # FIXME
            elif line.startswith("reset"):
                tagname = line[4:].strip()
                nextline = fp.readline()
                import_line += 1
                if nextline.startswith("from"):
                    tags_to_marks[tagname] = nextline[5:].strip()
                else:
                    error("missing from after reset")
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                nextline = fp.readline()
                import_line += 1
                if nextline.startswith("from"):
                    tags_to_marks[tagname] = nextline[5:].strip()
                else:
                    error("missing from after tag")
                self.read_data(open(".rs/tag" + tagname, "w")).close()
            else:
                raise error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

if __name__ == '__main__':
    #subcommand = sys.argv[1]
    #(options, arguments) = getopt.getopt(sys.argv[2:], "")
    print "No mainline code yet"

commit refs/heads/master
mark :13
author Eric S. Raymond <esr@thyrsus.com> 1287925789 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287925789 -0400
data 47
Fast-import reading except for commit objects.
from :11
M 100755 :12 rs

blob
mark :14
data 8457
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance pof a person acting on the repo."
    def __init__(self, name, email, when):
        self,name = name
        self.email = email
        self.when = when
    def __repr__(self):
        return self.name + " " + self.email + " " + self.when

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = None          # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, fp):
        "Initialize repo object from fast-import stream."
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header")
            return
        def readline():
            if linebuffers:
                return linebuffers.pop()
            else:
                self.import_line += 1
                return fp.readline()
        def pushback(line):
            self.linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                nextline = readline()
                if line.startswith("mark"):
                    mark = nextline[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = currentbranch
                ncommits += 1
                inlinecount = 0
                while True:
                    nextline = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = nextline[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            (name, email, when) = line.split()
                            commit.author = Action(name, email, when)
                        except ValueSelf.Error:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            (name, email, when) = line.split()
                            commit.committer = Action(name, email, when)
                        except ValueSelf.Error:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = self.read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.ancestors.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.filemap.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.filemap.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            fileop.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            fileop.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                nextline = readline()
                if nextline.startswith("from"):
                    refs_to_marks[currentbranch] = nextline[5:].strip()
                else:
                    self.error("missing from after reset")
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                nextline = readline()
                if nextline.startswith("from"):
                    refs_to_marks[tagname] = nextline[5:].strip()
                else:
                    self.error("missing from after tag")
                self.read_data(open(".rs/tag-" + tagname, "w")).close()
            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv.pop(0)
    (options, arguments) = getopt.getopt(sys.argv[2:], "")
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        repo = GenericRepo()
        try:
            if not arguments:
                repo.fast_import(sys.stdin)
            else:
                fatal("rs: unsupported load mode")
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/heads/master
mark :15
author Eric S. Raymond <esr@thyrsus.com> 1287956274 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287956274 -0400
data 30
First commands are executing.
from :13
M 100755 :14 rs

blob
mark :16
data 8874
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance pof a person acting on the repo."
    def __init__(self, name, email, when):
        self.name = name
        self.email = email
        self.when = when
    def __repr__(self):
        return self.name + " " + self.email + " " + self.when

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.map = []       # List of commit-to-parent mappings
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, argv):
        "Initialize repo object from fast-import stream."
        verbose = False
        (options, arguments) = getopt.getopt(argv[1:], "v")
        for (opt, arg) in options:
            if opt == '-v':
                verbose = True
        if not arguments:
            fp = sys.stdin
        else:
            error("load subcommand does not take arguments", atline=False)
        print "Foo!", argv, options, verbose
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            if verbose:
                print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            line = line.replace(" <", "|").replace("> ", "|")
                            (name, email, when) = line[7:].strip().split("|")
                            commit.author = Action(name, email, when)
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            line = line.replace(" <", "|").replace("> ", "|")
                            (name, email, when) = line[10:].strip().split("|")
                            commit.committer = Action(name, email, when)
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.filemap.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.filemap.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[tagname] = line[5:].strip()
                else:
                    self.error("missing from after tag")
                read_data(open(".rs/tag-" + tagname, "w")).close()
            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv[0]
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        try:
            repo = GenericRepo()
            repo.fast_import(sys.argv)
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/heads/master
mark :17
author Eric S. Raymond <esr@thyrsus.com> 1287991809 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287991809 -0400
data 36
Options processing for subcommands.
from :15
M 100755 :16 rs

blob
mark :18
data 9978
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance pof a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class GenericRepo:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, argv):
        "Initialize repo object from fast-import stream."
        verbose = False
        (options, arguments) = getopt.getopt(argv[1:], "v")
        for (opt, arg) in options:
            if opt == '-v':
                verbose = True
        if not arguments:
            fp = sys.stdin
        else:
            error("load subcommand does not take arguments", atline=False)
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv[0]
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        try:
            repo = GenericRepo()
            repo.fast_import(sys.argv)
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/heads/master
mark :19
author Eric S. Raymond <esr@thyrsus.com> 1287995066 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287995066 -0400
data 31
First parse of an entire dump.
from :17
M 100755 :18 rs

blob
mark :20
data 9975
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def fast_import(self, argv):
        "Initialize repo object from fast-import stream."
        verbose = False
        (options, arguments) = getopt.getopt(argv[1:], "v")
        for (opt, arg) in options:
            if opt == '-v':
                verbose = True
        if not arguments:
            fp = sys.stdin
        else:
            error("load subcommand does not take arguments", atline=False)
        try:
            os.mkdir(".rs")     # May throw OSError
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(".rs/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = ".rs/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

def usage():
    print >>sys.stderr,"""\
usage: rs command [option..]

Commands are as follows

    help       -- emit this help message             
    load       -- prepare a repo for surgery
    clear      -- clear the operating theater
"""

if __name__ == '__main__':
    sys.argv.pop(0)
    if not sys.argv:
        usage()
        raise SystemExit, 0
    command = sys.argv[0]
    if command in ("help", "usage"):
        usage()
    elif command == "clear":
        os.system("rm -fr .rs")
    elif command == "load":
        try:
            repo = Repository()
            repo.fast_import(sys.argv)
        except RepoSurgeonException, e:
            fatal(e.msg)
    else:
        print >>sys.stderr,"rs: unknown command"

# end

commit refs/heads/master
mark :21
author Eric S. Raymond <esr@thyrsus.com> 1288009568 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288009568 -0400
data 26
Typo fix and name change.
from :19
M 100755 :20 rs

blob
mark :22
data 1499
= Reposurgeon Theory of Operation =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that
version-control systems don't want to let you do, such as (a) editing
past comments and metadata, (b) excising commits, (c) coalescing
commits, and (d) removing files and subtrees from repo history. The
original motivation for reposurgeon was to clean up artifacts
created by repository conversions.

To keep reposurgeon simple and flexible, it does not do its own
repository reading and writing.  Instead, it relies on being able to
parse and emit the dump format created by git-fast-export and read by
git-fast-import.  This means that it can be used on any
version-control system that that has both fast-export and fast-import
utilities.  This set includes git itself, hg, bzr, and Subversion. As
version-control systems add support for the fast-import format, their
reppositories will automatically become editable by repoosurgeon see 
the https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools[Git 
Wiki tools page] for a large collection of such tools.

It is a design constraint that all reposurgeon operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.  Users should, however, be aware
of limitations in the ability of the fast-import format to capture 
repository state. Presently the most significant such limitation is
that the dumps do not capture git lightweight tags.





commit refs/heads/master
mark :23
author Eric S. Raymond <esr@thyrsus.com> 1288009592 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288009592 -0400
data 27
Upate theory of operation.
from :21
M 100644 :22 theory.txt

blob
mark :24
data 12567
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def load_repo(source):
    "Load a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist"
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.page = 1
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_load(self, line):
        if not line:
            line = '.';
        self.repo = load_repo(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :25
author Eric S. Raymond <esr@thyrsus.com> 1288031844 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288031844 -0400
data 38
First successful interpreted command.
from :23
M 100755 :24 rs

blob
mark :26
data 12575
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def load_repo(source):
    "Load a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist"
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.page = 1
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_load(self, line):
        if not line:
            line = '.';
        self.repo = load_repo(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :27
data 2028
= Reposurgeon Theory of Operation =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that
version-control systems don't want to let you do, such as (a) editing
past comments and metadata, (b) excising commits, (c) coalescing
commits, and (d) removing files and subtrees from repo history. The
original motivation for reposurgeon was to clean up artifacts
created by repository conversions.

To keep reposurgeon simple and flexible, it does not do its own
repository reading and writing.  Instead, it relies on being able to
parse and emit the dump format created by git-fast-export and read by
git-fast-import.  This means that it can be used on any
version-control system that that has both fast-export and fast-import
utilities.  This set includes git itself, hg, and bzr. 

Subversion/RCS/CVS aren't directly supported because exporting from
them requires fixups of usernames in the committer information to full
email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform dump files and cope with the export/import himself.

As version-control systems add support for the fast-import format,
their reppositories will automatically become editable by repoosurgeon
see the
https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools[Git
Wiki tools page] for a large collection of such tools.

It is a design constraint that all reposurgeon operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.  Users should, however, be aware
of limitations in the ability of the fast-import format to capture 
repository state. Presently the most significant such known 
limitations are:

* Under git, dumps do not capture git lightweight tags.

* Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.





commit refs/heads/master
mark :28
author Eric S. Raymond <esr@thyrsus.com> 1288032988 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288032988 -0400
data 22
Document limitations.
from :25
M 100755 :26 rs
M 100644 :27 theory.txt

blob
mark :29
data 12893
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, self.content)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n"
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                str += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")

def load_repo(source):
    "Load a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist"
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.page = 1
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_load(self, line):
        if not line:
            line = '.';
        self.repo = load_repo(line)
        print "rs: %d commits, %d blobs, %d marks, %d tags" % \
              (len(self.repo.commits),
               self.repo.nblobs,
               self.repo.nmarks,
               len(self.repo.tags))
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :30
author Eric S. Raymond <esr@thyrsus.com> 1288033905 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288033905 -0400
data 32
Fix a bug, add instrumentation.
from :28
M 100755 :29 rs

blob
mark :31
data 13693
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op) + "\n"
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            commit.fileops.append((op, mode, ref, path))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source):
    "Read a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(target):
    "Write a repository using fast-export."
    pass

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        self.repo.fast_export(sys.stdout)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :32
author Eric S. Raymond <esr@thyrsus.com> 1288035346 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288035346 -0400
data 43
Partial fast-export (everything but blobs.
from :30
M 100755 :31 rs

blob
mark :33
data 14364
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source):
    "Read a repository using fast-import."
    if not os.path.exists(source):
        print "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(target):
    "Write a repository using fast-export."
    pass

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        self.repo.fast_export(sys.stdout)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        RepoSurgeon().cmdloop()
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :34
author Eric S. Raymond <esr@thyrsus.com> 1288049092 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288049092 -0400
data 30
Blob dumping appears to work.
from :32
M 100755 :33 rs

blob
mark :35
data 14865
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = tagger
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s\n" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print "rs: could not find a repository under %s" % source
            return None
        print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :36
author Eric S. Raymond <esr@thyrsus.com> 1288057381 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288057381 -0400
data 40
We interpret command-ine arguments now.
from :34
M 100755 :35 rs

blob
mark :37
data 15019
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        refs_to_marks = {}
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    refs_to_marks[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob\nmark %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :38
author Eric S. Raymond <esr@thyrsus.com> 1288058277 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288058277 -0400
data 53
We're pretty close to round-tripping a git dump now.
from :36
M 100755 :37 rs

blob
mark :39
data 15203
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.refs_to_branches = {}
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        self.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[7:].strip()
                line = readline()
                if line.startswith("from"):
                    self.refs_to_branches[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob\nmark %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        branches = self.refs_to_branches.keys()
        for branch in branches:
            fp.write("reset %s\nmark %s\n\n" % (branch, self.refs_to_branches[branch]))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :40
author Eric S. Raymond <esr@thyrsus.com> 1288068011 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288068011 -0400
data 53
Checkpoint before tring to write only requred marks.
from :38
M 100755 :39 rs

blob
mark :41
data 15448
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)
        
class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commits = []   # A list of commit objects
        self.branches = []  # A list of branchname-to-commit mappings
        self.tags = []      # List of tag-to-commit
        self.nmarks = 0
        self.refs_to_branches = {}
        self.nblobs = 0
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        currentbranch = "master"
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                line = readline()
                if line.startswith("mark"):
                    mark = line[5:].strip()
                    read_data(open(self.subdir + "/blob-" + mark, "w")).close()
                    self.nmarks += 1
                    self.nblobs += 1
                else:
                    self.error("missing mark after blob")
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commits.append(commit)
            elif line.startswith("reset"):
                currentbranch = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    self.refs_to_branches[currentbranch] = line[5:].strip()
                else:
                    pushback(line)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.tags.append(Tag(tagname,
                                     referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for commit in self.commits:
            for fileop in commit.fileops:
                if type(fileop) == type(()):
                    ref = fileop[2]
                    if ref[0] == ':':
                        dp = open(fileop[4])
                        content = dp.read()
                        dp.close()
                        fp.write("blob\nmark %s\ndata %d\n%s\n" % (ref, len(content), content))
            fp.write(repr(commit))
        branches = self.refs_to_branches.keys()
        for branch in branches:
            fp.write("reset %s\nfrom %s\n\n" % (branch, self.refs_to_branches[branch]))
        for tag in self.tags:
            fp.write(repr(tag))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                   initializer,
                                                                   importer,
                                                                   checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commits, %d blobs, %d marks, %d tags" % \
                  (len(self.repo.commits),
                   self.repo.nblobs,
                   self.repo.nmarks,
                   len(self.repo.tags))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.oncmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :42
author Eric S. Raymond <esr@thyrsus.com> 1288069444 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288069444 -0400
data 62
This round-trips everything except the lightweight tag stuff.
from :40
M 100755 :41 rs

reset refs/heads/master
from :42

reset refs/tags/foo
from :42


commit refs/tags/lightweight-sample
mark :49
original-oid 91fc97c6bab012880e02f0811023b565fd54c50f
author Eric S. Raymond <esr@thyrsus.com> 1288083745 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288083745 -0400
data 36
Add and document a regression test.
from :44
M 100644 :45 READ[ME].txt
M 100755 :46 rs
M 100644 :47 test/Makefile
M 100644 :48 test/simple.dump

blob
mark :50
original-oid 52b22048d8cf25e9cdeffcc0dc6eb346b8703b70
data 1969
= Reposurgeon Theory of Operation =
Eric S. Raymond <esr@thyrsus.com>

The purpose of reposurgeon is to enable risky operations that
version-control systems don't want to let you do, such as (a) editing
past comments and metadata, (b) excising commits, (c) coalescing
commits, and (d) removing files and subtrees from repo history. The
original motivation for reposurgeon was to clean up artifacts
created by repository conversions.

To keep reposurgeon simple and flexible, it does not do its own
repository reading and writing.  Instead, it relies on being able to
parse and emit the dump format created by git-fast-export and read by
git-fast-import.  This means that it can be used on any
version-control system that that has both fast-export and fast-import
utilities.  This set includes git itself, hg, and bzr. 

Subversion/RCS/CVS aren't directly supported because exporting from
them requires fixups of usernames in the committer information to full
email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform dump files and cope with the export/import himself.

As version-control systems add support for the fast-import format,
their repositories will automatically become editable by reposurgeon
see the
https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools[Git
Wiki tools page] for a large collection of such tools.

It is a design constraint that all reposurgeon operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.  Users should, however, be aware
of limitations in the ability of the fast-import format to capture 
repository state. Presently the most significant such known 
limitations are:

* Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.





commit refs/tags/lightweight-sample
mark :51
original-oid 604abbb5489adfcf8cd62a7d61d8b67d6f4a4b41
author Eric S. Raymond <esr@thyrsus.com> 1288083882 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288083882 -0400
data 53
git-fast-export captures lightweight tags after all.
from :49
M 100644 :50 theory.txt

blob
mark :52
original-oid 136d653651b46d56e3d1008084b3a679144f3b7f
data 15686
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __repr__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __repr__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __repr__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __repr__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __repr__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(repr(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :53
original-oid e675556ea1cceb11ec74718992189ea7d1445056
author Eric S. Raymond <esr@thyrsus.com> 1288087302 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288087302 -0400
data 34
Re-enable command interpretation.
from :51
M 100755 :52 rs

blob
mark :54
original-oid 4d5d931bf24dcf6cc5ec165c144025b15c6376a1
data 15680
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif line.startswith("#") or line.startswith("checkpoint"):
                continue
            elif not line.strip():
                continue
            elif line.startswith("progress"):
                sys.stdout.write(line[9:])
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("options"):
                continue     # Might need real code here someday
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                raise self.error("unexpected line in import stream")
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :55
original-oid 7c7b8150cdacc5cb1b3b3b8f90c41389d095ebe5
author Eric S. Raymond <esr@thyrsus.com> 1288087772 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288087772 -0400
data 13
repr -> str.
from :53
M 100755 :54 rs

blob
mark :56
original-oid f46a54c80ee63118b910c466ac7432d541a3c19e
data 364
# Test-suite makefile for rs

all: roundtrip

# Test that all dumpfiles round-trip properly
# Test suceeds if there is no output.
roundtrip:
	@echo "Testing round-tripping of dump file. No diff output is good news."
	@for file in *.dump; do \
	    ../rs "read -;write -" <$$file >/tmp/rs$$$$; \
	    diff -u $${file} /tmp/rs$$$$; \
	    rm -f /tmp/rs$$$$; \
	done

commit refs/tags/lightweight-sample
mark :57
original-oid ae0543ddab85dc330008268ad4b30aed11647f7e
author Eric S. Raymond <esr@thyrsus.com> 1288087832 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288087832 -0400
data 37
Quiet the regression tests a little.
from :55
M 100644 :56 test/Makefile

blob
mark :58
original-oid 3871059d1635d5c6847d0b3c87d03a51ce7a73ba
data 15311
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :59
original-oid c65f2015adcdbf6939a791dcb1914e9976272d98
author Eric S. Raymond <esr@thyrsus.com> 1288088010 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288088010 -0400
data 28
Pass through mystery lines.
from :57
M 100755 :58 rs

blob
mark :60
original-oid 528a6d7a858f19724bf07f4966f625a89df06d66
data 16156
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "Set the interpreter's verbosity level."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :61
original-oid 6d392833d77c6929286cc2bc8504441c7779cafe
author Eric S. Raymond <esr@thyrsus.com> 1288092270 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288092270 -0400
data 28
Add do_shell and some help.
from :59
M 100755 :60 rs

blob
mark :62
original-oid fab9ae8debe53126b56244aae2d8b5d241f224ec
data 20
*.1
*.html
MANIFEST

blob
mark :63
original-oid a4ed127754c67e4deb9f15a36ddf8a274066c6fb
data 717
#
# makefile for reposugeon
#
VERS=1.0

SOURCES = README COPYING reposurgeon reposurgeon.xml reposurgeon.6 Makefile reposurgeon.spec

all: reposurgeon.1

reposurgeon.1: reposurgeon.xml
	xmlto man reposurgeon.xml

reposurgeon.html: reposurgeon.xml
	xmlto html-nochunks reposurgeon.xml

clean:
	rm -f *~ *.1 *.html MANIFEST SHIPPER.*

reposurgeon-$(VERS).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:reposurgeon-$(VERS)/: >MANIFEST
	@(cd ..; ln -s reposurgeon reposurgeon-$(VERS))
	(cd ..; tar -czvf reposurgeon/reposurgeon-$(VERS).tar.gz `cat reposurgeon/MANIFEST`)
	@(cd ..; rm reposurgeon-$(VERS))

dist: reposurgeon-$(VERS).tar.gz

release: reposurgeon-$(VERS).tar.gz reposurgeon.html
	shipper -u -m -t; make clean

blob
mark :64
original-oid e20b50c2a4262f3f5963bb59d24bd1641b6e6273
data 5972
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>rs</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose' option.</para>

<para>Here are the available commands:</para>

<variablelist>
<varlistentry><term>help</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry><term>version</term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry><term>verbose</term>
<listitem><para>'verbose 1' enables progress and statistics messages,
'verbose 0' disables them. 
</para></listitem>
</varlistentry>
<varlistentry><term>shell</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry><term>read</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


blob
mark :65
original-oid e0964e4bdde20a654af0416d331eacf41e7d2fbf
data 16419
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "rs: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"rs: could not find a repository under %s" % source
            return None
        if verbose:
            print "rs: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "rs:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "rs# "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "rs: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes))
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "rs: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :66
original-oid 4b804d7e554cbd74aa96c3df86fa973425012541
author Eric S. Raymond <esr@thyrsus.com> 1288093185 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288093185 -0400
data 65
Add doccumentation, a makefile, help commands, and shell escape.
from :61
M 100644 :62 .gitignore
M 100644 :63 Makefile
M 100644 :64 reposurgeon.xml
M 100755 :65 rs

blob
mark :67
original-oid 0a05a5fdac5ea9008e3d24ba1f61f004eb82b48a
data 823
#
# makefile for reposugeon
#
VERS=VERS=$(shell sed <reposurgeon -n -e '/version=\(.*\)/s//\1/p')

SOURCES = README COPYING reposurgeon reposurgeon.xml reposurgeon.6 Makefile reposurgeon.spec

all: reposurgeon.1

reposurgeon.1: reposurgeon.xml
	xmlto man reposurgeon.xml

reposurgeon.html: reposurgeon.xml
	xmlto html-nochunks reposurgeon.xml

clean:
	rm -f *~ *.1 *.html MANIFEST SHIPPER.*

reposurgeon-$(VERS).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:reposurgeon-$(VERS)/: >MANIFEST
	@(cd ..; ln -s reposurgeon reposurgeon-$(VERS))
	(cd ..; tar -czvf reposurgeon/reposurgeon-$(VERS).tar.gz `cat reposurgeon/MANIFEST`)
	@(cd ..; rm reposurgeon-$(VERS))

version:
	@echo $(VERS)

test:
	cd test; make

dist: reposurgeon-$(VERS).tar.gz

release: reposurgeon-$(VERS).tar.gz reposurgeon.html
	shipper -u -m -t; make clean

blob
mark :68
original-oid 9bf70ac40f683bb3e6d898f1b1bd8125ce2fe8df
data 373
# Test-suite makefile for rs

all: roundtrip

# Test that all dumpfiles round-trip properly
# Test suceeds if there is no output.
roundtrip:
	@echo "Testing round-tripping of dump file. No diff output is good news."
	@for file in *.dump; do \
	    ../reposurgeon "read -;write -" <$$file >/tmp/rs$$$$; \
	    diff -u $${file} /tmp/rs$$$$; \
	    rm -f /tmp/rs$$$$; \
	done

commit refs/tags/lightweight-sample
mark :69
original-oid dea6da6d5e2c89240be89092d024df67edc2198e
author Eric S. Raymond <esr@thyrsus.com> 1288093585 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288093585 -0400
data 13
Name change.
from :66
M 100644 :67 Makefile
M 100755 :65 reposurgeon
D rs
M 100644 :68 test/Makefile

blob
mark :70
original-oid 201045a04b7b3f119b05e849f7d49abf4d07e10a
data 824
#
# makefile for reposugeon
#
VERS=VERS=$(shell sed <reposurgeon -n -e '/version=\(.*\)/s//\1/p')

SOURCES = README COPYING reposurgeon reposurgeon.xml reposurgeon.6 Makefile reposurgeon.spec

all: reposurgeon.1

reposurgeon.1: reposurgeon.xml
	xmlto man reposurgeon.xml

reposurgeon.html: reposurgeon.xml
	xmlto html-nochunks reposurgeon.xml

clean:
	rm -f *~ *.1 *.html MANIFEST SHIPPER.*

reposurgeon-$(VERS).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:reposurgeon-$(VERS)/: >MANIFEST
	@(cd ..; ln -s reposurgeon reposurgeon-$(VERS))
	(cd ..; tar -czvf reposurgeon/reposurgeon-$(VERS).tar.gz `cat reposurgeon/MANIFEST`)
	@(cd ..; rm reposurgeon-$(VERS))

version:
	@echo $(VERS)

check:
	cd test; make

dist: reposurgeon-$(VERS).tar.gz

release: reposurgeon-$(VERS).tar.gz reposurgeon.html
	shipper -u -m -t; make clean

commit refs/tags/lightweight-sample
mark :71
original-oid b867834c5003656021f91b04d4e0b79f092f9469
author Eric S. Raymond <esr@thyrsus.com> 1288093728 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288093728 -0400
data 27
Avoid an aliasing problem.
from :69
M 100644 :70 Makefile

blob
mark :72
original-oid 62d792b13a9690ee1ff1d55ca0cc8950a5bb2f1f
data 825
#
# makefile for reposurgeon
#
VERS=VERS=$(shell sed <reposurgeon -n -e '/version=\(.*\)/s//\1/p')

SOURCES = README COPYING reposurgeon reposurgeon.xml reposurgeon.6 Makefile reposurgeon.spec

all: reposurgeon.1

reposurgeon.1: reposurgeon.xml
	xmlto man reposurgeon.xml

reposurgeon.html: reposurgeon.xml
	xmlto html-nochunks reposurgeon.xml

clean:
	rm -f *~ *.1 *.html MANIFEST SHIPPER.*

reposurgeon-$(VERS).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:reposurgeon-$(VERS)/: >MANIFEST
	@(cd ..; ln -s reposurgeon reposurgeon-$(VERS))
	(cd ..; tar -czvf reposurgeon/reposurgeon-$(VERS).tar.gz `cat reposurgeon/MANIFEST`)
	@(cd ..; rm reposurgeon-$(VERS))

version:
	@echo $(VERS)

check:
	cd test; make

dist: reposurgeon-$(VERS).tar.gz

release: reposurgeon-$(VERS).tar.gz reposurgeon.html
	shipper -u -m -t; make clean

blob
mark :73
original-oid 05eecf8d4a43a7e024e6556c423b9cd06443d5db
data 16481
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.repotype = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            
            if os.path.exists(subdir) and os.path.isdir(subdir):
                break
        else:
            print >>sys.stderr,"reposurgeon: could not find a repository under %s" % source
            return None
        if verbose:
            print "reposurgeon: recognized %s repository under %s" % (name, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += exporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    # FIXME: Have to decide a policy here

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        raise RepoSurgeonException("'%s' failed" % cmd)
    else:
        return out

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes))
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.verbose)
        if self.verbose:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            line = '-'
        write_repo(self.repo, line, self.verbose)
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate the browser."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :74
original-oid 9847734c28eec26eb5e4500c9142555a1730b8f8
data 5981
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose' option.</para>

<para>Here are the available commands:</para>

<variablelist>
<varlistentry><term>help</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry><term>version</term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry><term>verbose</term>
<listitem><para>'verbose 1' enables progress and statistics messages,
'verbose 0' disables them. 
</para></listitem>
</varlistentry>
<varlistentry><term>shell</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry><term>read</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/lightweight-sample
mark :75
original-oid d7fd276b01964bbc55e0d83de7c09a59c52b67d3
author Eric S. Raymond <esr@thyrsus.com> 1288093891 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288093891 -0400
data 26
Follow up on name change.
from :71
M 100644 :72 Makefile
M 100644 :74 reposurgeon.xml
M 100755 :73 reposurgeon

blob
mark :76
original-oid 4c6406ab1e95bb65ecae2b2ecb5925099ccf526d
data 808
#
# makefile for reposurgeon
#
VERS=VERS=$(shell sed <reposurgeon -n -e '/version=\(.*\)/s//\1/p')

SOURCES = README COPYING reposurgeon reposurgeon.xml reposurgeon.1 Makefile

all: reposurgeon.1

reposurgeon.1: reposurgeon.xml
	xmlto man reposurgeon.xml

reposurgeon.html: reposurgeon.xml
	xmlto html-nochunks reposurgeon.xml

clean:
	rm -f *~ *.1 *.html MANIFEST SHIPPER.*

reposurgeon-$(VERS).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:reposurgeon-$(VERS)/: >MANIFEST
	@(cd ..; ln -s reposurgeon reposurgeon-$(VERS))
	(cd ..; tar -czvf reposurgeon/reposurgeon-$(VERS).tar.gz `cat reposurgeon/MANIFEST`)
	@(cd ..; rm reposurgeon-$(VERS))

version:
	@echo $(VERS)

check:
	cd test; make

dist: reposurgeon-$(VERS).tar.gz

release: reposurgeon-$(VERS).tar.gz reposurgeon.html
	shipper -u -m -t; make clean

commit refs/tags/lightweight-sample
mark :77
original-oid f4e42dbb524fd0d8b0cfe2e463a5368be0621e2a
author Eric S. Raymond <esr@thyrsus.com> 1288093998 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288093998 -0400
data 22
There is no specfile.
from :75
M 100644 :76 Makefile

blob
mark :78
original-oid 0e950e83b481a977980e8948d3eb40016b2f8247
data 18449
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = [
     ("git",
      ".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
     ("hg",
      ".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
     ("bzr",
      ".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    ]

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        if verbose:
            if preferred:
                print "reposurgeon: looking for a %s repo..."
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, dirname, exporter, initializer, importer, checkout) in vcstypes:
            subdir = os.path.join(source, dirname)
            # FIXME: preference is not implemented
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % source
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % source
            return None
        elif verbose:
            print "reposurgeon: recognized %s repository under %s" % (foundname, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, preferred, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    elif os.path.isdir(source):
        # FIXME
        print >>sys.stderr, "reposurgeon: directory writes are not yet supported."
    elif os.path.exists(source):
        print >>sys.stderr, "reposurgeon: file %s already exists" % source
    else:
        repo.fast_export(open(source, "w"))

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes))
    def do_prefer(self):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(map(lambda x: x[0], vcstypes))
            if line.lower() in map(lambda x: x.lower(), known):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.verbose:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Write out the results of repo surgery."
        # FIXME: Default to . if we read from a directory
        if not line:
            line = '-'
        write_repo(self.repo, line, self.preferred, self.verbose)
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :79
original-oid 73316ba9ff37f2315c5bf0e0bfeccbbbd7f06be3
data 6606
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose' option.</para>

<para>Here are the available commands:</para>

<variablelist>
<varlistentry>
<term>help</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term>version</term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term>verbose</term>
<listitem><para>'verbose 1' enables progress and statistics messages,
'verbose 0' disables them. 
</para></listitem>
</varlistentry>
<varlistentry>
<term>shell</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term>prefer</term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>read</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/lightweight-sample
mark :80
original-oid c5055e6e510fbc59f690a02cb1ddba84e55cae59
author Eric S. Raymond <esr@thyrsus.com> 1288100146 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288100146 -0400
data 22
Implemented 'prefer'.
from :77
M 100644 :79 reposurgeon.xml
M 100755 :78 reposurgeon

blob
mark :81
original-oid 5a3d841237fd5c5a70aa213553d7d08937a45fd8
data 18498
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
    "bzr" : (".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    }

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        if verbose:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % source
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % source
            return None
        elif verbose:
            print "reposurgeon: recognized %s repository under %s" % (foundname, source)
        try:
            repo = Repository()
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
        (repo.type, repo.initializer, repo.importer, repo.checkout) = (name,
                                                                       initializer,
                                                                       importer,
                                                                       checkout)
    return repo

def write_repo(repo, target, preferred, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    elif os.path.isdir(source):
        # FIXME
        print >>sys.stderr, "reposurgeon: directory writes are not yet supported."
    elif os.path.exists(source):
        print >>sys.stderr, "reposurgeon: file %s already exists" % source
    else:
        repo.fast_export(open(source, "w"))

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.verbose:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Write out the results of repo surgery."
        # FIXME: Default to . if we read from a directory
        if not line:
            line = '-'
        write_repo(self.repo, line, self.preferred, self.verbose)
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/lightweight-sample
mark :82
original-oid 659f4129ed381c003b4e091a06c4c10c85fe09a7
author Eric S. Raymond <esr@thyrsus.com> 1288101062 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288101062 -0400
data 38
Fix buggy implementation of "prefer".
from :80
M 100755 :81 reposurgeon

blob
mark :83
original-oid f214e0645c75bae58b1efdff71ed3a3f46fcfd00
data 18416
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
    "bzr" : (".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    }

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        if verbose:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % source
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % source
            return None
        elif verbose:
            print "reposurgeon: recognized %s repository under %s" % (foundname, source)
        try:
            repo = Repository()
            repo.type = foundname 
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def write_repo(repo, target, preferred, verbose):
    "Write a repository using fast-export."
    if target == '-':
        repo.fast_export(sys.stdout)
    elif os.path.isdir(source):
        # FIXME
        print >>sys.stderr, "reposurgeon: directory writes are not yet supported."
    elif os.path.exists(source):
        print >>sys.stderr, "reposurgeon: file %s already exists" % source
    else:
        repo.fast_export(open(source, "w"))

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        if not line:
            line = '.';
        if self.repo and self.verbose:
            print "reposurgeon: previously data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
        if self.repo and self.verbose:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Write out the results of repo surgery."
        if not line:
            if self.preferred:
                line = "."
            else:
                line = '-'
        write_repo(self.repo, line, self.preferred, self.verbose)
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :84
original-oid 174520f3074c91c1e46d371b4723bb8fc71c330e
author Eric S. Raymond <esr@thyrsus.com> 1288101602 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288101602 -0400
data 47
Set the write default type more intelligently.
from :82
M 100755 :83 reposurgeon

blob
mark :85
original-oid 7e8a5babed905ec4f269420052a6f1dcf2128c0a
data 21562
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
    "bzr" : (".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    }

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, verbose=False):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
                if verbose:
                    print line.rstrip()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))

            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
    def fast_export(self, fp):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            fp.write(str(command))

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin)
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source))
    else:
        if verbose:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % source
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % source
            return None
        elif verbose:
            print "reposurgeon: recognized %s repository under %s" % (foundname, source)
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp);
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp)
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed"
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % savedir
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
        if self.repo and self.verbose:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :86
original-oid 461044538adff8aae7bfa45e0678c395cfba245d
data 7339
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose' option.</para>

<para>Here are the available commands:</para>

<variablelist>
<varlistentry>
<term>help</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term>version</term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term>verbose</term>
<listitem><para>'verbose 1' enables progress and statistics messages,
'verbose 0' disables them. 
</para></listitem>
</varlistentry>
<varlistentry>
<term>shell</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term>prefer</term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>read</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term>write</term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term>rebuild</term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/annotated-sample
mark :87
original-oid bc52c5a097000da16724d18ac80e705e3b183eb3
author Eric S. Raymond <esr@thyrsus.com> 1288112612 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288112612 -0400
data 46
Try to get the write and rebuild logic right.
from :84
M 100644 :86 reposurgeon.xml
M 100755 :85 reposurgeon

blob
mark :88
original-oid bb6eb14f91f032f1aab816c6ecc8f2342cd780bc
data 23221
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
    "bzr" : (".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: importing from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: importing from %s" % source))
    else:
        if verbose:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % source
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % source
            return None
        elif verbose:
            print "reposurgeon: recognized %s repository under %s" % (foundname, source)
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: importing from repo"));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed"
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % savedir
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
        else:
            print "reposurgeon: no repository loaded."
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :89
original-oid ffc6f86cf2e7abbf313d98d79ca67e340d710594
author Eric S. Raymond <esr@thyrsus.com> 1288113962 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288113962 -0400
data 36
Add twirling-batob progress meters.
from :87
M 100755 :88 reposurgeon

blob
mark :90
original-oid 918856d60a56e20d079c298a5fb28a57790834c4
data 23623
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
    "bzr" : (".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :91
original-oid ad608c4b53de90456f67505be3433d5a7b7f3e4f
data 7581
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose 1' option.</para>

<para>Here are the available commands:</para>

<variablelist>
<varlistentry>
<term>help</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term>version</term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term>verbose</term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term>shell</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term>prefer</term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>read</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term>stats</term>
<listitem><para>
Report size statistics and import/export method information after reading
a repo or stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term>write</term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term>rebuild</term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/annotated-sample
mark :92
original-oid be4302df54c46d8034058475a88791aa7a728b39
author Eric S. Raymond <esr@thyrsus.com> 1288115880 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288115880 -0400
data 35
Cut verbosity, improve statistics.
from :89
M 100644 :91 reposurgeon.xml
M 100755 :90 reposurgeon

blob
mark :93
original-oid 61ea5247d1245af0fd8f2f05fcc2f46b2c957ec4
data 24447
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :94
original-oid 7ba90a09ddce5f084c672bb7bc574ff4058d1b38
data 7922
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose 1' option.</para>

<para>Here are the available commands:</para>

<variablelist>
<varlistentry>
<term>help</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term>version</term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term>verbose</term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term>shell</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term>prefer</term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>read</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term>stats</term>
<listitem><para>
Report size statistics and import/export method information after reading
a repo or stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term>write</term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term>rebuild</term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
<varlistentry>
<term>view</term>
<listitem><para>
View a repo through the default GUI browser for its version control
system.  Note that this does not show the edited state held by
<application>reposurgeon</application> in core; it is mainly useful
for doing a quick eyeball check ofter a rebuild command.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/annotated-sample
mark :95
original-oid 580b5f19fb6dec58a8bad6f9966c05ccd85166ac
author Eric S. Raymond <esr@thyrsus.com> 1288117441 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288117441 -0400
data 26
Added the 'view' command.
from :92
M 100644 :94 reposurgeon.xml
M 100755 :93 reposurgeon

blob
mark :96
original-oid abc4871f9f70832bd3b1852042775af8cf7d4dda
data 26358
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :97
original-oid 3a5596834823fe95b42c858b725c397590758b76
data 10897
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> command line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose 1' option.</para>

<para>Here are the available and planned surgical commands:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>delete</command></cmdsynopsis></term>
<listitem>
<para>Delete a span of commits.  Requires a commit-range argument.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>expunge</command></cmdsynopsis></term>
<listitem>
<para>Expunge a file from the repo history.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>coalesce</command></cmdsynopsis></term>
<listitem>
<para>Scan the history for runs of commits with identical comments close to
each other in time (this is a common form of scar tissues in
repository up-conversions from older file-oriented version-control systems).
Merge these cliques.</para>

<para>The required first argument is a commit range to operate on.  The optional
second argument, if present, is a maximum time separation in seconds;
the default is 90 seconds.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>edit</command></cmdsynopsis></term>
<listitem>
<para>Edit a blob or commit or tag, identified by date or mark or tag
name.</para>
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
</variablelist>

<para>A commit range is either a single commit identifier or a pair
of them separated by "..".  A commit identifier is a mark number
(preceded by ':'). There are some commands that help you find interesting
mark numbers:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>index</command> <arg choice="opt">+b</arg></cmdsynopsis></term>
<listitem>
<para>Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob.</para>

<para>Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
<option>+b</option> option enables display of blobs.</para>
</listitem>
</varlistentry>
</variablelist>

<para>These are backed up by the following housekeeping commands:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>help</command></cmdsynopsis></term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>version</command></cmdsynopsis></term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>verbose</command></cmdsynopsis></term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>shell</command></cmdsynopsis></term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>prefer</command></cmdsynopsis></term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>read</command></cmdsynopsis></term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>stats</command></cmdsynopsis></term>
<listitem><para>
Report size statistics and import/export method information after reading
a repo or stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>write</command></cmdsynopsis></term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>rebuild</command></cmdsynopsis></term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>view</command></cmdsynopsis></term>
<listitem><para>
View a repo through the default GUI browser for its version control
system.  Note that this does not show the edited state held by
<application>reposurgeon</application> in core; it is mainly useful
for doing a quick eyeball check ofter a rebuild command.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/annotated-sample
mark :98
original-oid 7fdd057574eb801d69f0bc56216690df6a06412f
author Eric S. Raymond <esr@thyrsus.com> 1288160374 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288160374 -0400
data 53
Implement and document 'index'; document some plans.
from :95
M 100644 :97 reposurgeon.xml
M 100755 :96 reposurgeon

blob
mark :99
original-oid 0b1fb9bf6594850d8fe6d39cee27585c90e56a41
data 32121
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        # First, parse a visibility spec
        Unknown = type("")
        visible = set([Commit, Tag, Branch, Unknown])
        modmode = None
        while line and line[0] in "+-=Bctbx":
            if line[0] == "+":
                modmode = '+'
                line = line[1:]
            elif line[0] == '-':
                modmode = '-'
                line = line[1:]
            elif line[0] == '=':
                modmode = '+'
                visible = set([])
                line = line[1:]
            elif line[0] == 'B':
                if modmode == '+':
                    visible.add(Blob)
                elif modmode == '-' and Blob in visible:
                    visible.remove(Blob)
                line = line[1:]
            elif line[0] == 'c':
                if modmode == '+':
                    visible.add(Commit)
                elif modmode == '-' and Commit in visible:
                    visible.remove(Commit)
                line = line[1:]
            elif line[0] == 't':
                if modmode == '+':
                    visible.add(Tag)
                elif modmode == '-' and Tag in visible:
                    visible.remove(Tag)
                line = line[1:]
            elif line[0] == 'b':
                if modmode == '+':
                    visible.add(Branch)
                elif modmode == '-' and Branch in visible:
                    visible.remove(Branch)
                line = line[1:]
            elif line[0] == 'u':
                if modmode == '+':
                    visible.add(Unknown)
                elif modmode == '-' and Unknown in visible:
                    visible.remove(Unknown)
                line = line[1:]
            elif line[0].isspace():
                # Leave the space in place to signal that parsing is over
                break
            elif line[0] == '&':
                line = line[1:]
                break
            elif modmode:
                print >>sys.stderr,"reposurgeon: illegal char in visibity spec."
                while line and line[0].isspace():
                    line = line[1:]
        # Now compute a span
        span = []
        seenspanner = False
        while line and not line[0].isspace() and not len(span) == 2:
            # First, literal command numbers (1-origin)
            match = re.match("[0-9]+", line)
            if match:
                number = match.group()
                span.append(int(number)-1)
                line = line[len(number):]
                continue
            # Next, mark references
            match = re.match(":[0-9]+", line)
            if match:
                markref = match.group()
                line = line[len(markref):]
                for (i, cmd) in enumerate(self.repo.commands):
                    if type(cmd) == Unknown:
                        continue
                    elif cmd.hasattr("mark") and cmd.mark == markref:
                        span.append(i)
                        break
                else:
                    print >>sys.stderr,"reposurgeon: mark %s not found." % markref
                    while line and line[0].isspace():
                        line = line[1:]
                    return line
                continue
            # $ means last commit, a la ed(1).
            if line.startswith("$"):
                span.append(len(self.repo.commands)-1)
                line = line[1:]
                continue
            # Either "," or ".." is acceptable as span punctuation
            if line.startswith("..") or line.startswith(","): 
                if not span:
                    print >>sys.stderr,"reposurgeon: start of span is missing."
                    while line and line[0].isspace():
                        line = line[1:]
                    return line
                seenspanner = True
                if line.startswith(".."):
                    line = line[2:]
                if line.startswith(","):
                    line = line[1:]
                continue
            # Anything else is an error
            print >>sys.stderr,"reposurgeon: can't parse span specification."
            while line and line[0].isspace():
                line = line[1:]
                return line
            break
        # Done parsing the span.  Barf on trailing garbage
        if line and not line[0].isspace():
            print >>sys.stderr,"reposurgeon: trailing garbage on span specification."
            while line and line[0].isspace():
                line = line[1:]
                return line
        # Sanity checks
        if seenspanner and len(span) < 2:
            print >>sys.stderr,"reposurgeon: incomplete span."
            while line and line[0].isspace():
                line = line[1:]
                return line
        if len(span) == 0:
            span = [0, len(self.repo.objects)-1]
        elif len(span) == 1:
            span.append(span[0])
        (spanstart, spanend) = span 
        if spanstart < 0 or spanend > len(self.repo.objects)-1:
            print >>sys.stderr,"reposurgeon: span start or end out of range."
            return line
        # Now compose the actual selection
        self.selection = []
        for i in range(spanstart, spanend+1):
            cmd = self.repo.commands[i]
            if type(cmd) == Unkown and Unknown in visibility:
                self.selection.append(i)
            elif cmd.__class__ in visibility:
                self.selection.append(i)
        # We're done, return the unconsumed portion of the line
        return line
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :100
original-oid 8aea6566d0341f46a17693742ea47be39a546188
author Eric S. Raymond <esr@thyrsus.com> 1288173615 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288173615 -0400
data 37
First try at an expression language.
from :98
M 100755 :99 reposurgeon

blob
mark :101
original-oid 4cdb77116361aaa18f28aaefc05eb16cbba84a26
data 31908
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        if self.verbose >= 2:
            print "reposurgeon: precmd() sees %s" % `line`
        # First, parse a visibility spec
        Unknown = type("")
        visible = set([Commit, Tag, Branch, Unknown])
        modmode = None
        while line and line[0] in "+-=Bctbx&":
            if line[0] == "+":
                modmode = '+'
                line = line[1:]
            elif line[0] == '-':
                modmode = '-'
                line = line[1:]
            elif line[0] == '=':
                modmode = '+'
                visible = set([])
                line = line[1:]
            elif line[0] == 'B':
                if modmode == '+':
                    visible.add(Blob)
                elif modmode == '-' and Blob in visible:
                    visible.remove(Blob)
                line = line[1:]
            elif line[0] == 'c':
                if modmode == '+':
                    visible.add(Commit)
                elif modmode == '-' and Commit in visible:
                    visible.remove(Commit)
                line = line[1:]
            elif line[0] == 't':
                if modmode == '+':
                    visible.add(Tag)
                elif modmode == '-' and Tag in visible:
                    visible.remove(Tag)
                line = line[1:]
            elif line[0] == 'b':
                if modmode == '+':
                    visible.add(Branch)
                elif modmode == '-' and Branch in visible:
                    visible.remove(Branch)
                line = line[1:]
            elif line[0] == 'u':
                if modmode == '+':
                    visible.add(Unknown)
                elif modmode == '-' and Unknown in visible:
                    visible.remove(Unknown)
                line = line[1:]
            elif line[0].isspace() or line[0] == '&':
                line = line[1:]
                break
            elif modmode:
                print >>sys.stderr,"reposurgeon: illegal char in visibility spec."
        if self.verbose >= 2:
            print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `line`)
        # Now compute a selection
        selection = []
        seenspanner = False
        while line and not line[0].isspace() and not line[0].isalpha():
            seenspanner = False 
            # First, literal command numbers (1-origin)
            match = re.match("[0-9]+", line)
            if match:
                number = match.group()
                selection.append(int(number)-1)
                line = line[len(number):]
                continue
            # Next, mark references
            match = re.match(":[0-9]+", line)
            if match:
                markref = match.group()
                line = line[len(markref):]
                for (i, cmd) in enumerate(self.repo.commands):
                    if type(cmd) == Unknown:
                        continue
                    elif hasattr(cmd, "mark") and cmd.mark == markref:
                        selection.append(i)
                        break
                    elif hasattr(cmd, "committish") and cmd.committish == markref:
                        selection.append(i)
                        break
                else:
                    print >>sys.stderr,"reposurgeon: mark %s not found." % markref
                    while line and line[0].isspace():
                        line = line[1:]
                    return line
                continue
            # $ means last commit, a la ed(1).
            if line.startswith("$"):
                selection.append(len(self.repo.commands)-1)
                line = line[1:]
                continue
            # Comma just delimits a location spec
            if line.startswith(","):
                continue
            # Following ".." means a span
            if line.startswith(".."):
                seenspanner = True
                if selection:
                    line = line[2:]
                    continue
                else:
                    print >>sys.stderr,"reposurgeon: start of span is missing."
                    return line
            # Anything else is an error
            print >>sys.stderr,"reposurgeon: can't parse selection at %s." % `line`
            return line
        # Sanity checks
        if seenspanner:
            print >>sys.stderr,"reposurgeon: incomplete selection."
            return line
        if len(selection) == 0:
            selection = [0, len(self.repo.commands)-1]
        for number in selection:
            if number < 0 or number > len(self.repo.commands)-1:
                print >>sys.stderr,"reposurgeon: command number out of range."
                return line
        # Now compose the actual selection
        self.selection = []
        for i in selection:
            cmd = self.repo.commands[i]
            if type(cmd) == Unknown and Unknown in visible:
                self.selection.append(i)
            elif cmd.__class__ in visible:
                self.selection.append(i)
        # We're done, return the unconsumed portion of the line
        return line
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 2
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :102
original-oid 62851009560bfc36de209ab408cf871a71af4e81
author Eric S. Raymond <esr@thyrsus.com> 1288179718 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288179718 -0400
data 67
Numbers, mark lookup, and $ are working.  Span punctuation is not.
from :100
M 100755 :101 reposurgeon

blob
mark :103
original-oid a3cde6ece63603c42838a723a800428ce41b8da0
data 32448
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        # First, parse a visibility spec
        Unknown = type("")
        visible = set([Commit, Tag, Branch, Unknown])
        modmode = None
        while line and line[0] in "+-=Bctbx&":
            if line[0] == "+":
                modmode = '+'
                line = line[1:]
            elif line[0] == '-':
                modmode = '-'
                line = line[1:]
            elif line[0] == '=':
                modmode = '+'
                visible = set([])
                line = line[1:]
            elif line[0] == 'B':
                if modmode == '+':
                    visible.add(Blob)
                elif modmode == '-' and Blob in visible:
                    visible.remove(Blob)
                line = line[1:]
            elif line[0] == 'c':
                if modmode == '+':
                    visible.add(Commit)
                elif modmode == '-' and Commit in visible:
                    visible.remove(Commit)
                line = line[1:]
            elif line[0] == 't':
                if modmode == '+':
                    visible.add(Tag)
                elif modmode == '-' and Tag in visible:
                    visible.remove(Tag)
                line = line[1:]
            elif line[0] == 'b':
                if modmode == '+':
                    visible.add(Branch)
                elif modmode == '-' and Branch in visible:
                    visible.remove(Branch)
                line = line[1:]
            elif line[0] == 'u':
                if modmode == '+':
                    visible.add(Unknown)
                elif modmode == '-' and Unknown in visible:
                    visible.remove(Unknown)
                line = line[1:]
            elif line[0].isspace() or line[0] == '&':
                line = line[1:]
                break
            elif modmode:
                print >>sys.stderr,"reposurgeon: illegal char in visibility spec."
        if self.verbose >= 2:
            print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `line`)
        # Now compute a selection
        selection = []
        while line and not line[0].isspace() and not line[0].isalpha():
            # First, literal command numbers (1-origin)
            match = re.match("[0-9]+", line)
            if match:
                number = match.group()
                selection.append(int(number)-1)
                line = line[len(number):]
                continue
            # Next, mark references
            match = re.match(":[0-9]+", line)
            if match:
                markref = match.group()
                line = line[len(markref):]
                for (i, cmd) in enumerate(self.repo.commands):
                    if type(cmd) == Unknown:
                        continue
                    elif hasattr(cmd, "mark") and cmd.mark == markref:
                        selection.append(i)
                        break
                    elif hasattr(cmd, "committish") and cmd.committish == markref:
                        selection.append(i)
                        break
                else:
                    print >>sys.stderr,"reposurgeon: mark %s not found." % markref
                    while line and line[0].isspace():
                        line = line[1:]
                    return line
                continue
            # $ means last commit, a la ed(1).
            if line.startswith("$"):
                selection.append(len(self.repo.commands)-1)
                line = line[1:]
                continue
            # Comma just delimits a location spec
            if line.startswith(","):
                continue
            # Following ".." means a span
            if line.startswith(".."):
                if selection:
                    selection.append("..")
                    line = line[2:]
                    continue
                else:
                    print >>sys.stderr,"reposurgeon: start of span is missing."
                    return line
            # Anything else is an error
            print >>sys.stderr,"reposurgeon: can't parse selection at %s." % `line`
            return line
        if self.verbose >= 2:
            print "reposurgeon: location list is %s with %s left" % (selection, `line`)
        # Resolve spans
        resolved = []
        spanning = last = 0
        for elt in selection:
            if elt == '..':
                spanning = True
            else:
                if spanning:
                    resolved += range(last+1, elt+1)
                    spanning = False
                else:
                    resolved.append(elt)
                last = elt
        selection = resolved
        if self.verbose >= 2:
            print "reposurgeon: resolved list is %s with %s left" % (selection, `line`)
        # Sanity checks
        if len(selection) == 0:
            selection = [0, len(self.repo.commands)-1]
        elif selection and selection[-1] == '..':
            print >>sys.stderr,"reposurgeon: incomplete selection."
            return line
        for elt in selection:
            if elt < 0 or elt > len(self.repo.commands)-1:
                print >>sys.stderr,"reposurgeon: command number %s out of range." % elt
                return line
        # Now compose the actual selection
        self.selection = []
        for i in selection:
            cmd = self.repo.commands[i]
            if type(cmd) == Unknown and Unknown in visible:
                self.selection.append(i)
            elif cmd.__class__ in visible:
                self.selection.append(i)
        # We're done, return the unconsumed portion of the line
        return line
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :104
original-oid b1ae2ce5ef8f43ae0e4cad697ddb6fcb2a9f1926
author Eric S. Raymond <esr@thyrsus.com> 1288181252 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288181252 -0400
data 28
Span resolution is working.
from :102
M 100755 :103 reposurgeon

blob
mark :105
original-oid 46c08814de4435ebcc4a12f34d8668b4d3e44d43
data 35910
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = [0, len(self.repo.commands)-1]
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if not self.peek() == '|':
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if not self.peek() == '&':
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in "+-=":
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Branch, Unknown])
            modmode = None
            while self.peek() in "+-=Bctbu":
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'c':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 't':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'b':
                    if modmode == '+':
                        visible.add(Branch)
                    elif modmode == '-' and Branch in visible:
                        visible.remove(Branch)
                elif c == 'u':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ":0123456789$":
            polyrange = None
        else:
            selection = []
            while self.peek() in ":0123456789.,$":
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 2
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :106
original-oid 463a0a23f4e477f0c47fa6e8774fe369c4079f3a
author Eric S. Raymond <esr@thyrsus.com> 1288193458 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288193458 -0400
data 40
New recursive evaluator almost working.
from :104
M 100755 :105 reposurgeon

blob
mark :107
original-oid 32b7e18bfbd4c9905adeaf9338d5f4281f6772fb
data 35992
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = [0, len(self.repo.commands)-1]
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in "+-=":
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Branch, Unknown])
            modmode = None
            while self.peek() in "+-=Bctbu":
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'c':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 't':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'b':
                    if modmode == '+':
                        visible.add(Branch)
                    elif modmode == '-' and Branch in visible:
                        visible.remove(Branch)
                elif c == 'u':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ":0123456789$":
            polyrange = None
        else:
            selection = []
            while self.peek() in ":0123456789.,$":
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 2
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :108
original-oid 23a765e77e5b458b330be93c617a358f948cfb44
author Eric S. Raymond <esr@thyrsus.com> 1288194165 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288194165 -0400
data 49
OK, thismakes the binary logical operators work.
from :106
M 100755 :107 reposurgeon

blob
mark :109
original-oid cb54c15b8f2aa4ba7e995e4c0a1ef3030ea5ab79
data 36130
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = [0, len(self.repo.commands)-1]
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Branch, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'c':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 't':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'b':
                    if modmode == '+':
                        visible.add(Branch)
                    elif modmode == '-' and Branch in visible:
                        visible.remove(Branch)
                elif c == 'u':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d branches, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Branch),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Branch):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 2
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/tags/annotated-sample
mark :110
original-oid 6ecf0fedec5eed1186629341788a2178a395de9d
author Eric S. Raymond <esr@thyrsus.com> 1288194826 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288194826 -0400
data 29
No hang on commandless line.
from :108
M 100755 :109 reposurgeon

blob
mark :111
original-oid 0093c362ea6424410688e6cd039db019fa2f6b87
data 36088
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % os.path.relpath(source)
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed."
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % os.path.relpath(savedir)
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = [0, len(self.repo.commands)-1]
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            print >>sys.stderr,"reposurgeon: prefer a repo type first."
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            print >>sys.stderr,"reposurgeon: no GUI is available."
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Search for comments containing a specified string."
        if not self.repo:
            print >>sys.stderr,"reposurgeon: no repo is loaded."
            return
        line = line.lstrip()
        if line.startswith("+b"):
            seeblobs = True
            line = line[3:]
        else:
            seeblobs = False
        for (i, command) in enumerate(self.repo.commands):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 2
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :112
original-oid d4ab5c924a77a69290a09904adf5c1815428bd74
data 15009
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> invocation line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose 1' option.</para>

<para>A git-fast-import stream consists of a sequence of commands
which must be executed in the specified sequence to build the repo;
to avoiid confusion with <application>reposurgeon</application> commands
we will refer to the stream commands here as <emphasis>events</emphasis>.
These events are implicitly numbered from 1 upwards.  Most commands
require specifying a selection of event sequence numbers so
<application>reposurgeon</application> will know which events to
modify or delete.</para>

<para>When a command takes a selection-set argument, it will
<emphasis>precede</emphasis> the command keyword; other arguments will
follow. It is often possible to omit the selection-set argument and
have it default to something reasonable, usuaally the entire event 
sequence.</para>

<para>Here are some motivating examples.  The commands will be
explained in more detail after the description of selection
syntax.</para>

<programlisting>
:15 edit                     ;; edit the object associated with mark :15

29..71 index                 ;; list summary index of events 20..71

=t &amp; 1..:97 delete            ;; delete tags from event 1 to mark 15
</programlisting>

<para>The selection-set specification syntax is an expression-oriented 
minilanguage.  The most basic term in this language is a 
<firstterm>location</firstterm>. The following sorts of primitive locations
are supported:</para>

<variablelist>
<varlistentry>
<term><firstterm>event numbers</firstterm></term>
<listitem><para>A plain numeric literal is interpreted as a 1-origin
event-sequence number.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>marks</firstterm></term>
<listitem><para>A numeric literal preceded by a colon is interpreted
as a mark; see the format documentation for explanation of the 
semantics of marks.</para></listitem>
</varlistentry>
</variablelist>

<para>These may be grouped into sets in the following ways:</para>

<variablelist>
<varlistentry>
<term><firstterm>ranges</firstterm></term>
<listitem><para>A range is two locations separated by "..", and is
the set of events begining at the left-hand location and ending at the
right-hand location (inclusive).</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>lists</firstterm></term>
<listitem><para>Comma-separated lists of locations and ranges are 
accepted, with the obvious meaning.</para></listitem>
</varlistentry>
</variablelist>

<para>There are some other ways to construct event sets:</para>

<variablelist>
<varlistentry>
<term><firstterm>visibility sets</firstterm></term>
<listitem>
<para>A visibility set is an expression specifying a set of event
types. It will consist of a leading plus, minus, or equal sign,
followed by type letters. These are the type letters:</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='7' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <colspec colname='c3'/>
    <tbody>
      <row>
        <entry align='center'>B</entry>
        <entry align='center'>blobs</entry>
	<entry><para>Most default selection sets exclude blobs; they
	have to be manipulated through the commits they are attached
	to.</para></entry>
      </row>
      <row>
        <entry align='center'>C</entry>
        <entry align='center'>commits</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>T</entry>
        <entry align='center'>tags</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>R</entry>
        <entry align='center'>resets</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>U</entry>
        <entry align='center'>Unknown</entry>
	<entry><para>All event types types simply passed through,
	including comments, <command>progress</command> commands, 
        and <command>checkpoint</command> commands.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>The = prefix specifies exactly the set of types following; the +
prefix adds to the default set for the command; and the - prefix
subtracts from that set.</para>

</listitem>
</varlistentry>
</variablelist>

<para>Set expressions bay be combined with the operators | and &amp;;
these are, respectively, set uniomn and intersection.</para>

<para>Here are the available and planned surgical commands:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>index</command> <arg choice="opt">+b</arg></cmdsynopsis></term>
<listitem>
<para>Display four columns of info on objects in the selection set:
their number, their type, the associate mark (or '-' if no mark) and a
summary field varying by type.  For a branch or tag it's the
reference; for a commit it's the commit branch; for a blob it's the
repository path of the file in the blob.</para>

<para>The default selection set for this command is =ctbu, all objects
except blobs.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>delete</command></cmdsynopsis></term>
<listitem>
<para>Delete a selection set of commits.  The default selection set
for this command is empty.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>expunge</command></cmdsynopsis></term>
<listitem>
<para>Expunge a file from the repo history. Does not take a selection
set.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>coalesce</command></cmdsynopsis></term>
<listitem>
<para>Scan the selection set for runs of commits with identical
comments close to each other in time (this is a common form of scar
tissues in repository up-conversions from older file-oriented
version-control systems).  Merge these cliques.</para>

<para>The required first argument is a selection set to operate on.
The optional second argument, if present, is a maximum time separation
in seconds; the default is 90 seconds.</para>

<para>The default selection set for this command is =c, all commits.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>edit</command></cmdsynopsis></term>
<listitem>
<para>Edit a selection set of commands.</para>
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
</variablelist>

<para>These are backed up by the following housekeeping commands, none of 
which take a selection set:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>help</command></cmdsynopsis></term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>version</command></cmdsynopsis></term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>verbose</command></cmdsynopsis></term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>shell</command></cmdsynopsis></term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>prefer</command></cmdsynopsis></term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>read</command></cmdsynopsis></term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>stats</command></cmdsynopsis></term>
<listitem><para>
Report size statistics and import/export method information after reading
a repo or stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>write</command></cmdsynopsis></term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>rebuild</command></cmdsynopsis></term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>view</command></cmdsynopsis></term>
<listitem><para>
View a repo through the default GUI browser for its version control
system.  Note that this does not show the edited state held by
<application>reposurgeon</application> in core; it is mainly useful
for doing a quick eyeball check ofter a rebuild command.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/tags/annotated-sample
mark :113
original-oid 8f3ff752e691e9be4cd512449d3526cf8237ef98
author Eric S. Raymond <esr@thyrsus.com> 1288199857 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288199857 -0400
data 41
Document the new selection-set language.
from :110
M 100644 :112 reposurgeon.xml
M 100755 :111 reposurgeon

blob
mark :114
original-oid 98f67d2d9a2f25d947c06caff5f0ff8246544d09
data 15054
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> invocation line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose 1' option.</para>

<para>A git-fast-import stream consists of a sequence of commands
which must be executed in the specified sequence to build the repo;
to avoiid confusion with <application>reposurgeon</application> commands
we will refer to the stream commands here as <emphasis>events</emphasis>.
These events are implicitly numbered from 1 upwards.  Most commands
require specifying a selection of event sequence numbers so
<application>reposurgeon</application> will know which events to
modify or delete.</para>

<para>When a command takes a selection-set argument, it will
<emphasis>precede</emphasis> the command keyword; other arguments will
follow. It is often possible to omit the selection-set argument and
have it default to something reasonable, usuaally the entire event 
sequence.</para>

<para>Here are some motivating examples.  The commands will be
explained in more detail after the description of selection
syntax.</para>

<programlisting>
:15 edit                     ;; edit the object associated with mark :15

29..71 index                 ;; list summary index of events 20..71

=t &amp; 1..:97 delete            ;; delete tags from event 1 to mark 15
</programlisting>

<para>The selection-set specification syntax is an expression-oriented 
minilanguage.  The most basic term in this language is a 
<firstterm>location</firstterm>. The following sorts of primitive locations
are supported:</para>

<variablelist>
<varlistentry>
<term><firstterm>event numbers</firstterm></term>
<listitem><para>A plain numeric literal is interpreted as a 1-origin
event-sequence number.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>marks</firstterm></term>
<listitem><para>A numeric literal preceded by a colon is interpreted
as a mark; see the format documentation for explanation of the 
semantics of marks.</para></listitem>
</varlistentry>
</variablelist>

<para>These may be grouped into sets in the following ways:</para>

<variablelist>
<varlistentry>
<term><firstterm>ranges</firstterm></term>
<listitem><para>A range is two locations separated by "..", and is
the set of events begining at the left-hand location and ending at the
right-hand location (inclusive).</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>lists</firstterm></term>
<listitem><para>Comma-separated lists of locations and ranges are 
accepted, with the obvious meaning.</para></listitem>
</varlistentry>
</variablelist>

<para>There are some other ways to construct event sets:</para>

<variablelist>
<varlistentry>
<term><firstterm>visibility sets</firstterm></term>
<listitem>
<para>A visibility set is an expression specifying a set of event
types. It will consist of a leading plus, minus, or equal sign,
followed by type letters. These are the type letters:</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='3' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <colspec colname='c3'/>
    <tbody>
      <row>
        <entry align='center'>B</entry>
        <entry align='center'>blobs</entry>
	<entry><para>Most default selection sets exclude blobs; they
	have to be manipulated through the commits they are attached
	to.</para></entry>
      </row>
      <row>
        <entry align='center'>C</entry>
        <entry align='center'>commits</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>T</entry>
        <entry align='center'>tags</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>R</entry>
        <entry align='center'>resets</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>U</entry>
        <entry align='center'>Unknown</entry>
	<entry><para>All event types types simply passed through,
	including comments, <command>progress</command> commands, 
        and <command>checkpoint</command> commands.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>The = prefix specifies exactly the set of types following; the +
prefix adds to the default set for the command; and the - prefix
subtracts from that set.</para>

</listitem>
</varlistentry>
</variablelist>

<para>Set expressions bay be combined with the operators | and &amp;;
these are, respectively, set uniomn and intersection.</para>

<para>Here are the available and planned surgical commands:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>index</command></cmdsynopsis></term>
<listitem>
<para>Display four columns of info on objects in the selection set:
their number, their type, the associate mark (or '-' if no mark) and a
summary field varying by type.  For a branch or tag it's the
reference; for a commit it's the commit branch; for a blob it's the
repository path of the file in the blob.</para>

<para>The default selection set for this command is =CTRU, all objects
except blobs.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>delete</command></cmdsynopsis></term>
<listitem>
<para>Delete a selection set of commits.  The default selection set
for this command is empty.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>expunge</command></cmdsynopsis></term>
<listitem>
<para>Expunge a file from the repo history. Does not take a selection
set.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>coalesce</command></cmdsynopsis></term>
<listitem>
<para>Scan the selection set for runs of commits with identical
comments close to each other in time (this is a common form of scar
tissues in repository up-conversions from older file-oriented
version-control systems).  Merge these cliques.</para>

<para>The optional second argument, if present, is a maximum time
separation in seconds; the default is 90 seconds.</para>

<para>The default selection set for this command is =C, all
commits. Occasionally you may want to restrict it, for example to
avoid coalescing unrelated "*** empty log message ***" commits from
CVS lifts.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>edit</command></cmdsynopsis></term>
<listitem>
<para>Edit a selection set of events.</para>
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
</variablelist>

<para>These are backed up by the following housekeeping commands, none of 
which take a selection set:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>help</command></cmdsynopsis></term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>version</command></cmdsynopsis></term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>verbose</command></cmdsynopsis></term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>shell</command></cmdsynopsis></term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>prefer</command></cmdsynopsis></term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>read</command></cmdsynopsis></term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>stats</command></cmdsynopsis></term>
<listitem><para>
Report size statistics and import/export method information after reading
a repo or stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>write</command></cmdsynopsis></term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>rebuild</command></cmdsynopsis></term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>view</command></cmdsynopsis></term>
<listitem><para>
View a repo through the default GUI browser for its version control
system.  Note that this does not show the edited state held by
<application>reposurgeon</application> in core; it is mainly useful
for doing a quick eyeball check ofter a rebuild command.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/heads/master
mark :115
original-oid f5d79789cc581f147b96f67edcb8f1a2ae960fe1
author Eric S. Raymond <esr@thyrsus.com> 1288200336 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288200336 -0400
data 21
Documentation fixes.
from :113
M 100644 :114 reposurgeon.xml

blob
mark :116
original-oid 3b9199d49bba2fa0932703a6faaded74cd4a94d2
data 35714
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s") % os.path.relpath(source)
            return None
        elif hitcount > 1:
            complain("too many repos under %s") % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = None
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        elif self.selection is None:
            self.selection = range(len(self.repo.commands))
        for (i, command) in enumerate(self.selection):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :117
original-oid 4cc63d3da43c7d139a981d225f4987167a9a159d
author Eric S. Raymond <esr@thyrsus.com> 1288202060 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288202060 -0400
data 51
Minor refactoring step, and lower the debug level.
from :115
M 100755 :116 reposurgeon

blob
mark :118
original-oid 9433e7f9f498ea945534d0cdf54b5b9c5c13429b
data 35715
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s") % os.path.relpath(source)
            return None
        elif hitcount > 1:
            complain("too many repos under %s") % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = None
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdout)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        elif self.selection is None:
            self.selection = range(len(self.repo.commands))
        for (i, command) in enumerate(self.selection):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :119
original-oid 1b0e3f6e67b7023b94dc8e40e4f66deafbb53dcc
author Eric S. Raymond <esr@thyrsus.com> 1288202462 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288202462 -0400
data 67
Fix brown-paper-bag bug that broke the round-trip regression test.
from :117
M 100755 :118 reposurgeon

blob
mark :120
original-oid 90639cb38d25862355a98b82bd40bbfcbfb40aac
data 35992
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s") % os.path.relpath(source)
            return None
        elif hitcount > 1:
            complain("too many repos under %s") % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            # A FIFO version wouldn't block our reads until
            # the entire file is written - faster, and makes our baton
            # spinner useful -- if it worked.
            #tfname = os.path.join("/tmp/reposurgeon"+`os.getpid()`)
            #os.mkfifo(tfname)
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = None
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    print "I see dollar"
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdout)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        elif self.selection is None:
            self.selection = range(len(self.repo.commands))
        for (i, command) in enumerate(self.selection):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :121
original-oid b4f44ca2a857c26700593fb677f362d5ac69ba83
author Eric S. Raymond <esr@thyrsus.com> 1288203721 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288203721 -0400
data 27
Document a failed attempt.
from :119
M 100755 :120 reposurgeon

blob
mark :122
original-oid a3c9e029bd2dc3d070677f35e6a38188d09bada1
data 36097
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s") % os.path.relpath(source)
            return None
        elif hitcount > 1:
            complain("too many repos under %s") % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            # A FIFO version wouldn't block our reads until
            # the entire file is written - faster, and makes our baton
            # spinner useful -- if it worked.
            #tfname = os.path.join("/tmp/reposurgeon"+`os.getpid()`)
            #os.mkfifo(tfname)
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = None
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdout)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        elif self.selection is None:
            self.selection = range(len(self.repo.commands))
        for (i, command) in enumerate(self.selection):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        interpreter.use_rawinput = False
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.use_rawinput = True
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                    interpreter.use_rawinput = False
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :123
original-oid 96e0f248985a4a149972a54356dd4515c040000a
author Eric S. Raymond <esr@thyrsus.com> 1288204205 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288204205 -0400
data 37
Cut down on expensive input editing.
from :121
M 100755 :122 reposurgeon

blob
mark :124
original-oid 62c152768d4b153ec1bb108686e8475f128f2ead
data 36129
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s") % os.path.relpath(source)
            return None
        elif hitcount > 1:
            complain("too many repos under %s") % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            # A FIFO version wouldn't block our reads until
            # the entire file is written - faster, and makes our baton
            # spinner useful -- if it worked.
            #tfname = os.path.join("/tmp/reposurgeon"+`os.getpid()`)
            #os.mkfifo(tfname)
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def set_selection_set(self, line, default=None):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = default
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdout)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        self.set_selection_set(line, range(len(self.repo.commands)))
        for (i, command) in enumerate(self.selection):
            if isinstance(command, Blob):
                if seeblobs:
                    print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        set_selection_set(line)
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        interpreter.use_rawinput = False
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.use_rawinput = True
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                    interpreter.use_rawinput = False
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

blob
mark :125
original-oid 66cbabad27c1b88582271294f47d6603c9580223
data 15353
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Aug 24 1994</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <application>reposurgeon</application> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, and (d) removing files and subtrees
from repo history. The original motivation for
<application>reposurgeon</application> was to clean up artifacts
created by repository conversions.</para>

<para>To keep <application>reposurgeon</application> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an interactive
command interpreter or to execute commands given as arguments on the
<application>reposurgeon</application> invocation line. The only difference
between these modes is that the interactive one begins by turning on the
'verbose 1' option.</para>

<para>A git-fast-import stream consists of a sequence of commands
which must be executed in the specified sequence to build the repo;
to avoiid confusion with <application>reposurgeon</application> commands
we will refer to the stream commands here as <emphasis>events</emphasis>.
These events are implicitly numbered from 1 upwards.  Most commands
require specifying a selection of event sequence numbers so
<application>reposurgeon</application> will know which events to
modify or delete.</para>

<para>When a command takes a selection-set argument, it will
immediately follow the command keyword; other arguments will
follow. It is often possible to omit the selection-set argument and
have it default to something reasonable.</para>

<para>Here are some motivating examples.  The commands will be
explained in more detail after the description of selection
syntax.</para>

<programlisting>
edit :15                     ;; edit the object associated with mark :15

index 29..71                 ;; list summary index of events 20..71

delete =t &amp; 1..:97           ;; delete tags from event 1 to mark 15
</programlisting>

<para>The selection-set specification syntax is an expression-oriented 
minilanguage.  The most basic term in this language is a 
<firstterm>location</firstterm>. The following sorts of primitive locations
are supported:</para>

<variablelist>
<varlistentry>
<term><firstterm>event numbers</firstterm></term>
<listitem><para>A plain numeric literal is interpreted as a 1-origin
event-sequence number.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>marks</firstterm></term>
<listitem><para>A numeric literal preceded by a colon is interpreted
as a mark; see the format documentation for explanation of the 
semantics of marks.</para></listitem>
</varlistentry>
</variablelist>

<para>These may be grouped into sets in the following ways:</para>

<variablelist>
<varlistentry>
<term><firstterm>ranges</firstterm></term>
<listitem><para>A range is two locations separated by "..", and is
the set of events begining at the left-hand location and ending at the
right-hand location (inclusive).</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>lists</firstterm></term>
<listitem><para>Comma-separated lists of locations and ranges are 
accepted, with the obvious meaning.</para></listitem>
</varlistentry>
</variablelist>

<para>There are some other ways to construct event sets:</para>

<variablelist>
<varlistentry>
<term><firstterm>visibility sets</firstterm></term>
<listitem>
<para>A visibility set is an expression specifying a set of event
types. It will consist of a leading plus, minus, or equal sign,
followed by type letters. These are the type letters:</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='3' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <colspec colname='c3'/>
    <tbody>
      <row>
        <entry align='center'>B</entry>
        <entry align='center'>blobs</entry>
	<entry><para>Most default selection sets exclude blobs; they
	have to be manipulated through the commits they are attached
	to.</para></entry>
      </row>
      <row>
        <entry align='center'>C</entry>
        <entry align='center'>commits</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>T</entry>
        <entry align='center'>tags</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>R</entry>
        <entry align='center'>resets</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>U</entry>
        <entry align='center'>Unknown</entry>
	<entry><para>All event types types simply passed through,
	including comments, <command>progress</command> commands, 
        and <command>checkpoint</command> commands.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>The = prefix specifies exactly the set of types following; the +
prefix adds to the default set for the command; and the - prefix
subtracts from that set.</para>

</listitem>
</varlistentry>
</variablelist>

<para>Set expressions bay be combined with the operators | and &amp;;
these are, respectively, set uniomn and intersection.</para>

<para>Here are the available and planned surgical commands:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>index</command></cmdsynopsis></term>
<listitem>
<para>Display four columns of info on objects in the selection set:
their number, their type, the associate mark (or '-' if no mark) and a
summary field varying by type.  For a branch or tag it's the
reference; for a commit it's the commit branch; for a blob it's the
repository path of the file in the blob.</para>

<para>The default selection set for this command is =CTRU, all objects
except blobs.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>delete</command></cmdsynopsis></term>
<listitem>
<para>Delete a selection set of commits.  The default selection set
for this command is empty.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>expunge</command></cmdsynopsis></term>
<listitem>
<para>Expunge a file from the repo history. Does not take a selection
set.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>coalesce</command></cmdsynopsis></term>
<listitem>
<para>Scan the selection set for runs of commits with identical
comments close to each other in time (this is a common form of scar
tissues in repository up-conversions from older file-oriented
version-control systems).  Merge these cliques.</para>

<para>The optional second argument, if present, is a maximum time
separation in seconds; the default is 90 seconds.</para>

<para>The default selection set for this command is =C, all
commits. Occasionally you may want to restrict it, for example to
avoid coalescing unrelated "*** empty log message ***" commits from
CVS lifts.</para>
<!-- document handling of tags, branches, renames, deletes, copies. --> 
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>edit</command></cmdsynopsis></term>
<listitem>
<para>Edit a selection set of events.</para>
<para>NOT YET IMPLEMENTED.</para>
</listitem>
</varlistentry>
</variablelist>

<para>These are backed up by the following housekeeping commands, none of 
which take a selection set:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>help</command></cmdsynopsis></term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>resolve</command></cmdsynopsis></term>
<listitem><para>Does nothing but resolve a selection-set expression
and echo the resulting event-number set to standard
output. Implemented mainly for recression testing, but may be useful
for exploring the selection-set language.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>version</command></cmdsynopsis></term>
<listitem><para>Report the version of <application>reposurgeon</application>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>verbose</command></cmdsynopsis></term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>shell</command></cmdsynopsis></term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>prefer</command></cmdsynopsis></term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>read</command></cmdsynopsis></term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>stats</command></cmdsynopsis></term>
<listitem><para>
Report size statistics and import/export method information after reading
a repo or stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>write</command></cmdsynopsis></term>
<listitem><para>
Dump a fast-import stream representing the edited repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>rebuild</command></cmdsynopsis></term>
<listitem><para>
Rebuild a repository from the state held by
<application>reposurgeon</application>.  The argument specifies the
target directory in which to do the rebuild; if the repository read
was from a repo directory (and not a git-import stream), it defaults
to that directory.  If the target directory is nonempty its contents
are backed up to a save directory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>view</command></cmdsynopsis></term>
<listitem><para>
View a repo through the default GUI browser for its version control
system.  Note that this does not show the edited state held by
<application>reposurgeon</application> in core; it is mainly useful
for doing a quick eyeball check ofter a rebuild command.
</para></listitem>
</varlistentry>
</variablelist>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <application>reposurgeon</application> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <application>reposurgeon</application> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <application>reposurgeon</application> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <application>reposurgeon</application>
relies on other programs to generate and imterpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because exporting
from them requires fixups of usernames in the committer information to
full email addresses.  Trying to handle that entirely inside this tool
would be excessively messy, so we don't. Instead we let the user
transform repo-command streams and cope with the export/import
separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<application>reposurgeon</application>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@snark.thyrsus.com</email>; project
page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>).</para>
</refsect1>
</refentry>


commit refs/heads/master
mark :126
original-oid d5067f6e00fe49ecb351f8dc377e77870b1dbf56
author Eric S. Raymond <esr@thyrsus.com> 1288205012 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288205012 -0400
data 183
Switch selection sets from prefix to postfix.

The prefix position what triggering some obscure bug in the Python cmd
class; the symptom was that "$ verbose" wouldn't parse properly.
from :123
M 100644 :125 reposurgeon.xml
M 100755 :124 reposurgeon

blob
mark :127
original-oid 07e2efbd35b971cbfce30631fb24e9ab49dc5055
data 36212
#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time, re

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s") % os.path.relpath(source)
            return None
        elif hitcount > 1:
            complain("too many repos under %s") % os.path.relpath(source)
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            # A FIFO version wouldn't block our reads until
            # the entire file is written - faster, and makes our baton
            # spinner useful -- if it worked.
            #tfname = os.path.join("/tmp/reposurgeon"+`os.getpid()`)
            #os.mkfifo(tfname)
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def set_selection_set(self, line, default=None):
        "Implement object-selection syntax."
        self.selection = None
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = default
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = None
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() in ("+", "-", "="):
            visibility = None
        else:
            Unknown = type("")
            visible = set([Commit, Tag, Reset, Unknown])
            modmode = None
            while self.peek() in ("+", "-", "=", "B", "c", "t", "b", "u"):
                c = self.pop()
                if c == "+":
                    modmode = '+'
                elif c == '-':
                    modmode = '-'
                elif c == '=':
                    modmode = '+'
                    visible = set([])
                elif c == 'B':
                    if modmode == '+':
                        visible.add(Blob)
                    elif modmode == '-' and Blob in visible:
                        visible.remove(Blob)
                elif c == 'C':
                    if modmode == '+':
                        visible.add(Commit)
                    elif modmode == '-' and Commit in visible:
                        visible.remove(Commit)
                elif c == 'T':
                    if modmode == '+':
                        visible.add(Tag)
                    elif modmode == '-' and Tag in visible:
                        visible.remove(Tag)
                elif c == 'R':
                    if modmode == '+':
                        visible.add(Reset)
                    elif modmode == '-' and Reset in visible:
                        visible.remove(Reset)
                elif c == 'U':
                    if modmode == '+':
                        visible.add(Unknown)
                    elif modmode == '-' and Unknown in visible:
                        visible.remove(Unknown)
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if type(cmd) == Unknown and Unknown in visible:
                    selected.append(i)
                elif cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if type(cmd) == Unknown:
                            continue
                        elif hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSugeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSugeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("command number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdout)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        default = map(lambda x: x[0], filter(lambda (n, o): not isinstance(o, Blob), enumerate(self.repo.commands)))
        self.set_selection_set(line, default)
        for i in self.selection:
            command = self.repo.commands[i]
            if isinstance(command, Blob):
                print "%6d blob   %6s    %s" % (i, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag    -          %4s   %s" % (i, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on objects: their number, their type,
the associate mark (or '-' if no mark) and a summary field varying by type.
For a branch or tag it's the reference; for a commit it's the commit branch;
for a blob it's the repository path of the fiile in the blob. 

Normally, listing of blobs in the index is suppressed, as it is not very
useful to list them independently of the commits that reference them. The
+b option enables display of blobs.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        set_selection_set(line)
        print self.selection
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        interpreter.use_rawinput = False
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.use_rawinput = True
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                    interpreter.use_rawinput = False
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end

commit refs/heads/master
mark :128
original-oid 23b1c471add0f5ae5611c2de972213eb8a8f54a4
author Eric S. Raymond <esr@thyrsus.com> 1288206185 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1288206185 -0400
data 55
Compute the correct default set for the index command.
from :126
M 100755 :127 reposurgeon

tag annotated-sample
from :113
original-oid d2be661b8dda6a252be3796c656ca721cb529c59
tagger Eric S. Raymond <esr@thyrsus.com> 1288206780 -0400
data 66
We want an anntated tag in the repo for regression-test purposes.

done
