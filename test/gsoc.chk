pygi <pygi@57a73879-2fb5-44c3-a270-3262357dd7e2>
pygi <pygi>
stefan <stefan@57a73879-2fb5-44c3-a270-3262357dd7e2>
reposurgeon: internal error looking for renames of scripts/notify-roundup/notify-roundup.py
# This was originally a section from a git-svn lift, but a few of the
# committer/author headers have been hacked into the form emitted by
# git-cvsimport and cvs2git in order to broaden the test coverage. Also
# some delete ops have been removed.
blob
mark :186
data 171
<html>
<head>
<title>Item Not Found</title>
</head>

<body>
There is no <span tal:content="context/_classname" /> with id <span tal:content="context/id"/>
</body>
</html>

blob
mark :187
data 776
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <link rel="stylesheet" type="text/css" href="@@file/style.css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8;" />
  <title tal:content="string:Roundup Calendar"></title>
  <script language="Javascript"
          type="text/javascript"
          tal:content="structure string:
          // this is the name of the field in the original form that we're working on
          form  = window.opener.document.${request/form/form/value};
          field = '${request/form/property/value}';" >
  </script>
 </head>
 <body class="body"
       tal:content="structure python:utils.html_calendar(request)">
 </body>
</html>

blob
mark :189
data 177
<html>
  <head>
    <title>Empty page (no search performed yet)</title>
  </head>
  <body>
    <p i18n:translate="">Please specify your search parameters!</p>
  </body>
</html>

blob
mark :191
data 358
<html>
  <head>
    <title>Frame for search input fields</title>
  </head>
  <body>
    <p i18n:translate="">Generic template
    <span tal:replace="request/template" i18n:name="template">help-search</span>
    or version for class
    <span tal:replace="request/classname" i18n:name="classname">user</span>
    is not yet implemented</p>
  </body>
</html>


blob
mark :192
data 2615
<html>
  <head>
      <link rel="stylesheet" type="text/css" href="@@file/style.css" />
      <meta http-equiv="Content-Type"
       tal:attributes="content string:text/html;; charset=${request/client/charset}" />
      <tal:block tal:condition="python:request.form.has_key('property')">
      <title>Generic submit page for framed helper windows</title>
      <script language="Javascript" type="text/javascript"
          tal:content="structure string:<!--
// this is the name of the field in the original form that we're working on
form  = parent.opener.document.${request/form/form/value};
callingform=form
field  = '${request/form/property/value}';
var listform = null
function listPresent() {
  return document.frm_help.cb_listpresent.checked
}
function getListForm() {
  if (listPresent()) {
    return parent.list.document.forms.dummyform
  } else {
    return null
  }
}


function checkListForm() {
  // global listform
  if (listform != null)
    if (parent.list.document.dummyform) {
      listform = parent.list.document.dummyform
      alert(listform)
    }

  var bol= listform != null
  alert('checkListForm: bol='+bol)
  return bol
}
//-->">
      </script>
      <script src="@@file/help_controls.js" type="text/javascript"></script>
      </tal:block>
  </head>
 <body class="body" onload="parent.focus();" id="submit">
 <pre tal:content="request/env/QUERY_STRING" tal:condition=false />
 <form name="frm_help"
       tal:define="batch request/batch;
       props python:request.form['properties'].value.split(',')"
       class="help-submit"
       id="classhelp-controls">
     <div style="width:100%;text-align:left;margin-bottom:0.2em">
       <input type="text" name="text_preview" size="24" class="preview"
       onchange="f=getListForm();if(f){ reviseList_framed(f, this)};"
       />
     </div>
     <input type=checkbox name="cb_listpresent" readonly="readonly" style="display:none">
     <input type="button" id="btn_cancel"
            value=" Cancel " onclick="parent.close();return false;"
            i18n:attributes="value" />
     <input type="reset" id="btn_reset"
     onclick="text_field.value=original_field;f=getListForm();if (f) {reviseList_framed(f, this)};return false"
            />
     <input type="submit" id="btn_apply" class="apply"
            value=" Apply " onclick="callingform[field].value=text_field.value; parent.close();"
            i18n:attributes="value" />
 </form>
 <script type="text/javascript"><!--
var text_field = document.frm_help.text_preview;
original_field=form[field].value;
text_field.value=original_field;
//--></script>
 </body>
</html>

blob
mark :210
data 78
<!-- query.item -->
<span tal:replace="structure context/renderQueryForm" />


blob
mark :287
data 0

commit refs/heads/gsoc-2009
mark :557
author Stefan Seefeld <stefan@users.sourceforge.net> 1243903091 +0000
committer Stefan Seefeld <stefan@users.sourceforge.net> 1243903091 +0000
data 25
Set up GSoC 2009 branch.
property svn 4 4214

blob
mark :558
data 325
Name: devel
Description: This is a generic issue tracker that may be used to track bugs,
             feature requests, project issues or any number of other types
             of issues. Most users of Roundup will find that this template
             suits them, with perhaps a few customisations.
Intended-For: Developers


blob
mark :559
data 11826
# Roundup issue tracker configuration file
# Autogenerated at Fri Nov 17 16:59:49 2006

# WARNING! Following options need adjustments:
#  [mail]: domain, host
#  [tracker]: web

[main]

# Database directory path.
# The path may be either absolute or relative
# to the directory containig this config file.
# Default: db
database = db

# Path to the HTML templates directory.
# The path may be either absolute or relative
# to the directory containig this config file.
# Default: html
templates = html

# Path to directory holding additional static files
# available via Web UI.  This directory may contain
# sitewide images, CSS stylesheets etc. and is searched
# for these files prior to the TEMPLATES directory
# specified above.  If this option is not set, all static
# files are taken from the TEMPLATES directory
# The path may be either absolute or relative
# to the directory containig this config file.
# Default: 
static_files = 

# Email address that roundup will complain to if it runs into trouble.
# Default: roundup-admin
admin_email = roundup-admin

# The 'dispatcher' is a role that can get notified
# of new items to the database.
# It is used by the ERROR_MESSAGES_TO config setting.
# Default: roundup-admin
dispatcher_email = roundup-admin

# Additional text to include in the "name" part
# of the From: address used in nosy messages.
# If the sending user is "Foo Bar", the From: line
# is usually: "Foo Bar" <issue_tracker@tracker.example>
# the EMAIL_FROM_TAG goes inside the "Foo Bar" quotes like so:
# "Foo Bar EMAIL_FROM_TAG" <issue_tracker@tracker.example>
# Default: 
email_from_tag = 

# Roles that a user gets when they register with Web User Interface.
# This is a comma-separated string of role names (e.g. 'Admin,User').
# Default: User
new_web_user_roles = User

# Roles that a user gets when they register with Email Gateway.
# This is a comma-separated string of role names (e.g. 'Admin,User').
# Default: User
new_email_user_roles = User

# Send error message emails to the dispatcher, user, or both?
# The dispatcher is configured using the DISPATCHER_EMAIL setting.
# Default: user
error_messages_to = user

# HTML version to generate. The templates are html4 by default.
# If you wish to make them xhtml, then you'll need to change this
# var to 'xhtml' too so all auto-generated HTML is compliant.
# Allowed values: html4, xhtml
# Default: html4
html_version = xhtml

# Default timezone offset, applied when user's timezone is not set.
# If pytz module is installed, value may be any valid
# timezone specification (e.g. EET or Europe/Warsaw).
# If pytz is not installed, value must be integer number
# giving local timezone offset from UTC in hours.
# Default: UTC
timezone = UTC

# Register new users instantly, or require confirmation via
# email?
# Allowed values: yes, no
# Default: no
instant_registration = no

# Offer registration confirmation by email or only through the web?
# Allowed values: yes, no
# Default: yes
email_registration_confirmation = yes

# Additional stop-words for the full-text indexer specific to
# your tracker. See the indexer source for the default list of
# stop-words (eg. A,AND,ARE,AS,AT,BE,BUT,BY, ...)
# Allowed values: comma-separated list of words
# Default: 
indexer_stopwords = 

# Defines the file creation mode mask.
# Default: 02
umask = 02

[tracker]

# A descriptive name for your roundup instance.
# Default: Roundup issue tracker
name = Roundup tracker

# The web address that the tracker is viewable at.
# This will be included in information sent to users of the tracker.
# The URL MUST include the cgi-bin part or anything else
# that is required to get to the home page of the tracker.
# You MUST include a trailing '/' in the URL.
# Default: NO DEFAULT
web = 

# Email address that mail to roundup should go to.
# Default: issue_tracker
email = issue_tracker

# Default locale name for this tracker.
# If this option is not set, the language is determined
# by OS environment variable LANGUAGE, LC_ALL, LC_MESSAGES,
# or LANG, in that order of preference.
# Default: 
language = 

[web]

# Whether to use HTTP Basic Authentication, if present.
# Roundup will use either the REMOTE_USER or HTTP_AUTHORIZATION
# variables supplied by your web server (in that order).
# Set this option to 'no' if you do not wish to use HTTP Basic
# Authentication in your web interface.
# Allowed values: yes, no
# Default: yes
http_auth = yes

# Whether to use HTTP Accept-Language, if present.
# Browsers send a language-region preference list.
# It's usually set in the client's browser or in their
# Operating System.
# Set this option to 'no' if you want to ignore it.
# Allowed values: yes, no
# Default: yes
use_browser_language = no

# Setting this option makes Roundup display error tracebacks
# in the user's browser rather than emailing them to the
# tracker admin.
# Allowed values: yes, no
# Default: no
debug = no

# Settings in this section are used by Postgresql and MySQL backends only
[rdbms]

# Name of the database to use.
# Default: roundup
name = roundup_roundup_tracker

# Database server host.
# Default: localhost
host = localhost

# TCP port number of the database server.
# Postgresql usually resides on port 5432 (if any),
# for MySQL default port number is 3306.
# Leave this option empty to use backend default
# Default: 
port = 

# Database user name that Roundup should use.
# Default: roundup
user = roundup

# Database user password.
# Default: roundup
password = roundup

# Name of the MySQL defaults file.
# Only used in MySQL connections.
# Default: ~/.my.cnf
read_default_file = ~/.my.cnf

# Name of the group to use in the MySQL defaults file (.my.cnf).
# Only used in MySQL connections.
# Default: roundup
read_default_group = roundup

[logging]

# Path to configuration file for standard Python logging module.
# If this option is set, logging configuration is loaded
# from specified file; options 'filename' and 'level'
# in this section are ignored.
# The path may be either absolute or relative
# to the directory containig this config file.
# Default: 
config = 

# Log file name for minimal logging facility built into Roundup.
# If no file name specified, log messages are written on stderr.
# If above 'config' option is set, this option has no effect.
# The path may be either absolute or relative
# to the directory containig this config file.
# Default: 
filename = 

# Minimal severity level of messages written to log file.
# If above 'config' option is set, this option has no effect.
# Allowed values: DEBUG, INFO, WARNING, ERROR
# Default: ERROR
level = ERROR

# Outgoing email options.
# Used for nozy messages and approval requests
[mail]

# Domain name used for email addresses.
# Default: NO DEFAULT
#domain = NO DEFAULT
domain = psf.upfronthosting.co.za

# SMTP mail host that roundup will use to send mail
# Default: NO DEFAULT
#host = NO DEFAULT
host = localhost

# SMTP login name.
# Set this if your mail host requires authenticated access.
# If username is not empty, password (below) MUST be set!
# Default: 
username = 

# SMTP login password.
# Set this if your mail host requires authenticated access.
# Default: NO DEFAULT
#password = NO DEFAULT

# If your SMTP mail host provides or requires TLS
# (Transport Layer Security) then set this option to 'yes'.
# Allowed values: yes, no
# Default: no
tls = no

# If TLS is used, you may set this option to the name
# of a PEM formatted file that contains your private key.
# The path may be either absolute or relative
# to the directory containig this config file.
# Default: 
tls_keyfile = 

# If TLS is used, you may set this option to the name
# of a PEM formatted certificate chain file.
# The path may be either absolute or relative
# to the directory containig this config file.
# Default: 
tls_certfile = 

# Character set to encode email headers with.
# We use utf-8 by default, as it's the most flexible.
# Some mail readers (eg. Eudora) can't cope with that,
# so you might need to specify a more limited character set
# (eg. iso-8859-1).
# Default: utf-8
charset = utf-8

# Setting this option makes Roundup to write all outgoing email
# messages to this file *instead* of sending them.
# This option has the same effect as environment variable SENDMAILDEBUG.
# Environment variable takes precedence.
# The path may be either absolute or relative
# to the directory containig this config file.
# Default: 
#debug = /home/roundup/outgoing-mail
debug = 

# Roundup Mail Gateway options
[mailgw]

# Keep email citations when accepting messages.
# Setting this to "no" strips out "quoted" text from the message.
# Signatures are also stripped.
# Allowed values: yes, no
# Default: yes
keep_quoted_text = yes

# Preserve the email body as is - that is,
# keep the citations _and_ signatures.
# Allowed values: yes, no
# Default: no
leave_body_unchanged = no

# Default class to use in the mailgw
# if one isn't supplied in email subjects.
# To disable, leave the value blank.
# Default: issue
default_class = issue

# Default locale name for the tracker mail gateway.
# If this option is not set, mail gateway will use
# the language of the tracker instance.
# Default: 
language = 

# Controls the parsing of the [prefix] on subject
# lines in incoming emails. "strict" will return an
# error to the sender if the [prefix] is not recognised.
# "loose" will attempt to parse the [prefix] but just
# pass it through as part of the issue title if not
# recognised. "none" will always pass any [prefix]
# through as part of the issue title.
# Default: strict
subject_prefix_parsing = strict

# Controls the parsing of the [suffix] on subject
# lines in incoming emails. "strict" will return an
# error to the sender if the [suffix] is not recognised.
# "loose" will attempt to parse the [suffix] but just
# pass it through as part of the issue title if not
# recognised. "none" will always pass any [suffix]
# through as part of the issue title.
# Default: strict
subject_suffix_parsing = strict

# Defines the brackets used for delimiting the prefix and 
# suffix in a subject line. The presence of "suffix" in
# the config option name is a historical artifact and may
# be ignored.
# Default: []
subject_suffix_delimiters = []

# Controls matching of the incoming email subject line
# against issue titles in the case where there is no
# designator [prefix]. "never" turns off matching.
# "creation + interval" or "activity + interval"
# will match an issue for the interval after the issue's
# creation or last activity. The interval is a standard
# Roundup interval.
# Default: always
subject_content_match = always

# Nosy messages sending
[nosy]

# Send nosy messages to the author of the message.
# Allowed values: yes, no, new
# Default: no
messages_to_author = yes

# Where to place the email signature.
# Allowed values: top, bottom, none
# Default: bottom
signature_position = bottom

# Does the author of a message get placed on the nosy list
# automatically?  If 'new' is used, then the author will
# only be added when a message creates a new issue.
# If 'yes', then the author will be added on followups too.
# If 'no', they're never added to the nosy.
# 
# Allowed values: yes, no, new
# Default: new
add_author = yes

# Do the recipients (To:, Cc:) of a message get placed on the
# nosy list?  If 'new' is used, then the recipients will
# only be added when a message creates a new issue.
# If 'yes', then the recipients will be added on followups too.
# If 'no', they're never added to the nosy.
# 
# Allowed values: yes, no, new
# Default: new
add_recipients = new

# Controls the email sending from the nosy reactor. If
# "multiple" then a separate email is sent to each
# recipient. If "single" then a single email is sent with
# each recipient as a CC address.
# Default: single
email_sending = multiple

blob
mark :560
data 613
#$Id: messagesummary.py,v 1.1 2009/02/01 22:23:25 stefan Exp $

from roundup.mailgw import parseContent

def summarygenerator(db, cl, nodeid, newvalues):
    ''' If the message doesn't have a summary, make one for it.
    '''
    if newvalues.has_key('summary') or not newvalues.has_key('content'):
        return

    summary, content = parseContent(newvalues['content'], config=db.config)
    newvalues['summary'] = summary


def init(db):
    # fire before changes are made
    db.msg.audit('create', summarygenerator)

# vim: set filetype=python ts=4 sw=4 et si
#SHA: 538f90cb7f4eb63f77eca252b87afbe037d29c48

blob
mark :561
data 271

def audit_html_files(db, cl, nodeid, newvalues):
    if newvalues.has_key('type') and newvalues['type'] == 'text/html':
        newvalues['type'] = 'text/plain'
    

def init(db):
    db.file.audit('set', audit_html_files)
    db.file.audit('create', audit_html_files)

blob
mark :562
data 4563
import sets

from roundup import roundupdb, hyperdb

def nosyreaction(db, cl, nodeid, oldvalues):
    ''' A standard detector is provided that watches for additions to the
        "messages" property.
        
        When a new message is added, the detector sends it to all the users on
        the "nosy" list for the issue that are not already on the "recipients"
        list of the message.
        
        Those users are then appended to the "recipients" property on the
        message, so multiple copies of a message are never sent to the same
        user.
        
        The journal recorded by the hyperdatabase on the "recipients" property
        then provides a log of when the message was sent to whom. 
    '''
    # send a copy of all new messages to the nosy list
    for msgid in determineNewMessages(cl, nodeid, oldvalues):
        try:
            cl.nosymessage(nodeid, msgid, oldvalues)
        except roundupdb.MessageSendError, message:
            raise roundupdb.DetectorError, message

def determineNewMessages(cl, nodeid, oldvalues):
    ''' Figure a list of the messages that are being added to the given
        node in this transaction.
    '''
    messages = []
    if oldvalues is None:
        # the action was a create, so use all the messages in the create
        messages = cl.get(nodeid, 'messages')
    elif oldvalues.has_key('messages'):
        # the action was a set (so adding new messages to an existing issue)
        m = {}
        for msgid in oldvalues['messages']:
            m[msgid] = 1
        messages = []
        # figure which of the messages now on the issue weren't there before
        for msgid in cl.get(nodeid, 'messages'):
            if not m.has_key(msgid):
                messages.append(msgid)
    return messages

def updatenosy(db, cl, nodeid, newvalues):
    '''Update the nosy list for changes to the assignedto
    '''
    # nodeid will be None if this is a new node
    current_nosy = sets.Set()
    if nodeid is None:
        ok = ('new', 'yes')
    else:
        ok = ('yes',)
        # old node, get the current values from the node if they haven't
        # changed
        if not newvalues.has_key('nosy'):
            nosy = cl.get(nodeid, 'nosy')
            for value in nosy:
                current_nosy.add(value)

    # if the nosy list changed in this transaction, init from the new value
    if newvalues.has_key('nosy'):
        nosy = newvalues.get('nosy', [])
        for value in nosy:
            if not db.hasnode('user', value):
                continue
            current_nosy.add(value)

    new_nosy = sets.Set(current_nosy)

    # add assignedto(s) to the nosy list
    if newvalues.has_key('assignedto') and newvalues['assignedto'] is not None:
        propdef = cl.getprops()
        if isinstance(propdef['assignedto'], hyperdb.Link):
            assignedto_ids = [newvalues['assignedto']]
        elif isinstance(propdef['assignedto'], hyperdb.Multilink):
            assignedto_ids = newvalues['assignedto']
        for assignedto_id in assignedto_ids:
            new_nosy.add(assignedto_id)

    # see if there's any new messages - if so, possibly add the author and
    # recipient to the nosy
    if newvalues.has_key('messages'):
        if nodeid is None:
            ok = ('new', 'yes')
            messages = newvalues['messages']
        else:
            ok = ('yes',)
            # figure which of the messages now on the issue weren't
            oldmessages = cl.get(nodeid, 'messages')
            messages = []
            for msgid in newvalues['messages']:
                if msgid not in oldmessages:
                    messages.append(msgid)

        # configs for nosy modifications
        add_author = getattr(db.config, 'ADD_AUTHOR_TO_NOSY', 'new')
        add_recips = getattr(db.config, 'ADD_RECIPIENTS_TO_NOSY', 'new')

        # now for each new message:
        msg = db.msg
        for msgid in messages:
            if add_author in ok:
                authid = msg.get(msgid, 'author')
                new_nosy.add(authid)

            # add on the recipients of the message
            if add_recips in ok:
                for recipient in msg.get(msgid, 'recipients'):
                    new_nosy.add(recipient)

    if current_nosy != new_nosy:
        # that's it, save off the new nosy list
        newvalues['nosy'] = list(new_nosy)

def init(db):
    db.issue.react('create', nosyreaction)
    db.issue.react('set', nosyreaction)
    db.issue.audit('create', updatenosy)
    db.issue.audit('set', updatenosy)

blob
mark :563
data 1537
# Auditor for patch files
# Patches should be declared as text/plain (also .py files),
# independent of what the browser says, and
# the "patch" keyword should get set automatically.

import posixpath

patchtypes = ('.diff', '.patch')
sourcetypes = ('.diff', '.patch', '.py')

def ispatch(file, types):
    return posixpath.splitext(file)[1] in types

def patches_text_plain(db, cl, nodeid, newvalues):
    if ispatch(newvalues['name'], sourcetypes):
        newvalues['type'] = 'text/plain'

def patches_keyword(db, cl, nodeid, newvalues):
    # Check whether there are any new files
    newfiles = set(newvalues.get('files',()))
    if nodeid:
        newfiles -= set(db.issue.get(nodeid, 'files'))
    # Check whether any of these is a patch
    newpatch = False
    for fileid in newfiles:
        if ispatch(db.file.get(fileid, 'name'), patchtypes):
            newpatch = True
            break
    if newpatch:
        # Add the patch keyword if its not already there
        patchid = db.keyword.lookup("patch")
        oldkeywords = []
        if nodeid:
            oldkeywords = db.issue.get(nodeid, 'keywords')
            if patchid in oldkeywords:
                # This is already marked as a patch
                return
        if not newvalues.has_key('keywords'):
            newvalues['keywords'] = oldkeywords
        newvalues['keywords'].append(patchid)

def init(db): pass
#    db.file.audit('create', patches_text_plain)
#    db.issue.audit('create', patches_keyword)
#    db.issue.audit('set', patches_keyword)

blob
mark :564
data 319

def init_severity(db, cl, nodeid, newvalues):
    """Make sure severity is set on new issues"""
    if newvalues.has_key('severity') and newvalues['severity']:
        return

    normal = db.severity.lookup('normal')
    newvalues['severity'] = normal

def init(db): pass
    #db.issue.audit('create', init_severity)

blob
mark :565
data 335
def preset_new(db, cl, nodeid, newvalues):
    """ Make sure the status is set on new issues"""

    if newvalues.has_key('status') and newvalues['status']:
        return

    new = db.status.lookup('new')
    newvalues['status'] = new


def init(db): pass
    # fire before changes are made
    #db.issue.audit('create', preset_new)

blob
mark :566
data 2901
import re

# regular expression thanks to: http://www.regular-expressions.info/email.html
# this is the "99.99% solution for syntax only".
email_regexp = (r"[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*", r"(localhost|(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9]))")
email_rfc = re.compile('^' + email_regexp[0] + '@' + email_regexp[1] + '$', re.IGNORECASE)
email_local = re.compile('^' + email_regexp[0] + '$', re.IGNORECASE)

def valid_address(address):
    ''' If we see an @-symbol in the address then check against the full
        RFC syntax. Otherwise it is a local-only address so only check
        the local part of the RFC syntax.
    '''
    if '@' in address:
        return email_rfc.match(address)
    else:
        return email_local.match(address)

def get_addresses(user):
    ''' iterate over all known addresses in a newvalues dict
        this takes of the address/alterate_addresses handling
    '''
    if user.has_key('address'):
        yield user['address']
    if user.get('alternate_addresses', None):
        for address in user['alternate_addresses'].split('\n'):
            yield address

def audit_user_fields(db, cl, nodeid, newvalues):
    ''' Make sure user properties are valid.

        - email address is syntactically valid
        - email address is unique
        - roles specified exist
        - timezone is valid
    '''

    for address in get_addresses(newvalues):
        if not valid_address(address):
            print newvalues
            raise ValueError, 'Email address syntax is invalid "%s"'%address

        check_main = db.user.stringFind(address=address)
        # make sure none of the alts are owned by anyone other than us (x!=nodeid)
        check_alts = [x for x in db.user.filter(None, {'alternate_addresses' : address}) if x != nodeid]
        if check_main or check_alts:
            raise ValueError, 'Email address %s already in use' % address

    for rolename in [r.lower().strip() for r in newvalues.get('roles', '').split(',')]:
            if rolename and not db.security.role.has_key(rolename):
                raise ValueError, 'Role "%s" does not exist'%rolename

    tz = newvalues.get('timezone', None)
    if tz:
        # if they set a new timezone validate the timezone by attempting to
        # use it before we store it to the db.
        import roundup.date
        import datetime
        try:
            TZ = roundup.date.get_timezone(tz)
            dt = datetime.datetime.now()
            local = TZ.localize(dt).utctimetuple()
        except IOError:
            raise ValueError, 'Timezone "%s" does not exist' % tz
        except ValueError:
            raise ValueError, 'Timezone "%s" exceeds valid range [-23...23]' % tz

def init(db):
    # fire before changes are made
    db.user.audit('set', audit_user_fields)
    db.user.audit('create', audit_user_fields)

blob
mark :567
data 1555
import re

substitutions = [ (re.compile('debian:\#(?P<id>\d+)'),
                   '<a href="http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=\g<id>">debian#\g<id></a>' ),
                  (re.compile('\#(?P<ws>\s*)(?P<id>\d+)'),
                   "<a href='issue\g<id>'>#\g<ws>\g<id></a>" ),
                  (re.compile('(?P<prews>\s+)revision(?P<ws>\s*)(?P<revision>\d+)'),
                   "\g<prews><a href='http://svn.roundup-tracker.org/view?rev=\g<revision>&view=rev'>revision\g<ws>\g<revision></a>"),
                  (re.compile('(?P<prews>\s+)rev(?P<ws>\s*)(?P<revision>\d+)'),
                   "\g<prews><a href='http://svn.roundup-tracker.org/view?rev=\g<revision>&view=rev'>rev\g<ws>\g<revision></a>"),
                  (re.compile('(?P<prews>\s+)(?P<revstr>r|r\s+)(?P<revision>\d+)'),
                   "\g<prews><a href='http://svn.roundup-tracker.org/view?rev=\g<revision>&view=rev'>\g<revstr>\g<revision></a>"),
                  ]

def local_replace(message):

    for cre, replacement in substitutions:
        message = cre.sub(replacement, message)

    return message
        
    
    
def init(instance):
    instance.registerUtil('localReplace', local_replace)
    

if "__main__" == __name__:
    print " debian:#222", local_replace(" debian:#222")
    print " revision 222", local_replace(" revision 222")
    print " wordthatendswithr 222", local_replace(" wordthatendswithr 222")
    print " r222", local_replace(" r222")
    print " r 222", local_replace(" r 222")
    print " #555", local_replace(" #555")
    

blob
mark :568
data 2689
import re, math
from roundup.cgi.actions import Action
from roundup.cgi.exceptions import *

import xmlrpclib, socket

REVPAT = re.compile(r'(r[0-9]+\b|rev(ision)? [0-9]+\b)')

def extract_classinfo(db, classname, nodeid):
    node = db.getnode(classname, nodeid)

    authorage = node['creation'].timestamp() - \
                db.getnode('user', node.get('author', node.get('creator')))['creation'].timestamp()

    authorid = node.get('author', node.get('creator'))

    content = db.getclass(classname).get(nodeid, 'content')

    tokens = ["klass:%s" % classname,
              "author:%s" % authorid,
              "authorage:%d" % int(math.log(authorage)),
              "hasrev:%s" % (REVPAT.search(content) is not None)]

    return (content, tokens)

def train_spambayes(db, content, tokens, is_spam):
    spambayes_uri = db.config.detectors['SPAMBAYES_URI']

    server = xmlrpclib.ServerProxy(spambayes_uri, verbose=False)
    try:
        server.train({'content':content}, tokens, {}, is_spam)
        return (True, None)
    except (socket.error, xmlrpclib.Error), e:
        return (False, str(e))


class SpambayesClassify(Action):
    permissionType = 'SB: May Classify'
    
    def handle(self):
        (content, tokens) = extract_classinfo(self.db,
                                              self.classname, self.nodeid)

        if self.form.has_key("trainspam"):
            is_spam = True
        elif self.form.has_key("trainham"):
            is_spam = False

        (status, errmsg) = train_spambayes(self.db, content, tokens,
                                           is_spam)

        node = self.db.getnode(self.classname, self.nodeid)
        props = {}

        if status:
            if node.get('spambayes_misclassified', False):
                props['spambayes_misclassified'] = True

            props['spambayes_score'] = 1.0
            
            s = " SPAM"
            if not is_spam:
                props['spambayes_score'] = 0.0
                s = " HAM"
            self.client.ok_message.append(self._('Message classified as') + s)
        else:
            self.client.error_message.append(self._('Unable to classify message, got error:') + errmsg)

        klass = self.db.getclass(self.classname)
        klass.set(self.nodeid, **props)
        self.db.commit()

def sb_is_spam(obj):
    cutoff_score = float(obj._db.config.detectors['SPAMBAYES_SPAM_CUTOFF'])
    try:
        score = obj['spambayes_score']
    except KeyError:
        return False
    return score >= cutoff_score

def init(instance):
    instance.registerAction("spambayes_classify", SpambayesClassify)
    instance.registerUtil('sb_is_spam', sb_is_spam)
    

blob
mark :569
data 890
import time, struct, base64
from roundup.cgi.actions import RegisterAction
from roundup.cgi.exceptions import *

def timestamp():
    return base64.encodestring(struct.pack("i", time.time())).strip()

def unpack_timestamp(s):
    return struct.unpack("i",base64.decodestring(s))[0]

class Timestamped:
    def check(self):
        try:
            created = unpack_timestamp(self.form['opaque'].value)
        except KeyError:
            raise FormError, "somebody tampered with the form"
        if time.time() - created < 4:
            raise FormError, "responding to the form too quickly"
        return True

class TimestampedRegister(Timestamped, RegisterAction):
    def permission(self):
        self.check()
        RegisterAction.permission(self)

def init(instance):
    instance.registerUtil('timestamp', timestamp)
    instance.registerAction('register', TimestampedRegister)

blob
mark :570
data 907
# Utility for replacing the simple input field for the timezone with
# a select-field that lists the available values.

import cgi

try:
    import pytz
except ImportError:
    pytz = None


def tzfield(prop, name, default):
    if pytz:
        value = prop.plain()        
        if '' == value:
            value = default
        else:
            try:
                value = "Etc/GMT%+d" % int(value)
            except ValueError:
                pass

        l = ['<select name="%s"' % name]
        for zone in pytz.all_timezones:
            s = ' '
            if zone == value:
                s = 'selected=selected '
            z = cgi.escape(zone)
            l.append('<option %svalue="%s">%s</option>' % (s, z, z))
        l.append('</select>')
        return '\n'.join(l)
        
    else:
        return prop.field()

def init(instance):
    instance.registerUtil('tzfield', tzfield)

blob
mark :571
data 759
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate=""
 ><span tal:replace="python:context._classname.capitalize()"
 i18n:name="class" /> Edit Collision - <span i18n:name="tracker"
 tal:replace="config/TRACKER_NAME" /></title>
<tal:block metal:fill-slot="body_title" i18n:translate=""
 ><span tal:replace="python:context._classname.capitalize()"
 i18n:name="class" /> Edit Collision</tal:block>

<td class="content" metal:fill-slot="content" i18n:translate="
  There has been a collision. Another user updated this node
  while you were editing. Please <a href='${context}'>reload</a>
  the node and review your edits.
"><span tal:replace="context/designator" i18n:name="context" />
</td>
</tal:block>

blob
mark :572
data 1958
<tal:block tal:define="vok context/is_view_ok">
  <p tal:condition="not:vok" i18n:translate="">You are not
  allowed to view this page.</p>

  <tal:if condition="context/is_view_ok">
   <tal:def define="batch request/batch;">
    <table width="100%"
           tal:define="template string:help-list"
           metal:use-macro="templates/help/macros/batch_navi">
      <tr class="navigation">
       <th><a href="#">&lt;&lt; previous</a></th>
       <th i18n:translate="">1..25 out of 50</th>
       <th><a href="#">next &gt;&gt;</a></th>
      </tr>
    </table>
    <form>
    <table class="classhelp"
           tal:define="props python:request.form['properties'].value.split(',');
                       legend templates/help/macros/legend;">
      <thead>
        <tr metal:use-macro="legend">
          <th>&nbsp;<b>x</b></th>
          <th tal:repeat="prop props" tal:content="prop" i18n:translate=""></th>
        </tr>
      </thead>
      <tfoot tal:condition=true>
        <tr metal:use-macro="legend" />
      </tfoot>
      <tbody>
       <tr tal:repeat="item batch">
         <tal:block tal:define="attr python:item[props[0]]" >
           <td>
             <input name="check"
             onclick="switch_val(text_field, this);" type="checkbox"
             tal:attributes="value attr; id string:id_$attr" />
             </td>
             <td tal:repeat="prop props">
                 <label class="classhelp-label"
                        tal:attributes="for string:id_$attr"
                        tal:content="structure python:item[prop]"></label>
             </td>
           </tal:block>
         </tr>
       </tbody>
     </table>
   </form>
     </tal:def>
     </tal:if>
     
     <pre tal:content=request tal:condition=false />
     <script type="text/javascript"><!--
       parent.submit.document.frm_help.cb_listpresent.checked=true;
       reviseList_framed(document.dummyform, text_field)
     //--></script>
</tal:block>

blob
mark :573
data 5896
<tal:block metal:use-macro="templates/help/macros/frame">
<tal:block metal:fill-slot="content">
<tal:block tal:condition="python:request.form.has_key('property')">
 <form name="frm_help" action="#"
       tal:define="batch request/batch;
                   props python:request.form['properties'].value.split(',')">

     <div id="classhelp-controls" tal:condition="context/is_edit_ok">
       <!--input type="button" name="btn_clear"
              value="Clear" onClick="clearList()"/ -->
       <input type="text" name="text_preview" size="24" class="preview"
              onchange="reviseList(this.value);"/>
       <input type="button" name="btn_reset"
              value=" Cancel " onclick="resetList(); parent.close();"
              i18n:attributes="value" />
       <input type="button" name="btn_apply" class="apply"
              value=" Apply " onclick="updateList(); parent.close();"
              i18n:attributes="value" />
     </div>
     <table width="100%">
      <tr class="navigation">
       <th>
        <a tal:define="prev batch/previous" tal:condition="prev"
           tal:attributes="href python:request.indexargs_url(request.classname,
           {'@template':'help', 'property': request.form['property'].value,
            'properties': request.form['properties'].value,
            'form': request.form['form'].value,
            'type': request.form['type'].value,
            '@startwith':prev.first, '@pagesize':prev.size})"
           i18n:translate="" >&lt;&lt; previous</a>
        &nbsp;
       </th>
       <th i18n:translate=""><span tal:replace="batch/start" i18n:name="start"
        />..<span tal:replace="python: batch.start + batch.length -1" i18n:name="end"
        /> out of <span tal:replace="batch/sequence_length" i18n:name="total"
        />
       </th>
       <th>
        <a tal:define="next batch/next" tal:condition="next"
           tal:attributes="href python:request.indexargs_url(request.classname,
           {'@template':'help', 'property': request.form['property'].value,
            'properties': request.form['properties'].value,
            'form': request.form['form'].value,
            'type': request.form['type'].value,
            '@startwith':next.first, '@pagesize':next.size})"
           i18n:translate="" >next &gt;&gt;</a>
        &nbsp;
       </th>
      </tr>
     </table>

     <table class="classhelp">
       <tr>
           <th tal:condition="context/is_edit_ok">&nbsp;<b>x</b></th>
           <th tal:repeat="prop props" tal:content="prop" i18n:translate=""></th>
       </tr>
       <tr tal:repeat="item batch">
         <tal:block tal:define="attr python:item[props[0]]" >
           <td tal:condition="context/is_edit_ok">
             <input name="check"
                 onclick="updatePreview();"
                 tal:attributes="type python:request.form['type'].value;
                                 value attr; id string:id_$attr" />
             </td>
             <td tal:repeat="prop props">
                 <label class="classhelp-label"
                        tal:attributes="for string:id_$attr"
                        tal:content="structure python:item[prop]"></label>
             </td>
           </tal:block>
       </tr>
       <tr>
           <th>&nbsp;<b>x</b></th>
           <th tal:repeat="prop props" tal:content="prop" i18n:translate=""></th>
       </tr>
     </table>

 </form>
   <script type="text/javascript"><!--
var text_field = document.frm_help.text_preview;
original_field=form[field].value;
text_field.value=original_field;
//--></script>
 </tal:block>
 <tal:block tal:condition="python:not request.form.has_key('property')">
 <tal:block tal:define="batch request/batch;
                        props python:request.form['properties'].value.split(',')">
     <table width="100%">
      <tr class="navigation">
       <th>
        <a tal:define="prev batch/previous" tal:condition="prev"
           tal:attributes="href python:request.indexargs_url(request.classname,
           {'@template':'help', 'property': request.form['property'].value,
            'properties': request.form['properties'].value,
            'form': request.form['form'].value,
            'type': request.form['type'].value,
            '@startwith':prev.first, '@pagesize':prev.size})"
           i18n:translate="" >&lt;&lt; previous</a>
        &nbsp;
       </th>
       <th i18n:translate=""><span tal:replace="batch/start" i18n:name="start"
        />..<span tal:replace="python: batch.start + batch.length -1" i18n:name="end"
        /> out of <span tal:replace="batch/sequence_length" i18n:name="total"
        />
       </th>
       <th>
        <a tal:define="next batch/next" tal:condition="next"
           tal:attributes="href python:request.indexargs_url(request.classname,
           {'@template':'help', 'property': request.form['property'].value,
            'properties': request.form['properties'].value,
            'form': request.form['form'].value,
            'type': request.form['type'].value,
            '@startwith':next.first, '@pagesize':next.size})"
           i18n:translate="" >next &gt;&gt;</a>
        &nbsp;
       </th>
      </tr>
     </table>

     <table class="classhelp">
       <tr>
           <th tal:repeat="prop props" tal:content="prop" i18n:translate=""></th>
       </tr>
       <tr tal:repeat="item batch">
         <tal:block tal:define="attr python:item[props[0]]" >
             <td tal:repeat="prop props">
                 <label class="classhelp-label"
                        tal:attributes="for string:id_$attr"
                        tal:content="structure python:item[prop]"></label>
             </td>
           </tal:block>
       </tr>
       <tr>
           <th tal:repeat="prop props" tal:content="prop" i18n:translate=""></th>
       </tr>
     </table>
 </tal:block>
 </tal:block>
</tal:block> <!-- content -->
</tal:block>

blob
mark :574
data 2457
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate=""
 ><span tal:replace="python:context._classname.capitalize()"
 i18n:name="class" /> editing - <span i18n:name="tracker"
 tal:replace="config/TRACKER_NAME" /></title>
<tal:block metal:fill-slot="body_title" i18n:translate=""
 ><span tal:replace="python:context._classname.capitalize()"
 i18n:name="class" /> editing</tal:block>

<td class="content" metal:fill-slot="content">

<span tal:condition="python:not (context.is_view_ok() or context.is_edit_ok()
 or request.user.hasRole('Anonymous'))"
 tal:omit-tag="python:1" i18n:translate=""
>You are not allowed to view this page.</span>

<span tal:condition="python:not (context.is_view_ok() or context.is_edit_ok())
 and request.user.hasRole('Anonymous')"
 tal:omit-tag="python:1" i18n:translate=""
>Please login with your username and password.</span>

<tal:block tal:condition="context/is_edit_ok">
<tal:block i18n:translate="">
<p class="form-help">
 You may edit the contents of the
 <span tal:replace="request/classname" i18n:name="classname"/>
 class using this form. Commas, newlines and double quotes (") must be
 handled delicately. You may include commas and newlines by enclosing the
 values in double-quotes ("). Double quotes themselves must be quoted by
 doubling ("").
</p>

<p class="form-help">
 Multilink properties have their multiple values colon (":") separated
 (... ,"one:two:three", ...)
</p>

<p class="form-help">
 Remove entries by deleting their line. Add new entries by appending
 them to the table - put an X in the id column.
</p>
</tal:block>
<form onSubmit="return submit_once()" method="POST"
      tal:attributes="action context/designator">
<textarea rows="15" style="width:90%" name="rows" tal:content="context/csv"></textarea>
<br>
<input type="hidden" name="@action" value="editCSV">
<input type="submit" value="Edit Items" i18n:attributes="value">
</form>
</tal:block>

<table tal:condition="context/is_only_view_ok" width="100%" class="list">
 <tr>
  <th tal:repeat="property context/propnames" tal:content="property">&nbsp;</th>
 </tr>
 <tal:block repeat="item context/list">
 <tr tal:condition="item/is_view_ok"
     tal:attributes="class python:['normal', 'alt'][repeat['item'].index%6/3]">
  <td tal:repeat="property context/propnames"
   tal:content="python: item[property] or default"
  >&nbsp;</td>
 </tr>
 </tal:block>
</table>

</td>

</tal:block>

blob
mark :575
data 1644
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate=""
 ><span tal:replace="python:context._classname.capitalize()"
 i18n:name="class" /> editing - <span i18n:name="tracker"
 tal:replace="config/TRACKER_NAME" /></title>
<tal:block metal:fill-slot="body_title" i18n:translate=""
 ><span tal:replace="python:context._classname.capitalize()"
 i18n:name="class" /> editing</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<div tal:condition="context/is_view_ok">

<form method="POST" onSubmit="return submit_once()"
      enctype="multipart/form-data" tal:condition="context/is_view_ok"
      tal:attributes="action context/designator">

<input type="hidden" name="@template" value="item">

<table class="form">

<tr tal:repeat="prop python:db[context._classname].properties()">
 <tal:block tal:condition="python:prop._name not in ('id',
   'creator', 'creation', 'actor', 'activity')">
  <th tal:content="prop/_name"></th>
  <td tal:content="structure python:context[prop._name].field()"></td>
 </tal:block>
</tr>
<tr>
 <td>&nbsp;</td>
 <td colspan=3 tal:content="structure context/submit">
  submit button will go here
 </td>
</tr>
</table>

</form>

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</div>

</td>

</tal:block>

blob
mark :576
data 7691
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" >
  <span tal:omit-tag="true" i18n:translate="" >List of bugs</span>
  <span tal:condition="request/dispname"
   tal:replace="python:' - %s '%request.dispname"
  /> - <span tal:replace="config/TRACKER_NAME" />
</title>
<span metal:fill-slot="body_title" tal:omit-tag="true">
  <span tal:omit-tag="true" i18n:translate="" >List of bugs</span>
  <span tal:condition="request/dispname"
   tal:replace="python:' - %s' % request.dispname" />
</span>
<tal:block metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<tal:block tal:define="batch request/batch" tal:condition="context/is_view_ok">
 <table class="list">
  <tr>
   <th tal:condition="request/show/severity" i18n:translate="">Severity</th>
   <th tal:condition="request/show/id" i18n:translate="">ID</th>
   <th tal:condition="request/show/creation" i18n:translate="">Creation</th>
   <th tal:condition="request/show/activity" i18n:translate="">Activity</th>
   <th tal:condition="request/show/actor" i18n:translate="">Actor</th>
   <th tal:condition="request/show/title" i18n:translate="">Title</th>
   <th tal:condition="request/show/components"  i18n:translate="">Components</th>
   <th tal:condition="request/show/versions" i18n:translate="">Versions</th>
   <th tal:condition="request/show/status"    i18n:translate="">Status</th>
   <th tal:condition="request/show/resolution" i18n:translate="">Resolution</th>
   <th tal:condition="request/show/creator" i18n:translate="">Creator</th>
   <th tal:condition="request/show/assignee" i18n:translate="">Assigned&nbsp;To</th>
   <th tal:condition="request/show/keywords" i18n:translate="">Keywords</th>
   <th tal:condition="request/show/dependencies" i18n:translate="">Depends On</th>
   <th tal:condition="request/show/type" i18n:translate="">Type</th>
  </tr>
 <tal:block tal:repeat="i batch" condition="true">
  <tr tal:define="group python:[r[1] for r in request.group]"
      tal:condition="python:group and batch.propchanged(*group)">
   <th tal:attributes="colspan python:len(request.columns)" class="group">
    <tal:block tal:repeat="g group">
     <tal:block tal:content="python:str(i[g]) or '(no %s set)'%g"/>
    </tal:block>
   </th>
  </tr>

  <tr tal:attributes="class python:['even','odd'][repeat['i'].even()]">
   <td tal:condition="request/show/severity"
       tal:content="python:i.severity.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/id" tal:content="i/id">&nbsp;</td>
   <td class="date" tal:condition="request/show/creation"
       tal:content="i/creation/reldate">&nbsp;</td>
   <td class="date" tal:condition="request/show/activity"
       tal:content="i/activity/reldate">&nbsp;</td>
   <td tal:condition="request/show/actor"
       tal:content="python:i.actor.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/title">
    <a tal:attributes="href string:bug${i/id}"
		tal:content="python:str(i.title.plain(hyperlink=0)) or '[no title]'">title</a>
   </td>
   <td tal:condition="request/show/components"
       tal:content="python:i.components.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/versions"
       tal:content="python:i.versions.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/status"
       tal:content="python:i.status.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/resolution"
       tal:content="python:i.resolution.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/creator"
       tal:content="python:i.creator.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/assignee"
       tal:content="python:i.assignee.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/keywords"
       tal:content="python:i.keywords.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/dependencies"
       tal:content="python:i.dependencies.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/type"
       tal:content="python:i.type.plain() or default">&nbsp;</td>
  </tr>

 </tal:block>

 <metal:index define-macro="batch-footer">
 <tr tal:condition="batch">
  <th tal:attributes="colspan python:len(request.columns)">
   <table width="100%">
    <tr class="navigation">
     <th>
      <a tal:define="prev batch/previous" tal:condition="prev"
         tal:attributes="href python:request.indexargs_url(request.classname,
         {'@startwith':prev.first, '@pagesize':prev.size})"
         i18n:translate="">&lt;&lt; previous</a>
      &nbsp;
     </th>
     <th i18n:translate=""><span tal:replace="batch/start" i18n:name="start"
     />..<span tal:replace="python: batch.start + batch.length -1" i18n:name="end"
     /> out of <span tal:replace="batch/sequence_length" i18n:name="total"
     /></th>
     <th>
      <a tal:define="next batch/next" tal:condition="next"
         tal:attributes="href python:request.indexargs_url(request.classname,
         {'@startwith':next.first, '@pagesize':next.size})"
         i18n:translate="">next &gt;&gt;</a>
      &nbsp;
     </th>
    </tr>
   </table>
  </th>
 </tr>
 </metal:index>
</table>
<!--
<a tal:attributes="href python:request.indexargs_url('bug',
            {'@action':'export_csv'})" i18n:translate="">Download as CSV</a>
-->
<form method="get" class="index-controls"
    tal:attributes="action request/classname">

 <table class="form" tal:define="n_sort python:2">
<!--
<tal:block tal:repeat="n python:range(n_sort)" tal:condition="batch">
  <tr tal:define="key python:len(request.sort)>n and request.sort[n]">
   <th>
    <tal:block tal:condition="not:n" i18n:translate="">Sort on:</tal:block>
   </th>
   <td>
    <select tal:attributes="name python:'@sort%d'%n">
     <option value="" i18n:translate="">- nothing -</option>
     <option tal:repeat="col context/properties"
             tal:attributes="value col/_name;
                             selected python:key and col._name == key[1]"
             tal:content="col/_name"
             i18n:translate="">column</option>
    </select>
   </td>
   <th i18n:translate="">Descending:</th>
   <td><input type="checkbox" tal:attributes="name python:'@sortdir%d'%n;
              checked python:key and key[0] == '-'"/>
   </td>
  </tr>
  </tal:block>
  -->
  <tal:block tal:repeat="n python:range(n_sort)" tal:condition="batch">
  <tr tal:define="key python:len(request.group)>n and request.group[n]">
   <th>
    <tal:block tal:condition="not:n" i18n:translate="">Group on:</tal:block>
   </th>
   <td>
    <select tal:attributes="name python:'@group%d'%n">
     <option value="" i18n:translate="">- nothing -</option>
     <option tal:repeat="col context/properties"
             tal:attributes="value col/_name;
                             selected python:key and col._name == key[1]"
             tal:content="col/_name"
             i18n:translate="">column</option>
    </select>
   </td>
   <th i18n:translate="">Descending:</th>
   <td><input type="checkbox" tal:attributes="name python:'@groupdir%d'%n;
              checked python:key and key[0] == '-'"/>
   </td>
  </tr>
  </tal:block>
  <tr><td colspan="4">
              <input type="submit" value="Redisplay" i18n:attributes="value"/>
              <tal:block tal:replace="structure
                python:request.indexargs_form(sort=0, group=0)" />
  </td></tr>
 </table>
</form>

</tal:block>
</tal:block>
</tal:block>

blob
mark :577
data 10747
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title">
<tal:block condition="context/id" i18n:translate=""
 >Bug <span tal:replace="context/id" i18n:name="id"
 />: <span tal:replace="context/title" i18n:name="title"
 /> - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
<tal:block condition="not:context/id" i18n:translate=""
 >New Bug report - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
</title>
<tal:block metal:fill-slot="body_title">
 <span tal:condition="python: not (context.id or context.is_edit_ok())"
  tal:omit-tag="python:1" i18n:translate="">New Bug</span>
 <span tal:condition="python: not context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">New Bug Editing</span>
 <span tal:condition="python: context.id and not context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Bug <tal:x
  replace="context/id" i18n:name="id" /></span>
 <span tal:condition="python: context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Bug<tal:x
  replace="context/id" i18n:name="id" /> Editing</span>
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<div tal:condition="context/is_view_ok">

<form method="POST" name="itemSynopsis"
      onSubmit="return submit_once()" enctype="multipart/form-data"
      tal:attributes="action context/designator">

<fieldset><legend>classification</legend>
<table class="form">
<tr>
 <th class="required" i18n:translate="">Title:</th>
 <td colspan="3" tal:condition="context/title/is_edit_ok"
     tal:content="structure python:context.title.field(size=40)">title</td>
 <td colspan="3" tal:condition="not:context/title/is_edit_ok">
  <span tal:content="structure context/title/plain"/>
  <input type="hidden" name="title" tal:attributes="value context/title">
 </td>
</tr>

<tr>
 <th class="required" i18n:translate="">
   <span tal:condition="context/type/is_edit_ok" 
         tal:replace="structure python:db.bug_type.classhelp('id,name,description',property='type',label='Type')" />
   <span tal:condition="not:context/type/is_edit_ok">Type</span>:
 </th>
 <td tal:content="structure context/type/menu">type</td>
 <th i18n:translate="">
   <span tal:condition="context/severity/is_edit_ok"
         tal:replace="structure python:db.severity.classhelp('id,name,description',property='severity',label='Severity')" />
   <span tal:condition="not:context/severity/is_edit_ok">Severity</span>:
 </th>
 <td tal:content="structure context/severity/menu">severity</td>
</tr>

<tr>
 <th i18n:translate="">
   <span tal:condition="context/components/is_edit_ok" 
         tal:replace="structure python:db.component.classhelp('id,name,description',property='components',label='Components')" />
   <span tal:condition="not:context/components/is_edit_ok">Components</span>:
 </th>
 <td tal:content="structure context/components/menu">components</td>
 <th i18n:translate="">
   <span tal:condition="context/versions/is_edit_ok" 
         tal:replace="structure python:db.version.classhelp('id,name,description',property='versions',label='Versions')" />
   <span tal:condition="not:context/versions/is_edit_ok">Versions</span>:
 </th>
 <td tal:content="structure context/versions/menu">versions</td>
</tr>
</table>
</fieldset>

<fieldset><legend>process</legend>
<table class="form">
<tr tal:condition="context/id">
 <th i18n:translate="">
   <span tal:condition="context/status/is_edit_ok" 
         tal:replace="structure python:db.status.classhelp('id,name,description',property='status', label='Status')" />
   <span tal:condition="not:context/status/is_edit_ok">Status</span>:
 </th>
 <td tal:content="structure context/status/menu">status</td>
 <th i18n:translate="">
   <span tal:condition="context/resolution/is_edit_ok" 
         tal:replace="structure python:db.resolution.classhelp('id,name,description',property='resolution', label='Resolution')" />
   <span tal:condition="not:context/resolution/is_edit_ok">Resolution</span>:
 </th>
 <td tal:content="structure context/resolution/menu">resolution</td>
</tr>

<tr tal:condition="context/id">
 <th>
  <tal:block i18n:translate="">Dependencies</tal:block>:
  <span tal:condition="context/dependencies/is_edit_ok"
        tal:replace="structure python:db.bug.classhelp('id,title', filter='status=0,1', property='dependencies')" />
 </th>
 <td>
  <span tal:replace="structure python:context.dependencies.field(showid=1,size=20)" />
  <span tal:condition="context/dependencies" tal:repeat="d python:context.dependencies.sorted('creation')">
   <br/>View: <a tal:attributes="href string:bug${d/id}" tal:content="d/id"></a>
  </span>
 </td>
 <th i18n:translate="">
  <tal:block i18n:translate="">Superseder</tal:block>:
  <span tal:condition="context/superseder/is_edit_ok"
        tal:replace="structure python:db.bug.classhelp('id,title', filter='status=0,1', property='superseder')" />
 </th>
 <td>
  <span tal:replace="structure python:context.superseder.field(showid=1, size=20)" />
 <span tal:condition="context/superseder">
<!--   <br><span i18n:translate="">View</span>:
     <a tal:repeat="sup context/superseder"
        tal:content="python:sup['id'] + ', '*(not repeat['sup'].end)"
        tal:attributes="href string:bug${sup/id}; title sup/title;"></a> -->
   <br><span i18n:translate="">View</span>:
     <a tal:content="context/superseder/id"
        tal:attributes="href string:bug${context/superseder/id}; title context/superseder/title;"></a> 
  </span> 
 </td>
 </tr>
 <tr>
 <th><tal:block i18n:translate="">Assigned To</tal:block>:</th>
 <td tal:content="structure context/assignee/menu">assignedto menu</td>
 <th><tal:block i18n:translate="">Nosy List</tal:block>:
  <span tal:condition="context/nosy/is_edit_ok"
        tal:replace="structure python:db.user.classhelp('username,realname,address', property='nosy')" />
 </th>
 <td>
  <span tal:replace="structure context/nosy/field" />
 </td>
</tr>
<tr>
 <th>
   <span tal:condition="context/priority/is_edit_ok"
         tal:replace="structure python:db.priority.classhelp('id,name,description',property='priority',label='Priority')" />
   <span tal:condition="not:context/priority/is_edit_ok">Priority</span>:
 </th>
 <td tal:content="structure context/priority/menu">priority</td>
 <th i18n:translate="">Keywords:</th>
 <td tal:content="structure python:context['keywords'].menu(height=5)">keywords</td>


</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">Comment</tal:block>:</th>
 <td colspan="3">
  <textarea tal:content="request/form/@note/value | default"
            name="@note" wrap="hard" rows="10" cols="60"></textarea>
 </td>
</tr>

<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">File</tal:block>:</th>
 <td colspan="3">
   <input type="hidden" name="@link@files" value="file-1">
   <input type="file" name="file-1@content" size="35">
 </td>
</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">File Description</tal:block>:</th>
 <td colspan=3><input type="edit" name="file-1@description" size="40"></td>
</tr>
</table>
</fieldset>
<table class="form">
<tr tal:condition="context/is_edit_ok">
 <td>
  &nbsp;
  <input type="hidden" name="@template" value="item">
  <input type="hidden" name="@required" value="title">
 </td>
 <td colspan=3>
  <span tal:replace="structure context/submit">submit button</span>
  <a tal:condition="context/id" tal:attributes="href context/copy_url"
   i18n:translate="">Make a copy</a>
 </td>
</tr>
</table>
</form>

<p tal:condition="context/id" i18n:translate="">
 Created on <b><tal:x replace="python:context.creation.pretty('%Y-%m-%d %H:%M')" i18n:name="creation" /></b>
 by <b><tal:x replace="context/creator" i18n:name="creator" /></b>,
 last changed <b><tal:x replace="python:context.activity.pretty('%Y-%m-%d %H:%M')" i18n:name="activity" /></b>
 by <b><tal:x replace="context/actor" i18n:name="actor" /></b>.
</p>

<table class="files" tal:condition="context/files">
 <tr><th colspan="5" class="header" i18n:translate="">Files</th></tr>
 <tr>
  <th i18n:translate="">File name</th>
  <th i18n:translate="">Uploaded</th>
  <th i18n:translate="">Description</th>
  <th i18n:translate="">Edit</th>
  <th i18n:translate="">Remove</th>
 </tr>
 <tr tal:repeat="file python:context.files.sorted('creation')">
  <td>
   <a tal:attributes="href file/download_url"
      tal:content="file/name">dld link</a>
  </td>
  <td>
   <span tal:content="file/creator">creator's name</span>,
   <span tal:content="python:file.creation.pretty('%Y-%m-%d %H:%M')">creation date</span>
  </td>
  <td tal:content="file/description" />
  <td><a tal:condition="file/is_edit_ok"
          tal:attributes="href string:file${file/id}">edit</a>
  </td>
  <td>
   <form style="padding:0" tal:condition="file/is_edit_ok"
         tal:attributes="action string:bug${context/id}">
    <input type="hidden" name="@remove@files" tal:attributes="value file/id">
    <input type="hidden" name="@action" value="edit">
    <input type="submit" value="remove" i18n:attributes="value">
   </form>
  </td>
 </tr>
</table>

<table class="messages" tal:condition="context/messages">
 <tr><th colspan="4" class="header" i18n:translate="">Messages</th></tr>
 <tal:block tal:repeat="msg context/messages">
  <tr>
   <th><a tal:attributes="href string:msg${msg/id}"
    i18n:translate="">msg<tal:x replace="msg/id" i18n:name="id" /></a></th>
   <th i18n:translate="">Author: <tal:x replace="python:msg.author.realname.plain()"
       i18n:name="author" /> (<tal:x replace="msg/author"/>)</th>
   <th i18n:translate="">Date: <tal:x replace="python:msg.date.pretty('%Y-%m-%d %H:%M')"
       i18n:name="date" /></th>
   <th>
    <form style="padding:0" tal:condition="msg/is_edit_ok"
          tal:attributes="action string:bug${context/id}">
     <input type="hidden" name="@remove@messages" tal:attributes="value msg/id">
     <input type="hidden" name="@action" value="edit">
     <input type="submit" value="remove" i18n:attributes="value">
    </form>
   </th>
  </tr>
  <tr>
   <td colspan="4" class="content">
    <pre tal:condition="python:msg.content.is_view_ok()"
         tal:content="structure python:utils.localReplace(msg.content.hyperlinked())">content</pre>
   </td>
  </tr>
 </tal:block>
</table>

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</div>

</td>

</tal:block>

blob
mark :578
data 10717
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate="">Bug searching - <span
 i18n:name="tracker" tal:replace="config/TRACKER_NAME" /></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
 i18n:translate="">Bug searching</span>
<td class="content" metal:fill-slot="content">

<form method="get" name="itemSynopsis"
      tal:attributes="action request/classname">
      
<table class="form" tal:define="
   cols python:request.columns or 'id activity title status assignedto'.split();
   sort_on python:request.sort and request.sort[0] or nothing;
   sort_desc python:sort_on and sort_on[0] == '-';
   sort_on python:(sort_on and sort_on[1]) or 'activity';
   group_on python:request.group and request.group[0] or nothing;
   group_desc python:group_on and group_on[0] == '-';
   group_on python:(group_on and group_on[1]) or 'priority';

   search_input templates/page/macros/search_input;
   search_date templates/page/macros/search_date;
   column_input templates/page/macros/column_input;
   sort_input templates/page/macros/sort_input;
   group_input templates/page/macros/group_input;
   search_select templates/page/macros/search_select;
   search_select_translated templates/page/macros/search_select_translated;
   search_multiselect templates/page/macros/search_multiselect;">

<tr>
 <th class="header">&nbsp;</th>
 <th class="header" i18n:translate="">Filter on</th>
 <th class="header" i18n:translate="">Display</th>
 <th class="header" i18n:translate="">Sort on</th>
 <th class="header" i18n:translate="">Group on</th>
</tr>

<tr tal:define="name string:@search_text">
  <th i18n:translate="">All text*:</th>
  <td metal:use-macro="search_input"></td>
  <td>&nbsp;</td>
  <td>&nbsp;</td>
  <td>&nbsp;</td>
</tr>

<tr tal:define="name string:title">
  <th i18n:translate="">Title:</th>
  <td metal:use-macro="search_input"></td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td>&nbsp;</td>
</tr>

<tr tal:define="name string:id">
  <th i18n:translate="">ID:</th>
  <td metal:use-macro="search_input"></td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td>&nbsp;</td>
</tr>

<tr tal:define="name string:creation">
  <th i18n:translate="">Creation Date:</th>
  <td metal:use-macro="search_date"></td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:creator;
                db_klass string:user;
                db_content string:username;">
  <th i18n:translate="">Creator:</th>
  <td metal:use-macro="search_input">
    <option metal:fill-slot="extra_options" i18n:translate=""
            tal:attributes="value request/user/id">created by me</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:activity">
  <th i18n:translate="">Activity:</th>
  <td metal:use-macro="search_date"></td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td>&nbsp;</td>
</tr>

<tr tal:define="name string:actor;
                db_klass string:user;
                db_content string:username;">
  <th i18n:translate="">Last actor:</th>
  <td metal:use-macro="search_input">
    <option metal:fill-slot="extra_options" i18n:translate=""
            tal:attributes="value request/user/id">done by me</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td>&nbsp;</td>
</tr>

<tr tal:define="name string:nosy">
  <th i18n:translate="">Nosy list member:</th>
  <td metal:use-macro="search_input"></td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td>&nbsp;</td>
</tr>

<tr tal:define="name string:type;
                db_klass string:bug_type;
                db_content string:name;">
  <th i18n:translate="">Type:</th>
  <td metal:use-macro="search_select_translated">
    <option metal:fill-slot="extra_options" value="-1" i18n:translate=""
            tal:attributes="selected python:value == '-1'">not selected</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:components;
                db_klass string:component;
                db_content string:name;">
  <th i18n:translate="">Components:</th>
  <td metal:use-macro="search_select_translated">
    <option metal:fill-slot="extra_options" value="-1" i18n:translate=""
            tal:attributes="selected python:value == '-1'">not selected</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:versions;
                db_klass string:version;
                db_content string:name;">
  <th i18n:translate="">Versions:</th>
  <td metal:use-macro="search_select_translated">
    <option metal:fill-slot="extra_options" value="-1" i18n:translate=""
            tal:attributes="selected python:value == '-1'">not selected</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<!--tr tal:define="name string:severity;
                db_klass string:severity;
                db_content string:name;">
  <th i18n:translate="">Severity:</th>
  <td metal:use-macro="search_select_translated">
    <option metal:fill-slot="extra_options" value="-1" i18n:translate=""
            tal:attributes="selected python:value == '-1'">not selected</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr-->

<tr tal:define="name string:dependencies;
                db_klass string:bug;
                db_content string:id;">
  <th i18n:translate="">Depends on:</th>
  <td metal:use-macro="search_input"/>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:assignee;
                db_klass string:user;
                db_content string:username;">
  <th i18n:translate="">Assigned to:</th>
  <td metal:use-macro="search_input">
    <tal:block metal:fill-slot="extra_options">
      <option tal:attributes="value request/user/id"
       i18n:translate="">assigned to me</option>
      <option value="-1" tal:attributes="selected python:value == '-1'"
       i18n:translate="">unassigned</option>
    </tal:block>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:keywords;
                db_klass string:keyword;
                db_content string:name;">
  <th i18n:translate="">Keyword:</th>
  <td metal:use-macro="search_select_translated">
    <option metal:fill-slot="extra_options" value="-1" i18n:translate=""
            tal:attributes="selected python:value == '-1'">not set</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:priority;
                db_klass string:priority;
                db_content string:name;">
  <th i18n:translate="">Priority:</th>
  <td metal:use-macro="search_select_translated">
    <option metal:fill-slot="extra_options" value="-1" i18n:translate=""
            tal:attributes="selected python:value == '-1'">not selected</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:status;
                db_klass string:status;
                db_content string:name;">
  <th i18n:translate="">Status:</th>
  <td metal:use-macro="search_select_translated">
    <tal:block metal:fill-slot="extra_options">
      <option value="-1,1,2" i18n:translate=""
              tal:attributes="selected python:value == '-1,1,2'">not closed</option>
      <option value="-1" i18n:translate=""
              tal:attributes="selected python:value == '-1'">not selected</option>
    </tal:block>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:resolution;
                db_klass string:resolution;
                db_content string:name;">
  <th i18n:translate="">Resolution:</th>
  <td metal:use-macro="search_select_translated"/>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr>
 <th i18n:translate="">No Sort or group:</th>
 <td>&nbsp;</td>
 <td>&nbsp;</td>
 <td><input type="radio" name="@sort" value=""/></td>
 <td><input type="radio" name="@group" value=""/></td>
</tr>

<tr>
<th i18n:translate="">Pagesize:</th>
<td><input name="@pagesize" size="3" value="50"
           tal:attributes="value request/form/@pagesize/value | default"/></td>
</tr>

<tr>
<th i18n:translate="">Start With:</th>
<td><input name="@startwith" size="3" value="0"
           tal:attributes="value request/form/@startwith/value | default"/></td>
</tr>

<tr>
<th i18n:translate="">Sort Descending:</th>
<td><input type="checkbox" name="@sortdir"
           tal:attributes="checked sort_desc"/>
</td>
</tr>

<tr>
<th i18n:translate="">Group Descending:</th>
<td><input type="checkbox" name="@groupdir"
           tal:attributes="checked group_desc"/>
</td>
</tr>

<tr tal:condition="python:request.user.hasPermission('Edit', 'query')">
 <th i18n:translate="">Query name**:</th>
 <td tal:define="value request/form/@queryname/value | nothing">
  <input name="@queryname" tal:attributes="value value"/>
  <input type="hidden" name="@old-queryname" tal:attributes="value value"/>
 </td>
</tr>

<tr>
  <td>
   &nbsp;
   <input type="hidden" name="@action" value="search"/>
  </td>
  <td><input type="submit" value="Search" i18n:attributes="value"/></td>
</tr>

<tr><td>&nbsp;</td>
 <td colspan="4" class="help">
  <span i18n:translate="" tal:omit-tag="true">
   *: The "all text" field will look in message bodies and bug titles
  </span><br>
  <span tal:condition="python:request.user.hasPermission('Edit', 'query')"
   i18n:translate="" tal:omit-tag="true"
  >
   **: If you supply a name, the query will be saved off and available as a
       link in the sidebar
  </span>
 </td>
</tr>
</table>

</form>
</td>

</tal:block>

blob
mark :579
data 15086
         h  6              00     %  F  (                 @                                           5   B   G   E   8                                  ?L9/&{   ;                               ND:0&   @      	            	      XND:0%   A   5   ,            !   <   5bXN=4*!y   A    u@os=p:   KlbXNC9/$z   4}CyAt=K2[olaWMC9.$   AF}Dx@g6   NnjaWMB8.$   GJG|Cv?i6E1\   L   H   G   AEkA8-#   FMIF{Bu>p;j7i6h5`2   OEB7-   =PLHEyAt=o:i6i6i6`2   CKA6   $ROKH}Dx@s=m9i6i6i6   HUJ>   
    N~LH}Ct=l9f6l8i6i6   H                               IF{Bu>p;j7i6   A                               LEyAt>o:i6   (                               NJH~Dx@q<h7                                                                     (       @                                                                      	      %   1   :   A   D   @   9   .   !                                                                                  %0~1.(&n   K   <   #                                                                     	BvA>94/*% |   D   !                                                               OMHC>94/*%s{z   3                                                               WRMHC>94/*   :                                                               [VRMHC=94/   ;                                                               `[VQMHC=83/*%    ,                                                         e`[VQLGC=83.)%   '                                      $   7   A   F   6je`[VQL   Z   N   H   H   H   H   H   H   H   H   H   F   A   6   !             
v>vzBy@xAv?   Hoje`[VQLGB=83.)${   C   !      }DFE|CzBx@   Htojd_[VQLGB=83.)${   9   HHGF~D|CyA   Iusojd_ZUQLGB=83.)$   H   IJIGF}D{B   Muusnid_ZUPLGB=82.)$ud   -KKJHGE}CuR+otuusnid_ZUPKFB=82-($   8MLKIHF~Ep=auuusnid_ZUPKFA<82-(#   <ONLJIGF~DqO*saruusnid_ZUPKFA<72-(#   >POMKJHGE}Dp:bF#e   L   I   H   H   H   H   H   H   HGMKFA<72-("   <QPNMKJHFE|CzBx@v?s=q<o:m8j7i6i6d4dF"pKKFA<72-%   6PQONLKIHF~E|CzAw@u>s=p;n:l8j6i6i6h5dF$pMKFA<72*   .SRPOMLJIGF~D{ByAw?t>r<p;n9k8i6i6i6f3GOJEA<7-   #USRPOMKJHGE}D{Bx@v?t=q<o:m9k7i6i6i6   HTOJE@;-q   XRSQPNLKIHFE|CzBx@u?s=q;o:l8j7i6i6   HYTOJE>   *       U~TRQONLJIGF~D|CyAw@u>s=p;n9l8i6i6   H^YTOJA              SkRRPOMLJIGE}D{ByAw?t>r<p:m9k7i6   Hc^YRM                                                6   H   H   H   H   H   Hx@v?t=q<o:m9j7   H                                                               NLKIHF~E|CzAw@u>s=q;o:l8   H                                                               ONLJIGF~D{CyAw?u>r<p;n9   G                                                               POHGE}D{BxAv?t>r<o:   @                                                               QPIHFE|CzBx@v?s=o;   ,                                                               PQKIHF~D|CzAw@u>m9                                                                  OCPPOMLJIGF~D{ByAt=                                                                          XROMMKJHF~CzBw?\                                                                                                                                  (   0   `          %                                                                                         #   .   6   :   =   B   E   A   =   :   3   +   !                                                                                                                           	      3,s.,+&%#	o   L   @   .                                                                                                               	9C<<:730-)&# `|Z   >                                                                                                         BPFC@=:730-)&# r   >                                                                                                  K3LJGC@=9630-)&"C$a~Y   +   	                                                                                            RPMJGC@=9630-)&"^   9                                                                                               VTPMJGC@=9630,)i   A                                                                                               ZWTPMJFC@=963/,^   G                                                                                               ]ZWTPMIFC@=962/,I   I                                                                                               `]ZWTPMIFC@=962/,)&"   I                                                                                               d`]ZVSPMIFC?<962/,(%"   7                                                                                       gd`]YVSPMIFC?<962/,(%"   +                                                            -   ?   G   I   I   I   7jgd`]YVSPMI   \   P   I   I   I   I   I   I   I   I   I   I   I   I   I   I   I   I   F   ;   '                         j;+u>zBzByAw@v?t>   Imjfc`]YVSOLIFC?<952/,(%"   L   2                 nD%}D~E}C{BzAx@w?u>   Ipmjfc`]YVSOLIFC?<852/,(%!	   O   +              EFE~D|C{ByAx@v?   Itpmjfc`]YVSOLIFB?<852/+(%!   C          DoHGFE}D|CzByAw@   Iuspmjfc`\YVSOLIEB?<852.+(%!a~Y   +   	   IIHGF~E}D{CzBxA   Iuuspmjfc_\YVSOLHEB?<852.+(%!   =   KKJIGFE~D|C{BzA   Ksuuspmjfc_\YVSOLHEB?<852.+(%!   J   HmKJIHGFE~D|C{BS<Yruuusplifc_\YUROLHEB>;852.+'$!
yc   )LLKJIHGFE}D|C_4juuuusolifc_\YUROLHEB>;852.+'$!   2LMLKJIHGF~E}DwA   Pruuuusolifc_\YUROLHEB>;851.+'$!   :NNLKJIHGFE~D|Ce7J`ruuuusolieb_\YUROKHEB>;841.+'$!   <ONMLKJIHGFE~D|Ce7<{Yjruuusolieb_\YURNKHEB>;841.+'$!   <PONMLKJIHGFE}D|Cv?_4   Q   K   I   I   I   I   I   I   I   I   I   I   I   G9YLMKHEB>;841.+'$   <QPONMLKJIHGF~E}C{BzAx@w?u>t=r<q;o:n9l8k7i6i6i6f4f4uS))vVLKHDA>;841-*'"   9PQPONLKJIHGFE~D|C{ByAx@v?u>s=r<p;o:m9l8j7i6i6i6i6i6e3F2[JKHDA>;841-*%   1QQPONMLKJIHGFE~D|C{ByAw@v?t>s=q<p;o:m9l8j7i6i6i6i6i6c1-|TMKHDA>;741-%   )QRQPONMLKJIHGFE}D|CzByAw@v?t>s=q<p;n:m8k7j6i6i6i6i6i6mL'{KNKHDA=:741%   !Q}SRQPONMLKJIHGF~E}C{BzAx@w?u>t=r<q;o:n9l8k7i6i6i6i6i6c1:WQNKHDA=:74%g   M.SRQPONMLKJIHGFE~D|C{ByAx@v?u>s=r<p;o:m9l8j7i6i6i6i6f3   FTQNKGDA=:6   6       SSRQPONMLKJIHGFE}D|CzByAw@v?t>s=q<p;o:m9l8j7i6i6i6i6   IXTQNJGDA=7   $       S}TSRQPONMLKJIHGF~E}D{CzBxAw@u?t>s=q<p:n9m8k7j6i6i6i6   I[XTQNJGDA3n              UTSRQPONLKJIHGFE~D|C{BzAx@w?u>t=r<q;o:n9l8k7i6i6i6   I^[XTQNJGB                      SSRQPONMLKJIHGFE~D|C{ByAx@v?u>s=r<p;o:m9l8j7i6i6   Ia^ZWTQNI;+                           SYRPQPONMLKJIHGFE}D|CzByAw@v?t>s=q<p;n:m9k8j7i6   Ida^ZWROE!                                                                     7   I   I   I   I   I   I   I   I   I   IxAw@u?t>s=q<o:n9l8k7i6   I                                                                                               NLKJIHGFE~D|C{BzAx@w?u>t=r<q;o:n9l8k7   I                                                                                               NMLKJIHGFE~D|C{ByAx@v?u>s=r<p;o:m9l8   I                                                                                               ONMLKJIHGFE}D|CzByAw@v?t>s=q<p;n:m9   I                                                                                               PONc`IHGF~E}C{BzAx@w?u>t=r<q;o:n9   G                                                                                               PONIHGFE~D|C{ByAx@v?u>s=r<p;o:   ?                                                                                               OPOaIHGFE}D|CzByAw@v?t>s=q<n9   2                                                                                               QQPKJIHGFE}D{CzBxAw@u?t>s=l8                                                                                                  RRQ[XLKJIHGF~E}C{BzAx@w?u>r<^3F   
                                                                                               XPQPONMLKJIHGFE~D|C{ByAx@t>j7e                                                                                                          XQOPONMLKJIHGFE}D|CzBw?n<L                                                                                                                          MYOMLLLKJIHED{Bz@x<3                                                                    ?                                                                                                                                                                                                                                                                      
blob
mark :580
data 1299
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate=""
 >List of files - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker" /></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
  i18n:translate="">List of files</span>
<td class="content" metal:fill-slot="content">

<table class="otherinfo" tal:define="batch request/batch">
 <tr><th style="padding-right: 10" i18n:translate="">Download</th>
     <th style="padding-right: 10" i18n:translate="">Descriptoin</th>
     <th style="padding-right: 10" i18n:translate="">Content Type</th>
     <th style="padding-right: 10" i18n:translate="">Uploaded By</th>
     <th style="padding-right: 10" i18n:translate="">Date</th>
 </tr>
 <tr tal:repeat="file batch" tal:attributes="class python:['normal', 'alt'][repeat['file'].index%6/3]">
  <td>
   <a tal:attributes="href string:file${file/id}/${file/name}"
      tal:content="file/name">dld link</a>
  </td>
  <td tal:content="file/description">description</td>
  <td tal:content="file/type">content type</td>
  <td tal:content="file/creator">creator's name</td>
  <td tal:content="file/creation">creation date</td>
 </tr>

 <metal:block use-macro="templates/issue.index/macros/batch-footer" />

</table>

</td>

</tal:block>

blob
mark :581
data 2995
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate="">File display - <span
 i18n:name="tracker" tal:replace="config/TRACKER_NAME" /></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
 i18n:translate="">File display</span>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<form method="POST" onSubmit="return submit_once()"
      enctype="multipart/form-data" tal:condition="context/is_view_ok"
      tal:attributes="action context/designator">

<table class="form">
 <tr>
  <th i18n:translate="">Name</th>
  <td tal:content="structure context/name/field"></td>
 </tr>
 <tr>
  <th i18n:translate="">Description</th>
  <td tal:content="structure context/description/field"></td>
 </tr>
 <tr>
  <th i18n:translate="">Content Type</th>
  <td tal:content="structure context/type/field"/>
  <td style="border: none" tal:condition="python: context.is_edit_ok()">Please note that
  for security reasons, it's not permitted to set content type to <i>text/html</i>.</td>
 </tr>
 <tr tal:condition="python:context.is_edit_ok()">
  <td>
   &nbsp;
   <input type="hidden" name="@template" value="item">
   <input type="hidden" name="@required" value="name,type">
   <input type="hidden" name="@multilink"
          tal:condition="python:request.form.has_key('@multilink')"
          tal:attributes="value request/form/@multilink/value">
  </td>
  <td tal:content="structure context/submit">submit button here</td>
 </tr>
</table>
</form>

<!--<p tal:condition="python:utils.sb_is_spam(context)" class="error-message">
   File has been classified as spam.</p>-->

<a tal:condition="python:context.id and context.content.is_view_ok()"
 tal:attributes="href string:file${context/id}/${context/name}"
 i18n:translate="">download</a>

<!--<p tal:condition="python:context.id and not context.content.is_view_ok()">
   Files classified as spam are not available for download by
   unathorized users. If you think the file has been misclassified,
   please login and click on the button for reclassification.
</p>-->


<!--     <form method="POST" onSubmit="return submit_once()"
       enctype="multipart/form-data"
       tal:attributes="action context/designator"
       tal:condition="python:request.user.hasPermission('SB: May Classify')">
 
      <input type="hidden" name="@action" value="spambayes_classify">
      <input type="submit" name="trainspam" value="Mark as SPAM" i18n:attributes="value">
      <input type="submit" name="trainham" value="Mark as HAM (not SPAM)" i18n:attributes="value">
     </form>-->

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</td>

</tal:block>

blob
mark :582
data 488
@import url(style.css);

body { padding: 0;}
body > .header,
body > .footer
{
  margin: 0;
}
body .content { width: auto;}
.header h1 { font-size: 110%; }

table.classhelp th
{
  border-top: 1px solid #afafaf;
  border-bottom: 1px solid #afafaf;
  empty-cells: show;
  text-align: left;
  vertical-align: middle;
  white-space: nowrap;
}

table.classhelp td
{
  border-bottom: 1px solid #efefef;
  empty-cells: show;
  text-align: left;
  vertical-align: middle;
  white-space: nowrap;
}

blob
mark :583
data 2943
<tal:block metal:define-macro="frame">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html tal:define="what python:request.form.getvalue('property', request.classname);
                  form request/form/form/value;
                  field request/form/property/value">
<head>
  <meta http-equiv="Content-Type"
        tal:attributes="content string:text/html;; charset=${request/client/charset}" />
  <title i18n:translate="">
    <tal:x i18n:name="what" tal:content="what" i18n:translate="" />
    help - <span i18n:name="tracker" tal:replace="config/TRACKER_NAME" />
  </title>
  <script language="Javascript" type="text/javascript" tal:content="structure string:<!--
    // this is the name of the field in the original form that we're working on
    form  = window.opener.document.${form};
    field  = '${field}';
    //-->">
  </script>
  <link rel="stylesheet" type="text/css" href="@@file/help.css" />
  <script src="@@file/help_controls.js" type="text/javascript"></script>
  <metal:x define-slot="more-javascript" />
</head>
<body onload="resetList();">
  <div class="header">
    <h1>Roundup Issue Tracker: Help - <tal:block tal:content="what">item</tal:block></h1>
  </div>
  <div class="content">
    <tal:block metal:define-slot="content">Page content goes here</tal:block>
  </div> <!-- content -->
  <div class="footer">
    <tal:block metal:define-slot="footer"></tal:block>
  </div> <!-- footer -->
</body>
</html>
</tal:block>

<!-- legend for helper search results -->
<thead>
<tr metal:define-macro="legend">
  <th><b>x</b></th>
  <th tal:repeat="prop props" tal:content="prop" i18n:translate=""></th>
</tr>
</thead>

<table width="100%"
       metal:define-macro="batch_navi"
       tal:define="prev batch/previous;
                   next batch/next;"
       tal:condition="python:prev or next">
  <tr class="navigation">
   <th width="30%">
    <a tal:condition="prev"
       tal:attributes="href python:request.indexargs_url(request.classname, {'@template':'help-list', 'property': property, 'properties': request.form['properties'].value, 'form': request.form['form'].value, '@startwith':prev.first, '@pagesize':prev.size})"
       i18n:translate="" >&lt;&lt; previous</a>
    &nbsp;
   </th>
   <th i18n:translate="" width="40%"><span tal:replace="batch/start" i18n:name="start"
    />..<span tal:replace="python: batch.start + batch.length -1" i18n:name="end"
    /> out of <span tal:replace="batch/sequence_length" i18n:name="total"
    />
   </th>
   <th width="30%">
    <a tal:condition="next"
       tal:attributes="href python:request.indexargs_url(request.classname, {'@template':'help-list', 'property': property, 'properties': request.form['properties'].value, 'form': request.form['form'].value, '@startwith':next.first, '@pagesize':next.size})"
       i18n:translate="" >next &gt;&gt;</a>
    &nbsp;
   </th>
  </tr>
</table>

blob
mark :584
data 8436
// initial values for either Nosy, Superseder, Topic and Waiting On,
// depending on which has called
original_field = form[field].value;

// Some browsers (ok, IE) don't define the "undefined" variable.
undefined = document.geez_IE_is_really_friggin_annoying;

function trim(value) {
  var temp = value;
  var obj = /^(\s*)([\W\w]*)(\b\s*$)/;
  if (obj.test(temp)) { temp = temp.replace(obj, '$2'); }
  var obj = /  /g;
  while (temp.match(obj)) { temp = temp.replace(obj, " "); }
  return temp;
}

function determineList() {
     // generate a comma-separated list of the checked items
     var list = new String('');

     // either a checkbox object or an array of checkboxes
     var check = document.frm_help.check;

     if ((check.length == undefined) && (check.checked != undefined)) {
         // only one checkbox on page
         if (check.checked) {
             list = check.value;
         }
     } else {
         // array of checkboxes
         for (box=0; box < check.length; box++) {
             if (check[box].checked) {
                 if (list.length == 0) {
                     separator = '';
                 }
                 else {
                     separator = ',';
                 }
                 // we used to use an Array and push / join, but IE5.0 sux
                 list = list + separator + check[box].value;
             }
         }
     }
     return list;
}

/**
 * update the field in the opening window;
 * the text_field variable must be set in the calling page
 */
function updateOpener() {
  // write back to opener window
  if (document.frm_help.check==undefined) { return; }
  form[field].value = text_field.value;
}

function updateList() {
  // write back to opener window
  if (document.frm_help.check==undefined) { return; }
  form[field].value = determineList();
}

function updatePreview() {
  // update the preview box
  if (document.frm_help.check==undefined) { return; }
  writePreview(determineList());
}

function clearList() {
  // uncheck all checkboxes
  if (document.frm_help.check==undefined) { return; }
  for (box=0; box < document.frm_help.check.length; box++) {
      document.frm_help.check[box].checked = false;
  }
}

function reviseList_framed(form, textfield) {
  // update the checkboxes based on the preview field
  // alert('reviseList_framed')
  // alert(form)
  if (form.check==undefined)
      return;
  // alert(textfield)
  var to_check;
  var list = textfield.value.split(",");
  if (form.check.length==undefined) {
      check = form.check;
      to_check = false;
      for (val in list) {
          if (check.value==trim(list[val])) {
              to_check = true;
              break;
          }
      }
      check.checked = to_check;
  } else {
    for (box=0; box < form.check.length; box++) {
      check = form.check[box];
      to_check = false;
      for (val in list) {
          if (check.value==trim(list[val])) {
              to_check = true;
              break;
          }
      }
      check.checked = to_check;
    }
  }
}

function reviseList(vals) {
  // update the checkboxes based on the preview field
  if (document.frm_help.check==undefined) { return; }
  var to_check;
  var list = vals.split(",");
  if (document.frm_help.check.length==undefined) {
      check = document.frm_help.check;
      to_check = false;
      for (val in list) {
          if (check.value==trim(list[val])) {
              to_check = true;
              break;
          }
      }
      check.checked = to_check;
  } else {
    for (box=0; box < document.frm_help.check.length; box++) {
      check = document.frm_help.check[box];
      to_check = false;
      for (val in list) {
          if (check.value==trim(list[val])) {
              to_check = true;
              break;
          }
      }
      check.checked = to_check;
    }
  }
}

function resetList() {
  // reset preview and check boxes to initial values
  if (document.frm_help.check==undefined) { return; }
  writePreview(original_field);
  reviseList(original_field);
}

function writePreview(val) {
   // writes a value to the text_preview
   document.frm_help.text_preview.value = val;
}

function focusField(name) {
    for(i=0; i < document.forms.length; ++i) {
      var obj = document.forms[i].elements[name];
      if (obj && obj.focus) {obj.focus();}
    }
}

function selectField(name) {
    for(i=0; i < document.forms.length; ++i) {
      var obj = document.forms[i].elements[name];
      if (obj && obj.focus){obj.focus();}
      if (obj && obj.select){obj.select();}
    }
}

function checkRequiredFields(fields)
{
    var bonk='';
    var res='';
    var argv = checkRequiredFields.arguments;
    var argc = argv.length;
    var input = '';
    var val='';

    for (var i=0; i < argc; i++) {
        fi = argv[i];
        input = document.getElementById(fi);
        if (input) {
            val = input.value
            if (val == '' || val == '-1' || val == -1) {
                if (res == '') {
                    res = fi;
                    bonk = input;
                } else {
                    res += ', '+fi;
                }
            }
        } else {
            alert('Field with id='+fi+' not found!')
        }
    }
    if (res == '') {
        return submit_once();
    } else {
        alert('Missing value here ('+res+')!');
        if (window.event && window.event.returnvalue) {
            event.returnValue = 0;    // work-around for IE
        }
        bonk.focus();
        return false;
    }
}

/**
 * seeks the given value (2nd argument)
 * in the value of the given input element (1st argument),
 * which is considered a list of values, separated by commas
 */
function has_value(input, val)
{
    var actval = input.value
    var arr = feld.value.split(',');
    var max = arr.length;
    for (i=0;i<max;i++) {
        if (trim(arr[i]) == val) {
            return true
        }
    }
    return false
}

/**
 * Switch Value:
 * change the value of the given input field (might be of type text or hidden),
 * adding or removing the value of the given checkbox field (might be a radio
 * button as well)
 *
 * This function doesn't care whether or not the checkboxes of all values of
 * interest are present; but of course it doesn't have total control of the
 * text field.
 */
function switch_val(text, check)
{
    var switched_val = check.value
    var arr = text.value.split(',')
    var max = arr.length
    if (check.checked) {
        for (i=0; i<max; i++) {
            if (trim(arr[i]) == switched_val) {
                return
            }
        }
	if (text.value)
            text.value = text.value+','+switched_val
	else
            text.value = switched_val
    } else {
        var neu = ''
	var changed = false
        for (i=0; i<max; i++) {
            if (trim(arr[i]) == switched_val) {
                changed=true
            } else {
                neu = neu+','+trim(arr[i])
            }
        }
        if (changed) {
            text.value = neu.substr(1)
        }
    }
}

/**
 * append the given value (2nd argument) to an input field
 * (1st argument) which contains comma-separated values;
 * see --> remove_val()
 *
 * This will work nicely even for batched lists
 */
function append_val(name, val)
{
    var feld = document.itemSynopsis[name];
    var actval = feld.value;
    if (actval == '') {
        feld.value = val
    } else {
        var arr = feld.value.split(',');
        var max = arr.length;
        for (i=0;i<max;i++) {
            if (trim(arr[i]) == val) {
                return
            }
        }
        feld.value = actval+','+val
    }
}

/**
 * remove the given value (2nd argument) from the comma-separated values
 * of the given input element (1st argument); see --> append_val()
 */
function remove_val(name, val)
{
    var feld = document.itemSynopsis[name];
    var actval = feld.value;
    var changed=false;
    if (actval == '') {
	return
    } else {
        var arr = feld.value.split(',');
        var max = arr.length;
        var neu = ''
        for (i=0;i<max;i++) {
            if (trim(arr[i]) == val) {
                changed=true
            } else {
                neu = neu+','+trim(arr[i])
            }
        }
        if (changed) {
            feld.value = neu.substr(1)
        }
    }
}

/**
 * give the focus to the element given by id
 */
function focus2id(name)
{
    document.getElementById(name).focus();
}

blob
mark :585
data 772
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate="">List of classes - <span
 i18n:name="tracker" tal:replace="config/TRACKER_NAME" /></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
 i18n:translate="">List of classes</span>
<td class="content" metal:fill-slot="content">
<table class="classlist">

<tal:block tal:repeat="cl db/classes">
 <tr>
  <th class="header" colspan="2" align="left">
   <a tal:attributes="href string:${cl/classname}"
      tal:content="python:cl.classname.capitalize()">classname</a>
  </th>
 </tr>
 <tr tal:repeat="prop cl/properties">
  <th tal:content="prop/_name">name</th>
  <td tal:content="prop/_prop">type</td>
 </tr>
</tal:block>

</table>
</td>

</tal:block>

blob
mark :586
data 483
<!--
 This is the default body that is displayed when people visit the
 tracker. The tag below lists the currently open issues. You may
 replace it with a greeting message, or a different list of issues or
 whatever. It's a good idea to have the issues on the front page though
-->
<span tal:replace="structure python:db.bug.renderWith('index',
    sort=[('-', 'activity')], filter=['status'],
    columns=['activity','title','creator'],
    filterspec={'status':['1','2','4']})" />

blob
mark :587
data 120763
/*!
 * jQuery JavaScript Library v1.3.2
 * http://jquery.com/
 *
 * Copyright (c) 2009 John Resig
 * Dual licensed under the MIT and GPL licenses.
 * http://docs.jquery.com/License
 *
 * Date: 2009-02-19 17:34:21 -0500 (Thu, 19 Feb 2009)
 * Revision: 6246
 */
(function(){

var 
	// Will speed up references to window, and allows munging its name.
	window = this,
	// Will speed up references to undefined, and allows munging its name.
	undefined,
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,
	// Map over the $ in case of overwrite
	_$ = window.$,

	jQuery = window.jQuery = window.$ = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context );
	},

	// A simple way to check for HTML strings or ID strings
	// (both of which we optimize for)
	quickExpr = /^[^<]*(<(.|\s)+>)[^>]*$|^#([\w-]+)$/,
	// Is it a simple selector
	isSimple = /^.[^:#\[\.,]*$/;

jQuery.fn = jQuery.prototype = {
	init: function( selector, context ) {
		// Make sure that a selection was provided
		selector = selector || document;

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this[0] = selector;
			this.length = 1;
			this.context = selector;
			return this;
		}
		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			var match = quickExpr.exec( selector );

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] )
					selector = jQuery.clean( [ match[1] ], context );

				// HANDLE: $("#id")
				else {
					var elem = document.getElementById( match[3] );

					// Handle the case where IE and Opera return items
					// by name instead of ID
					if ( elem && elem.id != match[3] )
						return jQuery().find( selector );

					// Otherwise, we inject the element directly into the jQuery object
					var ret = jQuery( elem || [] );
					ret.context = document;
					ret.selector = selector;
					return ret;
				}

			// HANDLE: $(expr, [context])
			// (which is just equivalent to: $(content).find(expr)
			} else
				return jQuery( context ).find( selector );

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) )
			return jQuery( document ).ready( selector );

		// Make sure that old selector state is passed along
		if ( selector.selector && selector.context ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return this.setArray(jQuery.isArray( selector ) ?
			selector :
			jQuery.makeArray(selector));
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.3.2",

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num === undefined ?

			// Return a 'clean' array
			Array.prototype.slice.call( this ) :

			// Return just the object
			this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = jQuery( elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" )
			ret.selector = this.selector + (this.selector ? " " : "") + selector;
		else if ( name )
			ret.selector = this.selector + "." + name + "(" + selector + ")";

		// Return the newly-formed element set
		return ret;
	},

	// Force the current matched set of elements to become
	// the specified array of elements (destroying the stack in the process)
	// You should use pushStack() in order to do this, but maintain the stack
	setArray: function( elems ) {
		// Resetting the length to 0, then using the native Array push
		// is a super-fast way to populate an object with array-like properties
		this.length = 0;
		Array.prototype.push.apply( this, elems );

		return this;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {
		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem && elem.jquery ? elem[0] : elem
		, this );
	},

	attr: function( name, value, type ) {
		var options = name;

		// Look for the case where we're accessing a style value
		if ( typeof name === "string" )
			if ( value === undefined )
				return this[0] && jQuery[ type || "attr" ]( this[0], name );

			else {
				options = {};
				options[ name ] = value;
			}

		// Check to see if we're setting style values
		return this.each(function(i){
			// Set all the styles
			for ( name in options )
				jQuery.attr(
					type ?
						this.style :
						this,
					name, jQuery.prop( this, options[ name ], type, i, name )
				);
		});
	},

	css: function( key, value ) {
		// ignore negative width and height values
		if ( (key == 'width' || key == 'height') && parseFloat(value) < 0 )
			value = undefined;
		return this.attr( key, value, "curCSS" );
	},

	text: function( text ) {
		if ( typeof text !== "object" && text != null )
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );

		var ret = "";

		jQuery.each( text || this, function(){
			jQuery.each( this.childNodes, function(){
				if ( this.nodeType != 8 )
					ret += this.nodeType != 1 ?
						this.nodeValue :
						jQuery.fn.text( [ this ] );
			});
		});

		return ret;
	},

	wrapAll: function( html ) {
		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).clone();

			if ( this[0].parentNode )
				wrap.insertBefore( this[0] );

			wrap.map(function(){
				var elem = this;

				while ( elem.firstChild )
					elem = elem.firstChild;

				return elem;
			}).append(this);
		}

		return this;
	},

	wrapInner: function( html ) {
		return this.each(function(){
			jQuery( this ).contents().wrapAll( html );
		});
	},

	wrap: function( html ) {
		return this.each(function(){
			jQuery( this ).wrapAll( html );
		});
	},

	append: function() {
		return this.domManip(arguments, true, function(elem){
			if (this.nodeType == 1)
				this.appendChild( elem );
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function(elem){
			if (this.nodeType == 1)
				this.insertBefore( elem, this.firstChild );
		});
	},

	before: function() {
		return this.domManip(arguments, false, function(elem){
			this.parentNode.insertBefore( elem, this );
		});
	},

	after: function() {
		return this.domManip(arguments, false, function(elem){
			this.parentNode.insertBefore( elem, this.nextSibling );
		});
	},

	end: function() {
		return this.prevObject || jQuery( [] );
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: [].push,
	sort: [].sort,
	splice: [].splice,

	find: function( selector ) {
		if ( this.length === 1 ) {
			var ret = this.pushStack( [], "find", selector );
			ret.length = 0;
			jQuery.find( selector, this[0], ret );
			return ret;
		} else {
			return this.pushStack( jQuery.unique(jQuery.map(this, function(elem){
				return jQuery.find( selector, elem );
			})), "find", selector );
		}
	},

	clone: function( events ) {
		// Do the clone
		var ret = this.map(function(){
			if ( !jQuery.support.noCloneEvent && !jQuery.isXMLDoc(this) ) {
				// IE copies events bound via attachEvent when
				// using cloneNode. Calling detachEvent on the
				// clone will also remove the events from the orignal
				// In order to get around this, we use innerHTML.
				// Unfortunately, this means some modifications to
				// attributes in IE that are actually only stored
				// as properties will not be copied (such as the
				// the name attribute on an input).
				var html = this.outerHTML;
				if ( !html ) {
					var div = this.ownerDocument.createElement("div");
					div.appendChild( this.cloneNode(true) );
					html = div.innerHTML;
				}

				return jQuery.clean([html.replace(/ jQuery\d+="(?:\d+|null)"/g, "").replace(/^\s*/, "")])[0];
			} else
				return this.cloneNode(true);
		});

		// Copy the events from the original to the clone
		if ( events === true ) {
			var orig = this.find("*").andSelf(), i = 0;

			ret.find("*").andSelf().each(function(){
				if ( this.nodeName !== orig[i].nodeName )
					return;

				var events = jQuery.data( orig[i], "events" );

				for ( var type in events ) {
					for ( var handler in events[ type ] ) {
						jQuery.event.add( this, type, events[ type ][ handler ], events[ type ][ handler ].data );
					}
				}

				i++;
			});
		}

		// Return the cloned set
		return ret;
	},

	filter: function( selector ) {
		return this.pushStack(
			jQuery.isFunction( selector ) &&
			jQuery.grep(this, function(elem, i){
				return selector.call( elem, i );
			}) ||

			jQuery.multiFilter( selector, jQuery.grep(this, function(elem){
				return elem.nodeType === 1;
			}) ), "filter", selector );
	},

	closest: function( selector ) {
		var pos = jQuery.expr.match.POS.test( selector ) ? jQuery(selector) : null,
			closer = 0;

		return this.map(function(){
			var cur = this;
			while ( cur && cur.ownerDocument ) {
				if ( pos ? pos.index(cur) > -1 : jQuery(cur).is(selector) ) {
					jQuery.data(cur, "closest", closer);
					return cur;
				}
				cur = cur.parentNode;
				closer++;
			}
		});
	},

	not: function( selector ) {
		if ( typeof selector === "string" )
			// test special case where just one selector is passed in
			if ( isSimple.test( selector ) )
				return this.pushStack( jQuery.multiFilter( selector, this, true ), "not", selector );
			else
				selector = jQuery.multiFilter( selector, this );

		var isArrayLike = selector.length && selector[selector.length - 1] !== undefined && !selector.nodeType;
		return this.filter(function() {
			return isArrayLike ? jQuery.inArray( this, selector ) < 0 : this != selector;
		});
	},

	add: function( selector ) {
		return this.pushStack( jQuery.unique( jQuery.merge(
			this.get(),
			typeof selector === "string" ?
				jQuery( selector ) :
				jQuery.makeArray( selector )
		)));
	},

	is: function( selector ) {
		return !!selector && jQuery.multiFilter( selector, this ).length > 0;
	},

	hasClass: function( selector ) {
		return !!selector && this.is( "." + selector );
	},

	val: function( value ) {
		if ( value === undefined ) {			
			var elem = this[0];

			if ( elem ) {
				if( jQuery.nodeName( elem, 'option' ) )
					return (elem.attributes.value || {}).specified ? elem.value : elem.text;
				
				// We need to handle select boxes special
				if ( jQuery.nodeName( elem, "select" ) ) {
					var index = elem.selectedIndex,
						values = [],
						options = elem.options,
						one = elem.type == "select-one";

					// Nothing was selected
					if ( index < 0 )
						return null;

					// Loop through all the selected options
					for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {
						var option = options[ i ];

						if ( option.selected ) {
							// Get the specifc value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if ( one )
								return value;

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;				
				}

				// Everything else, we just grab the value
				return (elem.value || "").replace(/\r/g, "");

			}

			return undefined;
		}

		if ( typeof value === "number" )
			value += '';

		return this.each(function(){
			if ( this.nodeType != 1 )
				return;

			if ( jQuery.isArray(value) && /radio|checkbox/.test( this.type ) )
				this.checked = (jQuery.inArray(this.value, value) >= 0 ||
					jQuery.inArray(this.name, value) >= 0);

			else if ( jQuery.nodeName( this, "select" ) ) {
				var values = jQuery.makeArray(value);

				jQuery( "option", this ).each(function(){
					this.selected = (jQuery.inArray( this.value, values ) >= 0 ||
						jQuery.inArray( this.text, values ) >= 0);
				});

				if ( !values.length )
					this.selectedIndex = -1;

			} else
				this.value = value;
		});
	},

	html: function( value ) {
		return value === undefined ?
			(this[0] ?
				this[0].innerHTML.replace(/ jQuery\d+="(?:\d+|null)"/g, "") :
				null) :
			this.empty().append( value );
	},

	replaceWith: function( value ) {
		return this.after( value ).remove();
	},

	eq: function( i ) {
		return this.slice( i, +i + 1 );
	},

	slice: function() {
		return this.pushStack( Array.prototype.slice.apply( this, arguments ),
			"slice", Array.prototype.slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function(elem, i){
			return callback.call( elem, i, elem );
		}));
	},

	andSelf: function() {
		return this.add( this.prevObject );
	},

	domManip: function( args, table, callback ) {
		if ( this[0] ) {
			var fragment = (this[0].ownerDocument || this[0]).createDocumentFragment(),
				scripts = jQuery.clean( args, (this[0].ownerDocument || this[0]), fragment ),
				first = fragment.firstChild;

			if ( first )
				for ( var i = 0, l = this.length; i < l; i++ )
					callback.call( root(this[i], first), this.length > 1 || i > 0 ?
							fragment.cloneNode(true) : fragment );
		
			if ( scripts )
				jQuery.each( scripts, evalScript );
		}

		return this;
		
		function root( elem, cur ) {
			return table && jQuery.nodeName(elem, "table") && jQuery.nodeName(cur, "tr") ?
				(elem.getElementsByTagName("tbody")[0] ||
				elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
				elem;
		}
	}
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

function evalScript( i, elem ) {
	if ( elem.src )
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});

	else
		jQuery.globalEval( elem.text || elem.textContent || elem.innerHTML || "" );

	if ( elem.parentNode )
		elem.parentNode.removeChild( elem );
}

function now(){
	return +new Date;
}

jQuery.extend = jQuery.fn.extend = function() {
	// copy reference to target object
	var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) )
		target = {};

	// extend jQuery itself if only one argument is passed
	if ( length == i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ )
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null )
			// Extend the base object
			for ( var name in options ) {
				var src = target[ name ], copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy )
					continue;

				// Recurse if we're merging object values
				if ( deep && copy && typeof copy === "object" && !copy.nodeType )
					target[ name ] = jQuery.extend( deep, 
						// Never move original objects, clone them
						src || ( copy.length != null ? [ ] : { } )
					, copy );

				// Don't bring in undefined values
				else if ( copy !== undefined )
					target[ name ] = copy;

			}

	// Return the modified object
	return target;
};

// exclude the following css properties to add px
var	exclude = /z-?index|font-?weight|opacity|zoom|line-?height/i,
	// cache defaultView
	defaultView = document.defaultView || {},
	toString = Object.prototype.toString;

jQuery.extend({
	noConflict: function( deep ) {
		window.$ = _$;

		if ( deep )
			window.jQuery = _jQuery;

		return jQuery;
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return toString.call(obj) === "[object Function]";
	},

	isArray: function( obj ) {
		return toString.call(obj) === "[object Array]";
	},

	// check if an element is in a (or is an) XML document
	isXMLDoc: function( elem ) {
		return elem.nodeType === 9 && elem.documentElement.nodeName !== "HTML" ||
			!!elem.ownerDocument && jQuery.isXMLDoc( elem.ownerDocument );
	},

	// Evalulates a script in a global context
	globalEval: function( data ) {
		if ( data && /\S/.test(data) ) {
			// Inspired by code by Andrea Giammarchi
			// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html
			var head = document.getElementsByTagName("head")[0] || document.documentElement,
				script = document.createElement("script");

			script.type = "text/javascript";
			if ( jQuery.support.scriptEval )
				script.appendChild( document.createTextNode( data ) );
			else
				script.text = data;

			// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
			// This arises when a base node is used (#2709).
			head.insertBefore( script, head.firstChild );
			head.removeChild( script );
		}
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() == name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0, length = object.length;

		if ( args ) {
			if ( length === undefined ) {
				for ( name in object )
					if ( callback.apply( object[ name ], args ) === false )
						break;
			} else
				for ( ; i < length; )
					if ( callback.apply( object[ i++ ], args ) === false )
						break;

		// A special, fast, case for the most common use of each
		} else {
			if ( length === undefined ) {
				for ( name in object )
					if ( callback.call( object[ name ], name, object[ name ] ) === false )
						break;
			} else
				for ( var value = object[0];
					i < length && callback.call( value, i, value ) !== false; value = object[++i] ){}
		}

		return object;
	},

	prop: function( elem, value, type, i, name ) {
		// Handle executable functions
		if ( jQuery.isFunction( value ) )
			value = value.call( elem, i );

		// Handle passing in a number to a CSS property
		return typeof value === "number" && type == "curCSS" && !exclude.test( name ) ?
			value + "px" :
			value;
	},

	className: {
		// internal only, use addClass("class")
		add: function( elem, classNames ) {
			jQuery.each((classNames || "").split(/\s+/), function(i, className){
				if ( elem.nodeType == 1 && !jQuery.className.has( elem.className, className ) )
					elem.className += (elem.className ? " " : "") + className;
			});
		},

		// internal only, use removeClass("class")
		remove: function( elem, classNames ) {
			if (elem.nodeType == 1)
				elem.className = classNames !== undefined ?
					jQuery.grep(elem.className.split(/\s+/), function(className){
						return !jQuery.className.has( classNames, className );
					}).join(" ") :
					"";
		},

		// internal only, use hasClass("class")
		has: function( elem, className ) {
			return elem && jQuery.inArray( className, (elem.className || elem).toString().split(/\s+/) ) > -1;
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};
		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( var name in options )
			elem.style[ name ] = old[ name ];
	},

	css: function( elem, name, force, extra ) {
		if ( name == "width" || name == "height" ) {
			var val, props = { position: "absolute", visibility: "hidden", display:"block" }, which = name == "width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ];

			function getWH() {
				val = name == "width" ? elem.offsetWidth : elem.offsetHeight;

				if ( extra === "border" )
					return;

				jQuery.each( which, function() {
					if ( !extra )
						val -= parseFloat(jQuery.curCSS( elem, "padding" + this, true)) || 0;
					if ( extra === "margin" )
						val += parseFloat(jQuery.curCSS( elem, "margin" + this, true)) || 0;
					else
						val -= parseFloat(jQuery.curCSS( elem, "border" + this + "Width", true)) || 0;
				});
			}

			if ( elem.offsetWidth !== 0 )
				getWH();
			else
				jQuery.swap( elem, props, getWH );

			return Math.max(0, Math.round(val));
		}

		return jQuery.curCSS( elem, name, force );
	},

	curCSS: function( elem, name, force ) {
		var ret, style = elem.style;

		// We need to handle opacity special in IE
		if ( name == "opacity" && !jQuery.support.opacity ) {
			ret = jQuery.attr( style, "opacity" );

			return ret == "" ?
				"1" :
				ret;
		}

		// Make sure we're using the right name for getting the float value
		if ( name.match( /float/i ) )
			name = styleFloat;

		if ( !force && style && style[ name ] )
			ret = style[ name ];

		else if ( defaultView.getComputedStyle ) {

			// Only "float" is needed here
			if ( name.match( /float/i ) )
				name = "float";

			name = name.replace( /([A-Z])/g, "-$1" ).toLowerCase();

			var computedStyle = defaultView.getComputedStyle( elem, null );

			if ( computedStyle )
				ret = computedStyle.getPropertyValue( name );

			// We should always get a number back from opacity
			if ( name == "opacity" && ret == "" )
				ret = "1";

		} else if ( elem.currentStyle ) {
			var camelCase = name.replace(/\-(\w)/g, function(all, letter){
				return letter.toUpperCase();
			});

			ret = elem.currentStyle[ name ] || elem.currentStyle[ camelCase ];

			// From the awesome hack by Dean Edwards
			// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

			// If we're not dealing with a regular pixel number
			// but a number that has a weird ending, we need to convert it to pixels
			if ( !/^\d+(px)?$/i.test( ret ) && /^\d/.test( ret ) ) {
				// Remember the original values
				var left = style.left, rsLeft = elem.runtimeStyle.left;

				// Put in the new values to get a computed value out
				elem.runtimeStyle.left = elem.currentStyle.left;
				style.left = ret || 0;
				ret = style.pixelLeft + "px";

				// Revert the changed values
				style.left = left;
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret;
	},

	clean: function( elems, context, fragment ) {
		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" )
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;

		// If a single string is passed in and it's a single tag
		// just do a createElement and skip the rest
		if ( !fragment && elems.length === 1 && typeof elems[0] === "string" ) {
			var match = /^<(\w+)\s*\/?>$/.exec(elems[0]);
			if ( match )
				return [ context.createElement( match[1] ) ];
		}

		var ret = [], scripts = [], div = context.createElement("div");

		jQuery.each(elems, function(i, elem){
			if ( typeof elem === "number" )
				elem += '';

			if ( !elem )
				return;

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				// Fix "XHTML"-style tags in all browsers
				elem = elem.replace(/(<(\w+)[^>]*?)\/>/g, function(all, front, tag){
					return tag.match(/^(abbr|br|col|img|input|link|meta|param|hr|area|embed)$/i) ?
						all :
						front + "></" + tag + ">";
				});

				// Trim whitespace, otherwise indexOf won't work as expected
				var tags = elem.replace(/^\s+/, "").substring(0, 10).toLowerCase();

				var wrap =
					// option or optgroup
					!tags.indexOf("<opt") &&
					[ 1, "<select multiple='multiple'>", "</select>" ] ||

					!tags.indexOf("<leg") &&
					[ 1, "<fieldset>", "</fieldset>" ] ||

					tags.match(/^<(thead|tbody|tfoot|colg|cap)/) &&
					[ 1, "<table>", "</table>" ] ||

					!tags.indexOf("<tr") &&
					[ 2, "<table><tbody>", "</tbody></table>" ] ||

				 	// <thead> matched above
					(!tags.indexOf("<td") || !tags.indexOf("<th")) &&
					[ 3, "<table><tbody><tr>", "</tr></tbody></table>" ] ||

					!tags.indexOf("<col") &&
					[ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ] ||

					// IE can't serialize <link> and <script> tags normally
					!jQuery.support.htmlSerialize &&
					[ 1, "div<div>", "</div>" ] ||

					[ 0, "", "" ];

				// Go to html and back, then peel off extra wrappers
				div.innerHTML = wrap[1] + elem + wrap[2];

				// Move to the right depth
				while ( wrap[0]-- )
					div = div.lastChild;

				// Remove IE's autoinserted <tbody> from table fragments
				if ( !jQuery.support.tbody ) {

					// String was a <table>, *may* have spurious <tbody>
					var hasBody = /<tbody/i.test(elem),
						tbody = !tags.indexOf("<table") && !hasBody ?
							div.firstChild && div.firstChild.childNodes :

						// String was a bare <thead> or <tfoot>
						wrap[1] == "<table>" && !hasBody ?
							div.childNodes :
							[];

					for ( var j = tbody.length - 1; j >= 0 ; --j )
						if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length )
							tbody[ j ].parentNode.removeChild( tbody[ j ] );

					}

				// IE completely kills leading whitespace when innerHTML is used
				if ( !jQuery.support.leadingWhitespace && /^\s/.test( elem ) )
					div.insertBefore( context.createTextNode( elem.match(/^\s*/)[0] ), div.firstChild );
				
				elem = jQuery.makeArray( div.childNodes );
			}

			if ( elem.nodeType )
				ret.push( elem );
			else
				ret = jQuery.merge( ret, elem );

		});

		if ( fragment ) {
			for ( var i = 0; ret[i]; i++ ) {
				if ( jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );
				} else {
					if ( ret[i].nodeType === 1 )
						ret.splice.apply( ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName("script"))) );
					fragment.appendChild( ret[i] );
				}
			}
			
			return scripts;
		}

		return ret;
	},

	attr: function( elem, name, value ) {
		// don't set attributes on text and comment nodes
		if (!elem || elem.nodeType == 3 || elem.nodeType == 8)
			return undefined;

		var notxml = !jQuery.isXMLDoc( elem ),
			// Whether we are setting (or getting)
			set = value !== undefined;

		// Try to normalize/fix the name
		name = notxml && jQuery.props[ name ] || name;

		// Only do all the following if this is a node (faster for style)
		// IE elem.getAttribute passes even for style
		if ( elem.tagName ) {

			// These attributes require special treatment
			var special = /href|src|style/.test( name );

			// Safari mis-reports the default selected property of a hidden option
			// Accessing the parent's selectedIndex property fixes it
			if ( name == "selected" && elem.parentNode )
				elem.parentNode.selectedIndex;

			// If applicable, access the attribute via the DOM 0 way
			if ( name in elem && notxml && !special ) {
				if ( set ){
					// We can't allow the type property to be changed (since it causes problems in IE)
					if ( name == "type" && jQuery.nodeName( elem, "input" ) && elem.parentNode )
						throw "type property can't be changed";

					elem[ name ] = value;
				}

				// browsers index elements by id/name on forms, give priority to attributes.
				if( jQuery.nodeName( elem, "form" ) && elem.getAttributeNode(name) )
					return elem.getAttributeNode( name ).nodeValue;

				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				if ( name == "tabIndex" ) {
					var attributeNode = elem.getAttributeNode( "tabIndex" );
					return attributeNode && attributeNode.specified
						? attributeNode.value
						: elem.nodeName.match(/(button|input|object|select|textarea)/i)
							? 0
							: elem.nodeName.match(/^(a|area)$/i) && elem.href
								? 0
								: undefined;
				}

				return elem[ name ];
			}

			if ( !jQuery.support.style && notxml &&  name == "style" )
				return jQuery.attr( elem.style, "cssText", value );

			if ( set )
				// convert the value to a string (all browsers do this but IE) see #1070
				elem.setAttribute( name, "" + value );

			var attr = !jQuery.support.hrefNormalized && notxml && special
					// Some attributes require a special call on IE
					? elem.getAttribute( name, 2 )
					: elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return attr === null ? undefined : attr;
		}

		// elem is actually elem.style ... set the style

		// IE uses filters for opacity
		if ( !jQuery.support.opacity && name == "opacity" ) {
			if ( set ) {
				// IE has trouble with opacity if it does not have layout
				// Force it by setting the zoom level
				elem.zoom = 1;

				// Set the alpha filter to set the opacity
				elem.filter = (elem.filter || "").replace( /alpha\([^)]*\)/, "" ) +
					(parseInt( value ) + '' == "NaN" ? "" : "alpha(opacity=" + value * 100 + ")");
			}

			return elem.filter && elem.filter.indexOf("opacity=") >= 0 ?
				(parseFloat( elem.filter.match(/opacity=([^)]*)/)[1] ) / 100) + '':
				"";
		}

		name = name.replace(/-([a-z])/ig, function(all, letter){
			return letter.toUpperCase();
		});

		if ( set )
			elem[ name ] = value;

		return elem[ name ];
	},

	trim: function( text ) {
		return (text || "").replace( /^\s+|\s+$/g, "" );
	},

	makeArray: function( array ) {
		var ret = [];

		if( array != null ){
			var i = array.length;
			// The window, strings (and functions) also have 'length'
			if( i == null || typeof array === "string" || jQuery.isFunction(array) || array.setInterval )
				ret[0] = array;
			else
				while( i )
					ret[--i] = array[i];
		}

		return ret;
	},

	inArray: function( elem, array ) {
		for ( var i = 0, length = array.length; i < length; i++ )
		// Use === because on IE, window == document
			if ( array[ i ] === elem )
				return i;

		return -1;
	},

	merge: function( first, second ) {
		// We have to loop this way because IE & Opera overwrite the length
		// expando of getElementsByTagName
		var i = 0, elem, pos = first.length;
		// Also, we need to make sure that the correct elements are being returned
		// (IE returns comment nodes in a '*' query)
		if ( !jQuery.support.getAll ) {
			while ( (elem = second[ i++ ]) != null )
				if ( elem.nodeType != 8 )
					first[ pos++ ] = elem;

		} else
			while ( (elem = second[ i++ ]) != null )
				first[ pos++ ] = elem;

		return first;
	},

	unique: function( array ) {
		var ret = [], done = {};

		try {

			for ( var i = 0, length = array.length; i < length; i++ ) {
				var id = jQuery.data( array[ i ] );

				if ( !done[ id ] ) {
					done[ id ] = true;
					ret.push( array[ i ] );
				}
			}

		} catch( e ) {
			ret = array;
		}

		return ret;
	},

	grep: function( elems, callback, inv ) {
		var ret = [];

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ )
			if ( !inv != !callback( elems[ i ], i ) )
				ret.push( elems[ i ] );

		return ret;
	},

	map: function( elems, callback ) {
		var ret = [];

		// Go through the array, translating each of the items to their
		// new value (or values).
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			var value = callback( elems[ i ], i );

			if ( value != null )
				ret[ ret.length ] = value;
		}

		return ret.concat.apply( [], ret );
	}
});

// Use of jQuery.browser is deprecated.
// It's included for backwards compatibility and plugins,
// although they should work to migrate away.

var userAgent = navigator.userAgent.toLowerCase();

// Figure out what browser is being used
jQuery.browser = {
	version: (userAgent.match( /.+(?:rv|it|ra|ie)[\/: ]([\d.]+)/ ) || [0,'0'])[1],
	safari: /webkit/.test( userAgent ),
	opera: /opera/.test( userAgent ),
	msie: /msie/.test( userAgent ) && !/opera/.test( userAgent ),
	mozilla: /mozilla/.test( userAgent ) && !/(compatible|webkit)/.test( userAgent )
};

jQuery.each({
	parent: function(elem){return elem.parentNode;},
	parents: function(elem){return jQuery.dir(elem,"parentNode");},
	next: function(elem){return jQuery.nth(elem,2,"nextSibling");},
	prev: function(elem){return jQuery.nth(elem,2,"previousSibling");},
	nextAll: function(elem){return jQuery.dir(elem,"nextSibling");},
	prevAll: function(elem){return jQuery.dir(elem,"previousSibling");},
	siblings: function(elem){return jQuery.sibling(elem.parentNode.firstChild,elem);},
	children: function(elem){return jQuery.sibling(elem.firstChild);},
	contents: function(elem){return jQuery.nodeName(elem,"iframe")?elem.contentDocument||elem.contentWindow.document:jQuery.makeArray(elem.childNodes);}
}, function(name, fn){
	jQuery.fn[ name ] = function( selector ) {
		var ret = jQuery.map( this, fn );

		if ( selector && typeof selector == "string" )
			ret = jQuery.multiFilter( selector, ret );

		return this.pushStack( jQuery.unique( ret ), name, selector );
	};
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function(name, original){
	jQuery.fn[ name ] = function( selector ) {
		var ret = [], insert = jQuery( selector );

		for ( var i = 0, l = insert.length; i < l; i++ ) {
			var elems = (i > 0 ? this.clone(true) : this).get();
			jQuery.fn[ original ].apply( jQuery(insert[i]), elems );
			ret = ret.concat( elems );
		}

		return this.pushStack( ret, name, selector );
	};
});

jQuery.each({
	removeAttr: function( name ) {
		jQuery.attr( this, name, "" );
		if (this.nodeType == 1)
			this.removeAttribute( name );
	},

	addClass: function( classNames ) {
		jQuery.className.add( this, classNames );
	},

	removeClass: function( classNames ) {
		jQuery.className.remove( this, classNames );
	},

	toggleClass: function( classNames, state ) {
		if( typeof state !== "boolean" )
			state = !jQuery.className.has( this, classNames );
		jQuery.className[ state ? "add" : "remove" ]( this, classNames );
	},

	remove: function( selector ) {
		if ( !selector || jQuery.filter( selector, [ this ] ).length ) {
			// Prevent memory leaks
			jQuery( "*", this ).add([this]).each(function(){
				jQuery.event.remove(this);
				jQuery.removeData(this);
			});
			if (this.parentNode)
				this.parentNode.removeChild( this );
		}
	},

	empty: function() {
		// Remove element nodes and prevent memory leaks
		jQuery(this).children().remove();

		// Remove any remaining nodes
		while ( this.firstChild )
			this.removeChild( this.firstChild );
	}
}, function(name, fn){
	jQuery.fn[ name ] = function(){
		return this.each( fn, arguments );
	};
});

// Helper function used by the dimensions and offset modules
function num(elem, prop) {
	return elem[0] && parseInt( jQuery.curCSS(elem[0], prop, true), 10 ) || 0;
}
var expando = "jQuery" + now(), uuid = 0, windowData = {};

jQuery.extend({
	cache: {},

	data: function( elem, name, data ) {
		elem = elem == window ?
			windowData :
			elem;

		var id = elem[ expando ];

		// Compute a unique ID for the element
		if ( !id )
			id = elem[ expando ] = ++uuid;

		// Only generate the data cache if we're
		// trying to access or manipulate it
		if ( name && !jQuery.cache[ id ] )
			jQuery.cache[ id ] = {};

		// Prevent overriding the named cache with undefined values
		if ( data !== undefined )
			jQuery.cache[ id ][ name ] = data;

		// Return the named cache data, or the ID for the element
		return name ?
			jQuery.cache[ id ][ name ] :
			id;
	},

	removeData: function( elem, name ) {
		elem = elem == window ?
			windowData :
			elem;

		var id = elem[ expando ];

		// If we want to remove a specific section of the element's data
		if ( name ) {
			if ( jQuery.cache[ id ] ) {
				// Remove the section of cache data
				delete jQuery.cache[ id ][ name ];

				// If we've removed all the data, remove the element's cache
				name = "";

				for ( name in jQuery.cache[ id ] )
					break;

				if ( !name )
					jQuery.removeData( elem );
			}

		// Otherwise, we want to remove all of the element's data
		} else {
			// Clean up the element expando
			try {
				delete elem[ expando ];
			} catch(e){
				// IE has trouble directly removing the expando
				// but it's ok with using removeAttribute
				if ( elem.removeAttribute )
					elem.removeAttribute( expando );
			}

			// Completely remove the data cache
			delete jQuery.cache[ id ];
		}
	},
	queue: function( elem, type, data ) {
		if ( elem ){
	
			type = (type || "fx") + "queue";
	
			var q = jQuery.data( elem, type );
	
			if ( !q || jQuery.isArray(data) )
				q = jQuery.data( elem, type, jQuery.makeArray(data) );
			else if( data )
				q.push( data );
	
		}
		return q;
	},

	dequeue: function( elem, type ){
		var queue = jQuery.queue( elem, type ),
			fn = queue.shift();
		
		if( !type || type === "fx" )
			fn = queue[0];
			
		if( fn !== undefined )
			fn.call(elem);
	}
});

jQuery.fn.extend({
	data: function( key, value ){
		var parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			var data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			if ( data === undefined && this.length )
				data = jQuery.data( this[0], key );

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;
		} else
			return this.trigger("setData" + parts[1] + "!", [parts[0], value]).each(function(){
				jQuery.data( this, key, value );
			});
	},

	removeData: function( key ){
		return this.each(function(){
			jQuery.removeData( this, key );
		});
	},
	queue: function(type, data){
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined )
			return jQuery.queue( this[0], type );

		return this.each(function(){
			var queue = jQuery.queue( this, type, data );
			
			 if( type == "fx" && queue.length == 1 )
				queue[0].call(this);
		});
	},
	dequeue: function(type){
		return this.each(function(){
			jQuery.dequeue( this, type );
		});
	}
});/*!
 * Sizzle CSS Selector Engine - v0.9.3
 *  Copyright 2009, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['"][^'"]*['"]|[^[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?/g,
	done = 0,
	toString = Object.prototype.toString;

var Sizzle = function(selector, context, results, seed) {
	results = results || [];
	context = context || document;

	if ( context.nodeType !== 1 && context.nodeType !== 9 )
		return [];
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var parts = [], m, set, checkSet, check, mode, extra, prune = true;
	
	// Reset the position of the chunker regexp (start from head)
	chunker.lastIndex = 0;
	
	while ( (m = chunker.exec(selector)) !== null ) {
		parts.push( m[1] );
		
		if ( m[2] ) {
			extra = RegExp.rightContext;
			break;
		}
	}

	if ( parts.length > 1 && origPOS.exec( selector ) ) {
		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context );
		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] )
					selector += parts.shift();

				set = posProcess( selector, set );
			}
		}
	} else {
		var ret = seed ?
			{ expr: parts.pop(), set: makeArray(seed) } :
			Sizzle.find( parts.pop(), parts.length === 1 && context.parentNode ? context.parentNode : context, isXML(context) );
		set = Sizzle.filter( ret.expr, ret.set );

		if ( parts.length > 0 ) {
			checkSet = makeArray(set);
		} else {
			prune = false;
		}

		while ( parts.length ) {
			var cur = parts.pop(), pop = cur;

			if ( !Expr.relative[ cur ] ) {
				cur = "";
			} else {
				pop = parts.pop();
			}

			if ( pop == null ) {
				pop = context;
			}

			Expr.relative[ cur ]( checkSet, pop, isXML(context) );
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		throw "Syntax error, unrecognized expression: " + (cur || selector);
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );
		} else if ( context.nodeType === 1 ) {
			for ( var i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}
		} else {
			for ( var i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}
	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, context, results, seed );

		if ( sortOrder ) {
			hasDuplicate = false;
			results.sort(sortOrder);

			if ( hasDuplicate ) {
				for ( var i = 1; i < results.length; i++ ) {
					if ( results[i] === results[i-1] ) {
						results.splice(i--, 1);
					}
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function(expr, set){
	return Sizzle(expr, null, null, set);
};

Sizzle.find = function(expr, context, isXML){
	var set, match;

	if ( !expr ) {
		return [];
	}

	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
		var type = Expr.order[i], match;
		
		if ( (match = Expr.match[ type ].exec( expr )) ) {
			var left = RegExp.leftContext;

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace(/\\/g, "");
				set = Expr.find[ type ]( match, context, isXML );
				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = context.getElementsByTagName("*");
	}

	return {set: set, expr: expr};
};

Sizzle.filter = function(expr, set, inplace, not){
	var old = expr, result = [], curLoop = set, match, anyFound,
		isXMLFilter = set && set[0] && isXML(set[0]);

	while ( expr && set.length ) {
		for ( var type in Expr.filter ) {
			if ( (match = Expr.match[ type ].exec( expr )) != null ) {
				var filter = Expr.filter[ type ], found, item;
				anyFound = false;

				if ( curLoop == result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;
					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							var pass = not ^ !!found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;
								} else {
									curLoop[i] = false;
								}
							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr == old ) {
			if ( anyFound == null ) {
				throw "Syntax error, unrecognized expression: " + expr;
			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],
	match: {
		ID: /#((?:[\w\u00c0-\uFFFF_-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF_-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF_-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF_-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*_-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\((even|odd|[\dn+-]*)\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF_-]|\\.)+)(?:\((['"]*)((?:\([^\)]+\)|[^\2\(\)]*)+)\2\))?/
	},
	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},
	attrHandle: {
		href: function(elem){
			return elem.getAttribute("href");
		}
	},
	relative: {
		"+": function(checkSet, part, isXML){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !/\W/.test(part),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag && !isXML ) {
				part = part.toUpperCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},
		">": function(checkSet, part, isXML){
			var isPartStr = typeof part === "string";

			if ( isPartStr && !/\W/.test(part) ) {
				part = isXML ? part : part.toUpperCase();

				for ( var i = 0, l = checkSet.length; i < l; i++ ) {
					var elem = checkSet[i];
					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName === part ? parent : false;
					}
				}
			} else {
				for ( var i = 0, l = checkSet.length; i < l; i++ ) {
					var elem = checkSet[i];
					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},
		"": function(checkSet, part, isXML){
			var doneName = done++, checkFn = dirCheck;

			if ( !part.match(/\W/) ) {
				var nodeCheck = part = isXML ? part : part.toUpperCase();
				checkFn = dirNodeCheck;
			}

			checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
		},
		"~": function(checkSet, part, isXML){
			var doneName = done++, checkFn = dirCheck;

			if ( typeof part === "string" && !part.match(/\W/) ) {
				var nodeCheck = part = isXML ? part : part.toUpperCase();
				checkFn = dirNodeCheck;
			}

			checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
		}
	},
	find: {
		ID: function(match, context, isXML){
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				return m ? [m] : [];
			}
		},
		NAME: function(match, context, isXML){
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [], results = context.getElementsByName(match[1]);

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},
		TAG: function(match, context){
			return context.getElementsByTagName(match[1]);
		}
	},
	preFilter: {
		CLASS: function(match, curLoop, inplace, result, not, isXML){
			match = " " + match[1].replace(/\\/g, "") + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").indexOf(match) >= 0) ) {
						if ( !inplace )
							result.push( elem );
					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},
		ID: function(match){
			return match[1].replace(/\\/g, "");
		},
		TAG: function(match, curLoop){
			for ( var i = 0; curLoop[i] === false; i++ ){}
			return curLoop[i] && isXML(curLoop[i]) ? match[1] : match[1].toUpperCase();
		},
		CHILD: function(match){
			if ( match[1] == "nth" ) {
				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)n((?:\+|-)?\d*)/.exec(
					match[2] == "even" && "2n" || match[2] == "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},
		ATTR: function(match, curLoop, inplace, result, not, isXML){
			var name = match[1].replace(/\\/g, "");
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},
		PSEUDO: function(match, curLoop, inplace, result, not){
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( match[3].match(chunker).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);
				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
					if ( !inplace ) {
						result.push.apply( result, ret );
					}
					return false;
				}
			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},
		POS: function(match){
			match.unshift( true );
			return match;
		}
	},
	filters: {
		enabled: function(elem){
			return elem.disabled === false && elem.type !== "hidden";
		},
		disabled: function(elem){
			return elem.disabled === true;
		},
		checked: function(elem){
			return elem.checked === true;
		},
		selected: function(elem){
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			elem.parentNode.selectedIndex;
			return elem.selected === true;
		},
		parent: function(elem){
			return !!elem.firstChild;
		},
		empty: function(elem){
			return !elem.firstChild;
		},
		has: function(elem, i, match){
			return !!Sizzle( match[3], elem ).length;
		},
		header: function(elem){
			return /h\d/i.test( elem.nodeName );
		},
		text: function(elem){
			return "text" === elem.type;
		},
		radio: function(elem){
			return "radio" === elem.type;
		},
		checkbox: function(elem){
			return "checkbox" === elem.type;
		},
		file: function(elem){
			return "file" === elem.type;
		},
		password: function(elem){
			return "password" === elem.type;
		},
		submit: function(elem){
			return "submit" === elem.type;
		},
		image: function(elem){
			return "image" === elem.type;
		},
		reset: function(elem){
			return "reset" === elem.type;
		},
		button: function(elem){
			return "button" === elem.type || elem.nodeName.toUpperCase() === "BUTTON";
		},
		input: function(elem){
			return /input|select|textarea|button/i.test(elem.nodeName);
		}
	},
	setFilters: {
		first: function(elem, i){
			return i === 0;
		},
		last: function(elem, i, match, array){
			return i === array.length - 1;
		},
		even: function(elem, i){
			return i % 2 === 0;
		},
		odd: function(elem, i){
			return i % 2 === 1;
		},
		lt: function(elem, i, match){
			return i < match[3] - 0;
		},
		gt: function(elem, i, match){
			return i > match[3] - 0;
		},
		nth: function(elem, i, match){
			return match[3] - 0 == i;
		},
		eq: function(elem, i, match){
			return match[3] - 0 == i;
		}
	},
	filter: {
		PSEUDO: function(elem, match, i, array){
			var name = match[1], filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || "").indexOf(match[3]) >= 0;
			} else if ( name === "not" ) {
				var not = match[3];

				for ( var i = 0, l = not.length; i < l; i++ ) {
					if ( not[i] === elem ) {
						return false;
					}
				}

				return true;
			}
		},
		CHILD: function(elem, match){
			var type = match[1], node = elem;
			switch (type) {
				case 'only':
				case 'first':
					while (node = node.previousSibling)  {
						if ( node.nodeType === 1 ) return false;
					}
					if ( type == 'first') return true;
					node = elem;
				case 'last':
					while (node = node.nextSibling)  {
						if ( node.nodeType === 1 ) return false;
					}
					return true;
				case 'nth':
					var first = match[2], last = match[3];

					if ( first == 1 && last == 0 ) {
						return true;
					}
					
					var doneName = match[0],
						parent = elem.parentNode;
	
					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
						var count = 0;
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 
						parent.sizcache = doneName;
					}
					
					var diff = elem.nodeIndex - last;
					if ( first == 0 ) {
						return diff == 0;
					} else {
						return ( diff % first == 0 && diff / first >= 0 );
					}
			}
		},
		ID: function(elem, match){
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},
		TAG: function(elem, match){
			return (match === "*" && elem.nodeType === 1) || elem.nodeName === match;
		},
		CLASS: function(elem, match){
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},
		ATTR: function(elem, match){
			var name = match[1],
				result = Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value != check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},
		POS: function(elem, match, i, array){
			var name = match[2], filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS;

for ( var type in Expr.match ) {
	Expr.match[ type ] = RegExp( Expr.match[ type ].source + /(?![^\[]*\])(?![^\(]*\))/.source );
}

var makeArray = function(array, results) {
	array = Array.prototype.slice.call( array );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
try {
	Array.prototype.slice.call( document.documentElement.childNodes );

// Provide a fallback method if it does not work
} catch(e){
	makeArray = function(array, results) {
		var ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );
		} else {
			if ( typeof array.length === "number" ) {
				for ( var i = 0, l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}
			} else {
				for ( var i = 0; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		var ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;
		if ( ret === 0 ) {
			hasDuplicate = true;
		}
		return ret;
	};
} else if ( "sourceIndex" in document.documentElement ) {
	sortOrder = function( a, b ) {
		var ret = a.sourceIndex - b.sourceIndex;
		if ( ret === 0 ) {
			hasDuplicate = true;
		}
		return ret;
	};
} else if ( document.createRange ) {
	sortOrder = function( a, b ) {
		var aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();
		aRange.selectNode(a);
		aRange.collapse(true);
		bRange.selectNode(b);
		bRange.collapse(true);
		var ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);
		if ( ret === 0 ) {
			hasDuplicate = true;
		}
		return ret;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("form"),
		id = "script" + (new Date).getTime();
	form.innerHTML = "<input name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	var root = document.documentElement;
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( !!document.getElementById( id ) ) {
		Expr.find.ID = function(match, context, isXML){
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				return m ? m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ? [m] : undefined : [];
			}
		};

		Expr.filter.ID = function(elem, match){
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function(match, context){
			var results = context.getElementsByTagName(match[1]);

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";
	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {
		Expr.attrHandle.href = function(elem){
			return elem.getAttribute("href", 2);
		};
	}
})();

if ( document.querySelectorAll ) (function(){
	var oldSizzle = Sizzle, div = document.createElement("div");
	div.innerHTML = "<p class='TEST'></p>";

	// Safari can't handle uppercase or unicode characters when
	// in quirks mode.
	if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
		return;
	}
	
	Sizzle = function(query, context, extra, seed){
		context = context || document;

		// Only use querySelectorAll on non-XML documents
		// (ID selectors don't work in non-HTML documents)
		if ( !seed && context.nodeType === 9 && !isXML(context) ) {
			try {
				return makeArray( context.querySelectorAll(query), extra );
			} catch(e){}
		}
		
		return oldSizzle(query, context, extra, seed);
	};

	Sizzle.find = oldSizzle.find;
	Sizzle.filter = oldSizzle.filter;
	Sizzle.selectors = oldSizzle.selectors;
	Sizzle.matches = oldSizzle.matches;
})();

if ( document.getElementsByClassName && document.documentElement.getElementsByClassName ) (function(){
	var div = document.createElement("div");
	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	if ( div.getElementsByClassName("e").length === 0 )
		return;

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 )
		return;

	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function(match, context, isXML) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	var sibDir = dir == "previousSibling" && !isXML;
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];
		if ( elem ) {
			if ( sibDir && elem.nodeType === 1 ){
				elem.sizcache = doneName;
				elem.sizset = i;
			}
			elem = elem[dir];
			var match = false;

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem.sizcache = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	var sibDir = dir == "previousSibling" && !isXML;
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];
		if ( elem ) {
			if ( sibDir && elem.nodeType === 1 ) {
				elem.sizcache = doneName;
				elem.sizset = i;
			}
			elem = elem[dir];
			var match = false;

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem.sizcache = doneName;
						elem.sizset = i;
					}
					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

var contains = document.compareDocumentPosition ?  function(a, b){
	return a.compareDocumentPosition(b) & 16;
} : function(a, b){
	return a !== b && (a.contains ? a.contains(b) : true);
};

var isXML = function(elem){
	return elem.nodeType === 9 && elem.documentElement.nodeName !== "HTML" ||
		!!elem.ownerDocument && isXML( elem.ownerDocument );
};

var posProcess = function(selector, context){
	var tmpSet = [], later = "", match,
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
jQuery.find = Sizzle;
jQuery.filter = Sizzle.filter;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;

Sizzle.selectors.filters.hidden = function(elem){
	return elem.offsetWidth === 0 || elem.offsetHeight === 0;
};

Sizzle.selectors.filters.visible = function(elem){
	return elem.offsetWidth > 0 || elem.offsetHeight > 0;
};

Sizzle.selectors.filters.animated = function(elem){
	return jQuery.grep(jQuery.timers, function(fn){
		return elem === fn.elem;
	}).length;
};

jQuery.multiFilter = function( expr, elems, not ) {
	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return Sizzle.matches(expr, elems);
};

jQuery.dir = function( elem, dir ){
	var matched = [], cur = elem[dir];
	while ( cur && cur != document ) {
		if ( cur.nodeType == 1 )
			matched.push( cur );
		cur = cur[dir];
	}
	return matched;
};

jQuery.nth = function(cur, result, dir, elem){
	result = result || 1;
	var num = 0;

	for ( ; cur; cur = cur[dir] )
		if ( cur.nodeType == 1 && ++num == result )
			break;

	return cur;
};

jQuery.sibling = function(n, elem){
	var r = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType == 1 && n != elem )
			r.push( n );
	}

	return r;
};

return;

window.Sizzle = Sizzle;

})();
/*
 * A number of helper functions used for managing events.
 * Many of the ideas behind this code originated from
 * Dean Edwards' addEvent library.
 */
jQuery.event = {

	// Bind an event to an element
	// Original by Dean Edwards
	add: function(elem, types, handler, data) {
		if ( elem.nodeType == 3 || elem.nodeType == 8 )
			return;

		// For whatever reason, IE has trouble passing the window object
		// around, causing it to be cloned in the process
		if ( elem.setInterval && elem != window )
			elem = window;

		// Make sure that the function being executed has a unique ID
		if ( !handler.guid )
			handler.guid = this.guid++;

		// if data is passed, bind to handler
		if ( data !== undefined ) {
			// Create temporary function pointer to original handler
			var fn = handler;

			// Create unique handler function, wrapped around original handler
			handler = this.proxy( fn );

			// Store data in unique handler
			handler.data = data;
		}

		// Init the element's event structure
		var events = jQuery.data(elem, "events") || jQuery.data(elem, "events", {}),
			handle = jQuery.data(elem, "handle") || jQuery.data(elem, "handle", function(){
				// Handle the second event of a trigger and when
				// an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && !jQuery.event.triggered ?
					jQuery.event.handle.apply(arguments.callee.elem, arguments) :
					undefined;
			});
		// Add elem as a property of the handle function
		// This is to prevent a memory leak with non-native
		// event in IE.
		handle.elem = elem;

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		jQuery.each(types.split(/\s+/), function(index, type) {
			// Namespaced event handlers
			var namespaces = type.split(".");
			type = namespaces.shift();
			handler.type = namespaces.slice().sort().join(".");

			// Get the current list of functions bound to this event
			var handlers = events[type];
			
			if ( jQuery.event.specialAll[type] )
				jQuery.event.specialAll[type].setup.call(elem, data, namespaces);

			// Init the event handler queue
			if (!handlers) {
				handlers = events[type] = {};

				// Check for a special event handler
				// Only use addEventListener/attachEvent if the special
				// events handler returns false
				if ( !jQuery.event.special[type] || jQuery.event.special[type].setup.call(elem, data, namespaces) === false ) {
					// Bind the global event handler to the element
					if (elem.addEventListener)
						elem.addEventListener(type, handle, false);
					else if (elem.attachEvent)
						elem.attachEvent("on" + type, handle);
				}
			}

			// Add the function to the element's handler list
			handlers[handler.guid] = handler;

			// Keep track of which events have been used, for global triggering
			jQuery.event.global[type] = true;
		});

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	guid: 1,
	global: {},

	// Detach an event or set of events from an element
	remove: function(elem, types, handler) {
		// don't do events on text and comment nodes
		if ( elem.nodeType == 3 || elem.nodeType == 8 )
			return;

		var events = jQuery.data(elem, "events"), ret, index;

		if ( events ) {
			// Unbind all events for the element
			if ( types === undefined || (typeof types === "string" && types.charAt(0) == ".") )
				for ( var type in events )
					this.remove( elem, type + (types || "") );
			else {
				// types is actually an event object here
				if ( types.type ) {
					handler = types.handler;
					types = types.type;
				}

				// Handle multiple events seperated by a space
				// jQuery(...).unbind("mouseover mouseout", fn);
				jQuery.each(types.split(/\s+/), function(index, type){
					// Namespaced event handlers
					var namespaces = type.split(".");
					type = namespaces.shift();
					var namespace = RegExp("(^|\\.)" + namespaces.slice().sort().join(".*\\.") + "(\\.|$)");

					if ( events[type] ) {
						// remove the given handler for the given type
						if ( handler )
							delete events[type][handler.guid];

						// remove all handlers for the given type
						else
							for ( var handle in events[type] )
								// Handle the removal of namespaced events
								if ( namespace.test(events[type][handle].type) )
									delete events[type][handle];
									
						if ( jQuery.event.specialAll[type] )
							jQuery.event.specialAll[type].teardown.call(elem, namespaces);

						// remove generic event handler if no more handlers exist
						for ( ret in events[type] ) break;
						if ( !ret ) {
							if ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem, namespaces) === false ) {
								if (elem.removeEventListener)
									elem.removeEventListener(type, jQuery.data(elem, "handle"), false);
								else if (elem.detachEvent)
									elem.detachEvent("on" + type, jQuery.data(elem, "handle"));
							}
							ret = null;
							delete events[type];
						}
					}
				});
			}

			// Remove the expando if it's no longer used
			for ( ret in events ) break;
			if ( !ret ) {
				var handle = jQuery.data( elem, "handle" );
				if ( handle ) handle.elem = null;
				jQuery.removeData( elem, "events" );
				jQuery.removeData( elem, "handle" );
			}
		}
	},

	// bubbling is internal
	trigger: function( event, data, elem, bubbling ) {
		// Event object or event type
		var type = event.type || event;

		if( !bubbling ){
			event = typeof event === "object" ?
				// jQuery.Event object
				event[expando] ? event :
				// Object literal
				jQuery.extend( jQuery.Event(type), event ) :
				// Just the event type (string)
				jQuery.Event(type);

			if ( type.indexOf("!") >= 0 ) {
				event.type = type = type.slice(0, -1);
				event.exclusive = true;
			}

			// Handle a global trigger
			if ( !elem ) {
				// Don't bubble custom events when global (to avoid too much overhead)
				event.stopPropagation();
				// Only trigger if we've ever bound an event for it
				if ( this.global[type] )
					jQuery.each( jQuery.cache, function(){
						if ( this.events && this.events[type] )
							jQuery.event.trigger( event, data, this.handle.elem );
					});
			}

			// Handle triggering a single element

			// don't do events on text and comment nodes
			if ( !elem || elem.nodeType == 3 || elem.nodeType == 8 )
				return undefined;
			
			// Clean up in case it is reused
			event.result = undefined;
			event.target = elem;
			
			// Clone the incoming data, if any
			data = jQuery.makeArray(data);
			data.unshift( event );
		}

		event.currentTarget = elem;

		// Trigger the event, it is assumed that "handle" is a function
		var handle = jQuery.data(elem, "handle");
		if ( handle )
			handle.apply( elem, data );

		// Handle triggering native .onfoo handlers (and on links since we don't call .click() for links)
		if ( (!elem[type] || (jQuery.nodeName(elem, 'a') && type == "click")) && elem["on"+type] && elem["on"+type].apply( elem, data ) === false )
			event.result = false;

		// Trigger the native events (except for clicks on links)
		if ( !bubbling && elem[type] && !event.isDefaultPrevented() && !(jQuery.nodeName(elem, 'a') && type == "click") ) {
			this.triggered = true;
			try {
				elem[ type ]();
			// prevent IE from throwing an error for some hidden elements
			} catch (e) {}
		}

		this.triggered = false;

		if ( !event.isPropagationStopped() ) {
			var parent = elem.parentNode || elem.ownerDocument;
			if ( parent )
				jQuery.event.trigger(event, data, parent, true);
		}
	},

	handle: function(event) {
		// returned undefined or false
		var all, handlers;

		event = arguments[0] = jQuery.event.fix( event || window.event );
		event.currentTarget = this;
		
		// Namespaced event handlers
		var namespaces = event.type.split(".");
		event.type = namespaces.shift();

		// Cache this now, all = true means, any handler
		all = !namespaces.length && !event.exclusive;
		
		var namespace = RegExp("(^|\\.)" + namespaces.slice().sort().join(".*\\.") + "(\\.|$)");

		handlers = ( jQuery.data(this, "events") || {} )[event.type];

		for ( var j in handlers ) {
			var handler = handlers[j];

			// Filter the functions by class
			if ( all || namespace.test(handler.type) ) {
				// Pass in a reference to the handler function itself
				// So that we can later remove it
				event.handler = handler;
				event.data = handler.data;

				var ret = handler.apply(this, arguments);

				if( ret !== undefined ){
					event.result = ret;
					if ( ret === false ) {
						event.preventDefault();
						event.stopPropagation();
					}
				}

				if( event.isImmediatePropagationStopped() )
					break;

			}
		}
	},

	props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode metaKey newValue originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

	fix: function(event) {
		if ( event[expando] )
			return event;

		// store a copy of the original event object
		// and "clone" to set read-only properties
		var originalEvent = event;
		event = jQuery.Event( originalEvent );

		for ( var i = this.props.length, prop; i; ){
			prop = this.props[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary
		if ( !event.target )
			event.target = event.srcElement || document; // Fixes #1925 where srcElement might not be defined either

		// check if target is a textnode (safari)
		if ( event.target.nodeType == 3 )
			event.target = event.target.parentNode;

		// Add relatedTarget, if necessary
		if ( !event.relatedTarget && event.fromElement )
			event.relatedTarget = event.fromElement == event.target ? event.toElement : event.fromElement;

		// Calculate pageX/Y if missing and clientX/Y available
		if ( event.pageX == null && event.clientX != null ) {
			var doc = document.documentElement, body = document.body;
			event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc.clientLeft || 0);
			event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc.clientTop || 0);
		}

		// Add which for key events
		if ( !event.which && ((event.charCode || event.charCode === 0) ? event.charCode : event.keyCode) )
			event.which = event.charCode || event.keyCode;

		// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
		if ( !event.metaKey && event.ctrlKey )
			event.metaKey = event.ctrlKey;

		// Add which for click: 1 == left; 2 == middle; 3 == right
		// Note: button is not normalized, so don't use it
		if ( !event.which && event.button )
			event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));

		return event;
	},

	proxy: function( fn, proxy ){
		proxy = proxy || function(){ return fn.apply(this, arguments); };
		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || this.guid++;
		// So proxy can be declared as an argument
		return proxy;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: bindReady,
			teardown: function() {}
		}
	},
	
	specialAll: {
		live: {
			setup: function( selector, namespaces ){
				jQuery.event.add( this, namespaces[0], liveHandler );
			},
			teardown:  function( namespaces ){
				if ( namespaces.length ) {
					var remove = 0, name = RegExp("(^|\\.)" + namespaces[0] + "(\\.|$)");
					
					jQuery.each( (jQuery.data(this, "events").live || {}), function(){
						if ( name.test(this.type) )
							remove++;
					});
					
					if ( remove < 1 )
						jQuery.event.remove( this, namespaces[0], liveHandler );
				}
			}
		}
	}
};

jQuery.Event = function( src ){
	// Allow instantiation without the 'new' keyword
	if( !this.preventDefault )
		return new jQuery.Event(src);
	
	// Event object
	if( src && src.type ){
		this.originalEvent = src;
		this.type = src.type;
	// Event type
	}else
		this.type = src;

	// timeStamp is buggy for some events on Firefox(#3843)
	// So we won't rely on the native value
	this.timeStamp = now();
	
	// Mark it as fixed
	this[expando] = true;
};

function returnFalse(){
	return false;
}
function returnTrue(){
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if( !e )
			return;
		// if preventDefault exists run it on the original event
		if (e.preventDefault)
			e.preventDefault();
		// otherwise set the returnValue property of the original event to false (IE)
		e.returnValue = false;
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if( !e )
			return;
		// if stopPropagation exists run it on the original event
		if (e.stopPropagation)
			e.stopPropagation();
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation:function(){
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};
// Checks if an event happened on an element within another element
// Used in jQuery.event.special.mouseenter and mouseleave handlers
var withinElement = function(event) {
	// Check if mouse(over|out) are still within the same parent element
	var parent = event.relatedTarget;
	// Traverse up the tree
	while ( parent && parent != this )
		try { parent = parent.parentNode; }
		catch(e) { parent = this; }
	
	if( parent != this ){
		// set the correct event type
		event.type = event.data;
		// handle event if we actually just moused on to a non sub-element
		jQuery.event.handle.apply( this, arguments );
	}
};
	
jQuery.each({ 
	mouseover: 'mouseenter', 
	mouseout: 'mouseleave'
}, function( orig, fix ){
	jQuery.event.special[ fix ] = {
		setup: function(){
			jQuery.event.add( this, orig, withinElement, fix );
		},
		teardown: function(){
			jQuery.event.remove( this, orig, withinElement );
		}
	};			   
});

jQuery.fn.extend({
	bind: function( type, data, fn ) {
		return type == "unload" ? this.one(type, data, fn) : this.each(function(){
			jQuery.event.add( this, type, fn || data, fn && data );
		});
	},

	one: function( type, data, fn ) {
		var one = jQuery.event.proxy( fn || data, function(event) {
			jQuery(this).unbind(event, one);
			return (fn || data).apply( this, arguments );
		});
		return this.each(function(){
			jQuery.event.add( this, type, one, fn && data);
		});
	},

	unbind: function( type, fn ) {
		return this.each(function(){
			jQuery.event.remove( this, type, fn );
		});
	},

	trigger: function( type, data ) {
		return this.each(function(){
			jQuery.event.trigger( type, data, this );
		});
	},

	triggerHandler: function( type, data ) {
		if( this[0] ){
			var event = jQuery.Event(type);
			event.preventDefault();
			event.stopPropagation();
			jQuery.event.trigger( event, data, this[0] );
			return event.result;
		}		
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments, i = 1;

		// link all the functions, so any of them can unbind this click handler
		while( i < args.length )
			jQuery.event.proxy( fn, args[i++] );

		return this.click( jQuery.event.proxy( fn, function(event) {
			// Figure out which function to execute
			this.lastToggle = ( this.lastToggle || 0 ) % i;

			// Make sure that clicks stop
			event.preventDefault();

			// and execute the function
			return args[ this.lastToggle++ ].apply( this, arguments ) || false;
		}));
	},

	hover: function(fnOver, fnOut) {
		return this.mouseenter(fnOver).mouseleave(fnOut);
	},

	ready: function(fn) {
		// Attach the listeners
		bindReady();

		// If the DOM is already ready
		if ( jQuery.isReady )
			// Execute the function immediately
			fn.call( document, jQuery );

		// Otherwise, remember the function for later
		else
			// Add the function to the wait list
			jQuery.readyList.push( fn );

		return this;
	},
	
	live: function( type, fn ){
		var proxy = jQuery.event.proxy( fn );
		proxy.guid += this.selector + type;

		jQuery(document).bind( liveConvert(type, this.selector), this.selector, proxy );

		return this;
	},
	
	die: function( type, fn ){
		jQuery(document).unbind( liveConvert(type, this.selector), fn ? { guid: fn.guid + this.selector + type } : null );
		return this;
	}
});

function liveHandler( event ){
	var check = RegExp("(^|\\.)" + event.type + "(\\.|$)"),
		stop = true,
		elems = [];

	jQuery.each(jQuery.data(this, "events").live || [], function(i, fn){
		if ( check.test(fn.type) ) {
			var elem = jQuery(event.target).closest(fn.data)[0];
			if ( elem )
				elems.push({ elem: elem, fn: fn });
		}
	});

	elems.sort(function(a,b) {
		return jQuery.data(a.elem, "closest") - jQuery.data(b.elem, "closest");
	});
	
	jQuery.each(elems, function(){
		if ( this.fn.call(this.elem, event, this.fn.data) === false )
			return (stop = false);
	});

	return stop;
}

function liveConvert(type, selector){
	return ["live", type, selector.replace(/\./g, "`").replace(/ /g, "|")].join(".");
}

jQuery.extend({
	isReady: false,
	readyList: [],
	// Handle when the DOM is ready
	ready: function() {
		// Make sure that the DOM is not already loaded
		if ( !jQuery.isReady ) {
			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If there are functions bound, to execute
			if ( jQuery.readyList ) {
				// Execute all of them
				jQuery.each( jQuery.readyList, function(){
					this.call( document, jQuery );
				});

				// Reset the list of functions
				jQuery.readyList = null;
			}

			// Trigger any bound ready events
			jQuery(document).triggerHandler("ready");
		}
	}
});

var readyBound = false;

function bindReady(){
	if ( readyBound ) return;
	readyBound = true;

	// Mozilla, Opera and webkit nightlies currently support this event
	if ( document.addEventListener ) {
		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", function(){
			document.removeEventListener( "DOMContentLoaded", arguments.callee, false );
			jQuery.ready();
		}, false );

	// If IE event model is used
	} else if ( document.attachEvent ) {
		// ensure firing before onload,
		// maybe late but safe also for iframes
		document.attachEvent("onreadystatechange", function(){
			if ( document.readyState === "complete" ) {
				document.detachEvent( "onreadystatechange", arguments.callee );
				jQuery.ready();
			}
		});

		// If IE and not an iframe
		// continually check to see if the document is ready
		if ( document.documentElement.doScroll && window == window.top ) (function(){
			if ( jQuery.isReady ) return;

			try {
				// If IE is used, use the trick by Diego Perini
				// http://javascript.nwbox.com/IEContentLoaded/
				document.documentElement.doScroll("left");
			} catch( error ) {
				setTimeout( arguments.callee, 0 );
				return;
			}

			// and execute any waiting functions
			jQuery.ready();
		})();
	}

	// A fallback to window.onload, that will always work
	jQuery.event.add( window, "load", jQuery.ready );
}

jQuery.each( ("blur,focus,load,resize,scroll,unload,click,dblclick," +
	"mousedown,mouseup,mousemove,mouseover,mouseout,mouseenter,mouseleave," +
	"change,select,submit,keydown,keypress,keyup,error").split(","), function(i, name){

	// Handle event binding
	jQuery.fn[name] = function(fn){
		return fn ? this.bind(name, fn) : this.trigger(name);
	};
});

// Prevent memory leaks in IE
// And prevent errors on refresh with events like mouseover in other browsers
// Window isn't included so as not to unbind existing unload events
jQuery( window ).bind( 'unload', function(){ 
	for ( var id in jQuery.cache )
		// Skip the window
		if ( id != 1 && jQuery.cache[ id ].handle )
			jQuery.event.remove( jQuery.cache[ id ].handle.elem );
}); 
(function(){

	jQuery.support = {};

	var root = document.documentElement,
		script = document.createElement("script"),
		div = document.createElement("div"),
		id = "script" + (new Date).getTime();

	div.style.display = "none";
	div.innerHTML = '   <link/><table></table><a href="/a" style="color:red;float:left;opacity:.5;">a</a><select><option>text</option></select><object><param/></object>';

	var all = div.getElementsByTagName("*"),
		a = div.getElementsByTagName("a")[0];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return;
	}

	jQuery.support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: div.firstChild.nodeType == 3,
		
		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,
		
		// Make sure that you can get all elements in an <object> element
		// IE 7 always returns no results
		objectAll: !!div.getElementsByTagName("object")[0]
			.getElementsByTagName("*").length,
		
		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,
		
		// Get the style information from getAttribute
		// (IE uses .cssText insted)
		style: /red/.test( a.getAttribute("style") ),
		
		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: a.getAttribute("href") === "/a",
		
		// Make sure that element opacity exists
		// (IE uses filter instead)
		opacity: a.style.opacity === "0.5",
		
		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Will be defined later
		scriptEval: false,
		noCloneEvent: true,
		boxModel: null
	};
	
	script.type = "text/javascript";
	try {
		script.appendChild( document.createTextNode( "window." + id + "=1;" ) );
	} catch(e){}

	root.insertBefore( script, root.firstChild );
	
	// Make sure that the execution of code works by injecting a script
	// tag with appendChild/createTextNode
	// (IE doesn't support this, fails, and uses .text instead)
	if ( window[ id ] ) {
		jQuery.support.scriptEval = true;
		delete window[ id ];
	}

	root.removeChild( script );

	if ( div.attachEvent && div.fireEvent ) {
		div.attachEvent("onclick", function(){
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			jQuery.support.noCloneEvent = false;
			div.detachEvent("onclick", arguments.callee);
		});
		div.cloneNode(true).fireEvent("onclick");
	}

	// Figure out if the W3C box model works as expected
	// document.body must exist before we can do this
	jQuery(function(){
		var div = document.createElement("div");
		div.style.width = div.style.paddingLeft = "1px";

		document.body.appendChild( div );
		jQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2;
		document.body.removeChild( div ).style.display = 'none';
	});
})();

var styleFloat = jQuery.support.cssFloat ? "cssFloat" : "styleFloat";

jQuery.props = {
	"for": "htmlFor",
	"class": "className",
	"float": styleFloat,
	cssFloat: styleFloat,
	styleFloat: styleFloat,
	readonly: "readOnly",
	maxlength: "maxLength",
	cellspacing: "cellSpacing",
	rowspan: "rowSpan",
	tabindex: "tabIndex"
};
jQuery.fn.extend({
	// Keep a copy of the old load
	_load: jQuery.fn.load,

	load: function( url, params, callback ) {
		if ( typeof url !== "string" )
			return this._load( url );

		var off = url.indexOf(" ");
		if ( off >= 0 ) {
			var selector = url.slice(off, url.length);
			url = url.slice(0, off);
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params )
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = null;

			// Otherwise, build a param string
			} else if( typeof params === "object" ) {
				params = jQuery.param( params );
				type = "POST";
			}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			complete: function(res, status){
				// If successful, inject the HTML into all the matched elements
				if ( status == "success" || status == "notmodified" )
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div/>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(res.responseText.replace(/<script(.|\s)*?\/script>/g, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						res.responseText );

				if( callback )
					self.each( callback, [res.responseText, status, res] );
			}
		});
		return this;
	},

	serialize: function() {
		return jQuery.param(this.serializeArray());
	},
	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray(this.elements) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				(this.checked || /select|textarea/i.test(this.nodeName) ||
					/text|hidden|password|search/i.test(this.type));
		})
		.map(function(i, elem){
			var val = jQuery(this).val();
			return val == null ? null :
				jQuery.isArray(val) ?
					jQuery.map( val, function(val, i){
						return {name: elem.name, value: val};
					}) :
					{name: elem.name, value: val};
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend".split(","), function(i,o){
	jQuery.fn[o] = function(f){
		return this.bind(o, f);
	};
});

var jsc = now();

jQuery.extend({
  
	get: function( url, data, callback, type ) {
		// shift arguments if data argument was ommited
		if ( jQuery.isFunction( data ) ) {
			callback = data;
			data = null;
		}

		return jQuery.ajax({
			type: "GET",
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	},

	getScript: function( url, callback ) {
		return jQuery.get(url, null, callback, "script");
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get(url, data, callback, "json");
	},

	post: function( url, data, callback, type ) {
		if ( jQuery.isFunction( data ) ) {
			callback = data;
			data = {};
		}

		return jQuery.ajax({
			type: "POST",
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	},

	ajaxSetup: function( settings ) {
		jQuery.extend( jQuery.ajaxSettings, settings );
	},

	ajaxSettings: {
		url: location.href,
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		username: null,
		password: null,
		*/
		// Create the request object; Microsoft failed to properly
		// implement the XMLHttpRequest in IE7, so we use the ActiveXObject when it is available
		// This function can be overriden by calling jQuery.ajaxSetup
		xhr:function(){
			return window.ActiveXObject ? new ActiveXObject("Microsoft.XMLHTTP") : new XMLHttpRequest();
		},
		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			script: "text/javascript, application/javascript",
			json: "application/json, text/javascript",
			text: "text/plain",
			_default: "*/*"
		}
	},

	// Last-Modified header cache for next request
	lastModified: {},

	ajax: function( s ) {
		// Extend the settings, but re-extend 's' so that it can be
		// checked again later (in the test suite, specifically)
		s = jQuery.extend(true, s, jQuery.extend(true, {}, jQuery.ajaxSettings, s));

		var jsonp, jsre = /=\?(&|$)/g, status, data,
			type = s.type.toUpperCase();

		// convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" )
			s.data = jQuery.param(s.data);

		// Handle JSONP Parameter Callbacks
		if ( s.dataType == "jsonp" ) {
			if ( type == "GET" ) {
				if ( !s.url.match(jsre) )
					s.url += (s.url.match(/\?/) ? "&" : "?") + (s.jsonp || "callback") + "=?";
			} else if ( !s.data || !s.data.match(jsre) )
				s.data = (s.data ? s.data + "&" : "") + (s.jsonp || "callback") + "=?";
			s.dataType = "json";
		}

		// Build temporary JSONP function
		if ( s.dataType == "json" && (s.data && s.data.match(jsre) || s.url.match(jsre)) ) {
			jsonp = "jsonp" + jsc++;

			// Replace the =? sequence both in the query string and the data
			if ( s.data )
				s.data = (s.data + "").replace(jsre, "=" + jsonp + "$1");
			s.url = s.url.replace(jsre, "=" + jsonp + "$1");

			// We need to make sure
			// that a JSONP style response is executed properly
			s.dataType = "script";

			// Handle JSONP-style loading
			window[ jsonp ] = function(tmp){
				data = tmp;
				success();
				complete();
				// Garbage collect
				window[ jsonp ] = undefined;
				try{ delete window[ jsonp ]; } catch(e){}
				if ( head )
					head.removeChild( script );
			};
		}

		if ( s.dataType == "script" && s.cache == null )
			s.cache = false;

		if ( s.cache === false && type == "GET" ) {
			var ts = now();
			// try replacing _= if it is there
			var ret = s.url.replace(/(\?|&)_=.*?(&|$)/, "$1_=" + ts + "$2");
			// if nothing was replaced, add timestamp to the end
			s.url = ret + ((ret == s.url) ? (s.url.match(/\?/) ? "&" : "?") + "_=" + ts : "");
		}

		// If data is available, append data to url for get requests
		if ( s.data && type == "GET" ) {
			s.url += (s.url.match(/\?/) ? "&" : "?") + s.data;

			// IE likes to send both get and post data, prevent this
			s.data = null;
		}

		// Watch for a new set of requests
		if ( s.global && ! jQuery.active++ )
			jQuery.event.trigger( "ajaxStart" );

		// Matches an absolute URL, and saves the domain
		var parts = /^(\w+:)?\/\/([^\/?#]+)/.exec( s.url );

		// If we're requesting a remote document
		// and trying to load JSON or Script with a GET
		if ( s.dataType == "script" && type == "GET" && parts
			&& ( parts[1] && parts[1] != location.protocol || parts[2] != location.host )){

			var head = document.getElementsByTagName("head")[0];
			var script = document.createElement("script");
			script.src = s.url;
			if (s.scriptCharset)
				script.charset = s.scriptCharset;

			// Handle Script loading
			if ( !jsonp ) {
				var done = false;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function(){
					if ( !done && (!this.readyState ||
							this.readyState == "loaded" || this.readyState == "complete") ) {
						done = true;
						success();
						complete();

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;
						head.removeChild( script );
					}
				};
			}

			head.appendChild(script);

			// We handle everything using the script element injection
			return undefined;
		}

		var requestDone = false;

		// Create the request object
		var xhr = s.xhr();

		// Open the socket
		// Passing null username, generates a login popup on Opera (#2865)
		if( s.username )
			xhr.open(type, s.url, s.async, s.username, s.password);
		else
			xhr.open(type, s.url, s.async);

		// Need an extra try/catch for cross domain requests in Firefox 3
		try {
			// Set the correct header, if data is being sent
			if ( s.data )
				xhr.setRequestHeader("Content-Type", s.contentType);

			// Set the If-Modified-Since header, if ifModified mode.
			if ( s.ifModified )
				xhr.setRequestHeader("If-Modified-Since",
					jQuery.lastModified[s.url] || "Thu, 01 Jan 1970 00:00:00 GMT" );

			// Set header so the called script knows that it's an XMLHttpRequest
			xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");

			// Set the Accepts header for the server, depending on the dataType
			xhr.setRequestHeader("Accept", s.dataType && s.accepts[ s.dataType ] ?
				s.accepts[ s.dataType ] + ", */*" :
				s.accepts._default );
		} catch(e){}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && s.beforeSend(xhr, s) === false ) {
			// Handle the global AJAX counter
			if ( s.global && ! --jQuery.active )
				jQuery.event.trigger( "ajaxStop" );
			// close opended socket
			xhr.abort();
			return false;
		}

		if ( s.global )
			jQuery.event.trigger("ajaxSend", [xhr, s]);

		// Wait for a response to come back
		var onreadystatechange = function(isTimeout){
			// The request was aborted, clear the interval and decrement jQuery.active
			if (xhr.readyState == 0) {
				if (ival) {
					// clear poll interval
					clearInterval(ival);
					ival = null;
					// Handle the global AJAX counter
					if ( s.global && ! --jQuery.active )
						jQuery.event.trigger( "ajaxStop" );
				}
			// The transfer is complete and the data is available, or the request timed out
			} else if ( !requestDone && xhr && (xhr.readyState == 4 || isTimeout == "timeout") ) {
				requestDone = true;

				// clear poll interval
				if (ival) {
					clearInterval(ival);
					ival = null;
				}

				status = isTimeout == "timeout" ? "timeout" :
					!jQuery.httpSuccess( xhr ) ? "error" :
					s.ifModified && jQuery.httpNotModified( xhr, s.url ) ? "notmodified" :
					"success";

				if ( status == "success" ) {
					// Watch for, and catch, XML document parse errors
					try {
						// process the data (runs the xml through httpData regardless of callback)
						data = jQuery.httpData( xhr, s.dataType, s );
					} catch(e) {
						status = "parsererror";
					}
				}

				// Make sure that the request was successful or notmodified
				if ( status == "success" ) {
					// Cache Last-Modified header, if ifModified mode.
					var modRes;
					try {
						modRes = xhr.getResponseHeader("Last-Modified");
					} catch(e) {} // swallow exception thrown by FF if header is not available

					if ( s.ifModified && modRes )
						jQuery.lastModified[s.url] = modRes;

					// JSONP handles its own success callback
					if ( !jsonp )
						success();
				} else
					jQuery.handleError(s, xhr, status);

				// Fire the complete handlers
				complete();

				if ( isTimeout )
					xhr.abort();

				// Stop memory leaks
				if ( s.async )
					xhr = null;
			}
		};

		if ( s.async ) {
			// don't attach the handler to the request, just poll it instead
			var ival = setInterval(onreadystatechange, 13);

			// Timeout checker
			if ( s.timeout > 0 )
				setTimeout(function(){
					// Check to see if the request is still happening
					if ( xhr && !requestDone )
						onreadystatechange( "timeout" );
				}, s.timeout);
		}

		// Send the data
		try {
			xhr.send(s.data);
		} catch(e) {
			jQuery.handleError(s, xhr, null, e);
		}

		// firefox 1.5 doesn't fire statechange for sync requests
		if ( !s.async )
			onreadystatechange();

		function success(){
			// If a local callback was specified, fire it and pass it the data
			if ( s.success )
				s.success( data, status );

			// Fire the global callback
			if ( s.global )
				jQuery.event.trigger( "ajaxSuccess", [xhr, s] );
		}

		function complete(){
			// Process result
			if ( s.complete )
				s.complete(xhr, status);

			// The request was completed
			if ( s.global )
				jQuery.event.trigger( "ajaxComplete", [xhr, s] );

			// Handle the global AJAX counter
			if ( s.global && ! --jQuery.active )
				jQuery.event.trigger( "ajaxStop" );
		}

		// return XMLHttpRequest to allow aborting the request etc.
		return xhr;
	},

	handleError: function( s, xhr, status, e ) {
		// If a local callback was specified, fire it
		if ( s.error ) s.error( xhr, status, e );

		// Fire the global callback
		if ( s.global )
			jQuery.event.trigger( "ajaxError", [xhr, s, e] );
	},

	// Counter for holding the number of active queries
	active: 0,

	// Determines if an XMLHttpRequest was successful or not
	httpSuccess: function( xhr ) {
		try {
			// IE error sometimes returns 1223 when it should be 204 so treat it as success, see #1450
			return !xhr.status && location.protocol == "file:" ||
				( xhr.status >= 200 && xhr.status < 300 ) || xhr.status == 304 || xhr.status == 1223;
		} catch(e){}
		return false;
	},

	// Determines if an XMLHttpRequest returns NotModified
	httpNotModified: function( xhr, url ) {
		try {
			var xhrRes = xhr.getResponseHeader("Last-Modified");

			// Firefox always returns 200. check Last-Modified date
			return xhr.status == 304 || xhrRes == jQuery.lastModified[url];
		} catch(e){}
		return false;
	},

	httpData: function( xhr, type, s ) {
		var ct = xhr.getResponseHeader("content-type"),
			xml = type == "xml" || !type && ct && ct.indexOf("xml") >= 0,
			data = xml ? xhr.responseXML : xhr.responseText;

		if ( xml && data.documentElement.tagName == "parsererror" )
			throw "parsererror";
			
		// Allow a pre-filtering function to sanitize the response
		// s != null is checked to keep backwards compatibility
		if( s && s.dataFilter )
			data = s.dataFilter( data, type );

		// The filter can actually parse the response
		if( typeof data === "string" ){

			// If the type is "script", eval it in global context
			if ( type == "script" )
				jQuery.globalEval( data );

			// Get the JavaScript object, if JSON is used.
			if ( type == "json" )
				data = window["eval"]("(" + data + ")");
		}
		
		return data;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a ) {
		var s = [ ];

		function add( key, value ){
			s[ s.length ] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
		};

		// If an array was passed in, assume that it is an array
		// of form elements
		if ( jQuery.isArray(a) || a.jquery )
			// Serialize the form elements
			jQuery.each( a, function(){
				add( this.name, this.value );
			});

		// Otherwise, assume that it's an object of key/value pairs
		else
			// Serialize the key/values
			for ( var j in a )
				// If the value is an array then the key names need to be repeated
				if ( jQuery.isArray(a[j]) )
					jQuery.each( a[j], function(){
						add( j, this );
					});
				else
					add( j, jQuery.isFunction(a[j]) ? a[j]() : a[j] );

		// Return the resulting serialization
		return s.join("&").replace(/%20/g, "+");
	}

});
var elemdisplay = {},
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	];

function genFx( type, num ){
	var obj = {};
	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function(){
		obj[ this ] = type;
	});
	return obj;
}

jQuery.fn.extend({
	show: function(speed,callback){
		if ( speed ) {
			return this.animate( genFx("show", 3), speed, callback);
		} else {
			for ( var i = 0, l = this.length; i < l; i++ ){
				var old = jQuery.data(this[i], "olddisplay");
				
				this[i].style.display = old || "";
				
				if ( jQuery.css(this[i], "display") === "none" ) {
					var tagName = this[i].tagName, display;
					
					if ( elemdisplay[ tagName ] ) {
						display = elemdisplay[ tagName ];
					} else {
						var elem = jQuery("<" + tagName + " />").appendTo("body");
						
						display = elem.css("display");
						if ( display === "none" )
							display = "block";
						
						elem.remove();
						
						elemdisplay[ tagName ] = display;
					}
					
					jQuery.data(this[i], "olddisplay", display);
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( var i = 0, l = this.length; i < l; i++ ){
				this[i].style.display = jQuery.data(this[i], "olddisplay") || "";
			}
			
			return this;
		}
	},

	hide: function(speed,callback){
		if ( speed ) {
			return this.animate( genFx("hide", 3), speed, callback);
		} else {
			for ( var i = 0, l = this.length; i < l; i++ ){
				var old = jQuery.data(this[i], "olddisplay");
				if ( !old && old !== "none" )
					jQuery.data(this[i], "olddisplay", jQuery.css(this[i], "display"));
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( var i = 0, l = this.length; i < l; i++ ){
				this[i].style.display = "none";
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2 ){
		var bool = typeof fn === "boolean";

		return jQuery.isFunction(fn) && jQuery.isFunction(fn2) ?
			this._toggle.apply( this, arguments ) :
			fn == null || bool ?
				this.each(function(){
					var state = bool ? fn : jQuery(this).is(":hidden");
					jQuery(this)[ state ? "show" : "hide" ]();
				}) :
				this.animate(genFx("toggle", 3), fn, fn2);
	},

	fadeTo: function(speed,to,callback){
		return this.animate({opacity: to}, speed, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed(speed, easing, callback);

		return this[ optall.queue === false ? "each" : "queue" ](function(){
		
			var opt = jQuery.extend({}, optall), p,
				hidden = this.nodeType == 1 && jQuery(this).is(":hidden"),
				self = this;
	
			for ( p in prop ) {
				if ( prop[p] == "hide" && hidden || prop[p] == "show" && !hidden )
					return opt.complete.call(this);

				if ( ( p == "height" || p == "width" ) && this.style ) {
					// Store display property
					opt.display = jQuery.css(this, "display");

					// Make sure that nothing sneaks out
					opt.overflow = this.style.overflow;
				}
			}

			if ( opt.overflow != null )
				this.style.overflow = "hidden";

			opt.curAnim = jQuery.extend({}, prop);

			jQuery.each( prop, function(name, val){
				var e = new jQuery.fx( self, opt, name );

				if ( /toggle|show|hide/.test(val) )
					e[ val == "toggle" ? hidden ? "show" : "hide" : val ]( prop );
				else {
					var parts = val.toString().match(/^([+-]=)?([\d+-.]+)(.*)$/),
						start = e.cur(true) || 0;

					if ( parts ) {
						var end = parseFloat(parts[2]),
							unit = parts[3] || "px";

						// We need to compute starting value
						if ( unit != "px" ) {
							self.style[ name ] = (end || 1) + unit;
							start = ((end || 1) / e.cur(true)) * start;
							self.style[ name ] = start + unit;
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] )
							end = ((parts[1] == "-=" ? -1 : 1) * end) + start;

						e.custom( start, end, unit );
					} else
						e.custom( start, val, "" );
				}
			});

			// For JS strict compliance
			return true;
		});
	},

	stop: function(clearQueue, gotoEnd){
		var timers = jQuery.timers;

		if (clearQueue)
			this.queue([]);

		this.each(function(){
			// go in reverse order so anything added to the queue during the loop is ignored
			for ( var i = timers.length - 1; i >= 0; i-- )
				if ( timers[i].elem == this ) {
					if (gotoEnd)
						// force the next step to be the last
						timers[i](true);
					timers.splice(i, 1);
				}
		});

		// start the next in the queue if the last step wasn't forced
		if (!gotoEnd)
			this.dequeue();

		return this;
	}

});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show", 1),
	slideUp: genFx("hide", 1),
	slideToggle: genFx("toggle", 1),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" }
}, function( name, props ){
	jQuery.fn[ name ] = function( speed, callback ){
		return this.animate( props, speed, callback );
	};
});

jQuery.extend({

	speed: function(speed, easing, fn) {
		var opt = typeof speed === "object" ? speed : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			jQuery.fx.speeds[opt.duration] || jQuery.fx.speeds._default;

		// Queueing
		opt.old = opt.complete;
		opt.complete = function(){
			if ( opt.queue !== false )
				jQuery(this).dequeue();
			if ( jQuery.isFunction( opt.old ) )
				opt.old.call( this );
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ){
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		if ( !options.orig )
			options.orig = {};
	}

});

jQuery.fx.prototype = {

	// Simple function for setting a style value
	update: function(){
		if ( this.options.step )
			this.options.step.call( this.elem, this.now, this );

		(jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );

		// Set display property to block for height/width animations
		if ( ( this.prop == "height" || this.prop == "width" ) && this.elem.style )
			this.elem.style.display = "block";
	},

	// Get the current size
	cur: function(force){
		if ( this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null) )
			return this.elem[ this.prop ];

		var r = parseFloat(jQuery.css(this.elem, this.prop, force));
		return r && r > -10000 ? r : parseFloat(jQuery.curCSS(this.elem, this.prop)) || 0;
	},

	// Start an animation from one number to another
	custom: function(from, to, unit){
		this.startTime = now();
		this.start = from;
		this.end = to;
		this.unit = unit || this.unit || "px";
		this.now = this.start;
		this.pos = this.state = 0;

		var self = this;
		function t(gotoEnd){
			return self.step(gotoEnd);
		}

		t.elem = this.elem;

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval(function(){
				var timers = jQuery.timers;

				for ( var i = 0; i < timers.length; i++ )
					if ( !timers[i]() )
						timers.splice(i--, 1);

				if ( !timers.length ) {
					clearInterval( timerId );
					timerId = undefined;
				}
			}, 13);
		}
	},

	// Simple 'show' function
	show: function(){
		// Remember where we started, so that we can go back to it later
		this.options.orig[this.prop] = jQuery.attr( this.elem.style, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any
		// flash of content
		this.custom(this.prop == "width" || this.prop == "height" ? 1 : 0, this.cur());

		// Start by showing the element
		jQuery(this.elem).show();
	},

	// Simple 'hide' function
	hide: function(){
		// Remember where we started, so that we can go back to it later
		this.options.orig[this.prop] = jQuery.attr( this.elem.style, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom(this.cur(), 0);
	},

	// Each step of an animation
	step: function(gotoEnd){
		var t = now();

		if ( gotoEnd || t >= this.options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			this.options.curAnim[ this.prop ] = true;

			var done = true;
			for ( var i in this.options.curAnim )
				if ( this.options.curAnim[i] !== true )
					done = false;

			if ( done ) {
				if ( this.options.display != null ) {
					// Reset the overflow
					this.elem.style.overflow = this.options.overflow;

					// Reset the display
					this.elem.style.display = this.options.display;
					if ( jQuery.css(this.elem, "display") == "none" )
						this.elem.style.display = "block";
				}

				// Hide the element if the "hide" operation was done
				if ( this.options.hide )
					jQuery(this.elem).hide();

				// Reset the properties, if the item has been hidden or shown
				if ( this.options.hide || this.options.show )
					for ( var p in this.options.curAnim )
						jQuery.attr(this.elem.style, p, this.options.orig[p]);
					
				// Execute the complete function
				this.options.complete.call( this.elem );
			}

			return false;
		} else {
			var n = t - this.startTime;
			this.state = n / this.options.duration;

			// Perform the easing function, defaults to swing
			this.pos = jQuery.easing[this.options.easing || (jQuery.easing.swing ? "swing" : "linear")](this.state, n, 0, 1, this.options.duration);
			this.now = this.start + ((this.end - this.start) * this.pos);

			// Perform the next step of the animation
			this.update();
		}

		return true;
	}

};

jQuery.extend( jQuery.fx, {
	speeds:{
		slow: 600,
 		fast: 200,
 		// Default speed
 		_default: 400
	},
	step: {

		opacity: function(fx){
			jQuery.attr(fx.elem.style, "opacity", fx.now);
		},

		_default: function(fx){
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null )
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			else
				fx.elem[ fx.prop ] = fx.now;
		}
	}
});
if ( document.documentElement["getBoundingClientRect"] )
	jQuery.fn.offset = function() {
		if ( !this[0] ) return { top: 0, left: 0 };
		if ( this[0] === this[0].ownerDocument.body ) return jQuery.offset.bodyOffset( this[0] );
		var box  = this[0].getBoundingClientRect(), doc = this[0].ownerDocument, body = doc.body, docElem = doc.documentElement,
			clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
			top  = box.top  + (self.pageYOffset || jQuery.boxModel && docElem.scrollTop  || body.scrollTop ) - clientTop,
			left = box.left + (self.pageXOffset || jQuery.boxModel && docElem.scrollLeft || body.scrollLeft) - clientLeft;
		return { top: top, left: left };
	};
else 
	jQuery.fn.offset = function() {
		if ( !this[0] ) return { top: 0, left: 0 };
		if ( this[0] === this[0].ownerDocument.body ) return jQuery.offset.bodyOffset( this[0] );
		jQuery.offset.initialized || jQuery.offset.initialize();

		var elem = this[0], offsetParent = elem.offsetParent, prevOffsetParent = elem,
			doc = elem.ownerDocument, computedStyle, docElem = doc.documentElement,
			body = doc.body, defaultView = doc.defaultView,
			prevComputedStyle = defaultView.getComputedStyle(elem, null),
			top = elem.offsetTop, left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			computedStyle = defaultView.getComputedStyle(elem, null);
			top -= elem.scrollTop, left -= elem.scrollLeft;
			if ( elem === offsetParent ) {
				top += elem.offsetTop, left += elem.offsetLeft;
				if ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && /^t(able|d|h)$/i.test(elem.tagName)) )
					top  += parseInt( computedStyle.borderTopWidth,  10) || 0,
					left += parseInt( computedStyle.borderLeftWidth, 10) || 0;
				prevOffsetParent = offsetParent, offsetParent = elem.offsetParent;
			}
			if ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" )
				top  += parseInt( computedStyle.borderTopWidth,  10) || 0,
				left += parseInt( computedStyle.borderLeftWidth, 10) || 0;
			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" )
			top  += body.offsetTop,
			left += body.offsetLeft;

		if ( prevComputedStyle.position === "fixed" )
			top  += Math.max(docElem.scrollTop, body.scrollTop),
			left += Math.max(docElem.scrollLeft, body.scrollLeft);

		return { top: top, left: left };
	};

jQuery.offset = {
	initialize: function() {
		if ( this.initialized ) return;
		var body = document.body, container = document.createElement('div'), innerDiv, checkDiv, table, td, rules, prop, bodyMarginTop = body.style.marginTop,
			html = '<div style="position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;"><div></div></div><table style="position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;" cellpadding="0" cellspacing="0"><tr><td></td></tr></table>';

		rules = { position: 'absolute', top: 0, left: 0, margin: 0, border: 0, width: '1px', height: '1px', visibility: 'hidden' };
		for ( prop in rules ) container.style[prop] = rules[prop];

		container.innerHTML = html;
		body.insertBefore(container, body.firstChild);
		innerDiv = container.firstChild, checkDiv = innerDiv.firstChild, td = innerDiv.nextSibling.firstChild.firstChild;

		this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
		this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

		innerDiv.style.overflow = 'hidden', innerDiv.style.position = 'relative';
		this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

		body.style.marginTop = '1px';
		this.doesNotIncludeMarginInBodyOffset = (body.offsetTop === 0);
		body.style.marginTop = bodyMarginTop;

		body.removeChild(container);
		this.initialized = true;
	},

	bodyOffset: function(body) {
		jQuery.offset.initialized || jQuery.offset.initialize();
		var top = body.offsetTop, left = body.offsetLeft;
		if ( jQuery.offset.doesNotIncludeMarginInBodyOffset )
			top  += parseInt( jQuery.curCSS(body, 'marginTop',  true), 10 ) || 0,
			left += parseInt( jQuery.curCSS(body, 'marginLeft', true), 10 ) || 0;
		return { top: top, left: left };
	}
};


jQuery.fn.extend({
	position: function() {
		var left = 0, top = 0, results;

		if ( this[0] ) {
			// Get *real* offsetParent
			var offsetParent = this.offsetParent(),

			// Get correct offsets
			offset       = this.offset(),
			parentOffset = /^body|html$/i.test(offsetParent[0].tagName) ? { top: 0, left: 0 } : offsetParent.offset();

			// Subtract element margins
			// note: when an element has margin: auto the offsetLeft and marginLeft 
			// are the same in Safari causing offset.left to incorrectly be 0
			offset.top  -= num( this, 'marginTop'  );
			offset.left -= num( this, 'marginLeft' );

			// Add offsetParent borders
			parentOffset.top  += num( offsetParent, 'borderTopWidth'  );
			parentOffset.left += num( offsetParent, 'borderLeftWidth' );

			// Subtract the two offsets
			results = {
				top:  offset.top  - parentOffset.top,
				left: offset.left - parentOffset.left
			};
		}

		return results;
	},

	offsetParent: function() {
		var offsetParent = this[0].offsetParent || document.body;
		while ( offsetParent && (!/^body|html$/i.test(offsetParent.tagName) && jQuery.css(offsetParent, 'position') == 'static') )
			offsetParent = offsetParent.offsetParent;
		return jQuery(offsetParent);
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( ['Left', 'Top'], function(i, name) {
	var method = 'scroll' + name;
	
	jQuery.fn[ method ] = function(val) {
		if (!this[0]) return null;

		return val !== undefined ?

			// Set the scroll offset
			this.each(function() {
				this == window || this == document ?
					window.scrollTo(
						!i ? val : jQuery(window).scrollLeft(),
						 i ? val : jQuery(window).scrollTop()
					) :
					this[ method ] = val;
			}) :

			// Return the scroll offset
			this[0] == window || this[0] == document ?
				self[ i ? 'pageYOffset' : 'pageXOffset' ] ||
					jQuery.boxModel && document.documentElement[ method ] ||
					document.body[ method ] :
				this[0][ method ];
	};
});
// Create innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function(i, name){

	var tl = i ? "Left"  : "Top",  // top or left
		br = i ? "Right" : "Bottom", // bottom or right
		lower = name.toLowerCase();

	// innerHeight and innerWidth
	jQuery.fn["inner" + name] = function(){
		return this[0] ?
			jQuery.css( this[0], lower, false, "padding" ) :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn["outer" + name] = function(margin) {
		return this[0] ?
			jQuery.css( this[0], lower, false, margin ? "margin" : "border" ) :
			null;
	};
	
	var type = name.toLowerCase();

	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		return this[0] == window ?
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			document.compatMode == "CSS1Compat" && document.documentElement[ "client" + name ] ||
			document.body[ "client" + name ] :

			// Get document width or height
			this[0] == document ?
				// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
				Math.max(
					document.documentElement["client" + name],
					document.body["scroll" + name], document.documentElement["scroll" + name],
					document.body["offset" + name], document.documentElement["offset" + name]
				) :

				// Get or set width or height on the element
				size === undefined ?
					// Get width or height on the element
					(this.length ? jQuery.css( this[0], type ) : null) :

					// Set the width or height on the element (default to pixels if value is unitless)
					this.css( type, typeof size === "string" ? size : size + "px" );
	};

});
})();

blob
mark :588
data 1557
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" >
  <span tal:omit-tag="true" i18n:translate="" >List of keywords</span>
  <span tal:condition="request/dispname"
   tal:replace="python:' - %s '%request.dispname"
  /> - <span tal:replace="config/TRACKER_NAME" />
</title>
<span metal:fill-slot="body_title" tal:omit-tag="true">
  <span tal:omit-tag="true" i18n:translate="" >List of keywords</span>
  <span tal:condition="request/dispname"
   tal:replace="python:' - %s' % request.dispname" />
</span>
<tal:block metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<table width="100%" tal:condition="context/is_view_ok" class="list">
<tr>
 <th i18n:translate="">Keyword</th>
 <th i18n:translate="">Description</th>
</tr>

<tal:block repeat="keyword context/list">
<tr tal:attributes="class python:['normal', 'alt'][repeat['keyword'].index%6/3]">
 <td>
  <a tal:attributes="href string:keyword${keyword/id}"
     tal:content="keyword/name">keyword name</a>
 </td>
 <td tal:content="python:keyword.description.plain() or
     default">&nbsp;</td>
</tr>
</tal:block>

<tr tal:condition="context/is_edit_ok">
   <td colspan="2"><a href="keyword?@template=item">New Keyword</a></td>
</tr>
</table>

</tal:block>
</tal:block>

blob
mark :589
data 2654
<tal:doc metal:use-macro="templates/page/macros/frame"
define="edit_ok context/is_edit_ok"
>
<title metal:fill-slot="head_title">
<tal:if condition="context/id" i18n:translate=""
 >Keyword <span tal:replace="context/id" i18n:name="id"
 />: <span tal:replace="context/name" i18n:name="title"
 /> - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:if>
<tal:if condition="not:context/id" i18n:translate=""
 >New Keyword - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:if>
</title>
<metal:slot fill-slot="more-javascript">
<script type="text/javascript" src="@@file/help_controls.js"></script>
</metal:slot>
<tal:block metal:fill-slot="body_title"
  define="edit_ok context/is_edit_ok">
 <span tal:condition="python: not (context.id or edit_ok)"
  tal:omit-tag="python:1" i18n:translate="">New Keyword</span>
 <span tal:condition="python: not context.id and edit_ok"
  tal:omit-tag="python:1" i18n:translate="">New Keyword Editing</span>
 <span tal:condition="python: context.id and not edit_ok"
  tal:omit-tag="python:1" i18n:translate="">Keyword<tal:x
  replace="context/id" i18n:name="id" /></span>
 <span tal:condition="python: context.id and edit_ok"
  tal:omit-tag="python:1" i18n:translate="">Keyword<tal:x
  replace="context/id" i18n:name="id" /> Editing</span>
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<div tal:condition="context/is_view_ok">

<form method="POST"
      tal:define="required python:'name description'.split()"
      enctype="multipart/form-data"
      tal:attributes="action context/designator;">

<table class="form">

<tr>
 <th class="required" i18n:translate="">Keyword:</th>
 <td tal:content="structure
 python:context.name.field(size=60)">title</td>
</tr>

<tr>
 <th class="required" i18n:translate="">Description:</th>
 <td tal:content="structure python:context.description.field(size=60)">description</td>

</tr>

 <tr tal:condition="context/is_edit_ok">
  <td>
   &nbsp;
   <input type="hidden" name="@template" value="item">
   <input type="hidden" name="@required" value="name,description"
          tal:attributes="value python:','.join(required)">
  </td>
  <td><input type="submit" value="save" tal:replace="structure context/submit"><!--submit button here-->
    <input type="reset">
  </td>
 </tr>

</table>
</form>
</div>
</td>
</tal:doc>

blob
mark :590
data 5488
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" >
  <span tal:omit-tag="true" i18n:translate="" >List of milestones</span>
  <span tal:condition="request/dispname"
   tal:replace="python:' - %s '%request.dispname"
  /> - <span tal:replace="config/TRACKER_NAME" />
</title>
<span metal:fill-slot="body_title" tal:omit-tag="true">
  <span tal:omit-tag="true" i18n:translate="" >List of milestones</span>
  <span tal:condition="request/dispname"
   tal:replace="python:' - %s' % request.dispname" />
</span>
<tal:block metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<tal:block tal:define="batch request/batch" tal:condition="context/is_view_ok">
 <table class="list">
  <tr>
   <th tal:condition="request/show/id" i18n:translate="">ID</th>
   <th tal:condition="request/show/title" i18n:translate="">Title</th>
   <th tal:condition="request/show/status"    i18n:translate="">Status</th>
<!--   <th tal:condition="request/show/type" i18n:translate="">Type</th>-->
  </tr>
 <tal:block tal:repeat="i batch" condition=true>
  <tr tal:define="group python:[r[1] for r in request.group]"
      tal:condition="python:group and batch.propchanged(*group)">
   <th tal:attributes="colspan python:len(request.columns)" class="group">
    <tal:block tal:repeat="g group">
     <tal:block tal:content="python:str(i[g]) or '(no %s set)'%g"/>
    </tal:block>
   </th>
  </tr>

  <tr tal:attributes="class python:['even','odd'][repeat['i'].even()]">
   <td tal:condition="request/show/id" tal:content="i/id">&nbsp;</td>
   <td tal:condition="request/show/title">
    <a tal:attributes="href string:milestone${i/id}"
		tal:content="python:str(i.title.plain(hyperlink=0)) or '[no title]'">title</a>
   </td>
   <td tal:condition="request/show/status"
       tal:content="python:i.status.plain() or default">&nbsp;</td>
  </tr>

 </tal:block>

 <metal:index define-macro="batch-footer">
 <tr tal:condition="batch">
  <th tal:attributes="colspan python:len(request.columns)">
   <table width="100%">
    <tr class="navigation">
     <th>
      <a tal:define="prev batch/previous" tal:condition="prev"
         tal:attributes="href python:request.indexargs_url(request.classname,
         {'@startwith':prev.first, '@pagesize':prev.size})"
         i18n:translate="">&lt;&lt; previous</a>
      &nbsp;
     </th>
     <th i18n:translate=""><span tal:replace="batch/start" i18n:name="start"
     />..<span tal:replace="python: batch.start + batch.length -1" i18n:name="end"
     /> out of <span tal:replace="batch/sequence_length" i18n:name="total"
     /></th>
     <th>
      <a tal:define="next batch/next" tal:condition="next"
         tal:attributes="href python:request.indexargs_url(request.classname,
         {'@startwith':next.first, '@pagesize':next.size})"
         i18n:translate="">next &gt;&gt;</a>
      &nbsp;
     </th>
    </tr>
   </table>
  </th>
 </tr>
 </metal:index>
</table>
<!--
<a tal:attributes="href python:request.indexargs_url('milestone',
            {'@action':'export_csv'})" i18n:translate="">Download as CSV</a>
-->
<form method="get" class="index-controls"
    tal:attributes="action request/classname">

 <table class="form" tal:define="n_sort python:2">
<!--
<tal:block tal:repeat="n python:range(n_sort)" tal:condition="batch">
  <tr tal:define="key python:len(request.sort)>n and request.sort[n]">
   <th>
    <tal:block tal:condition="not:n" i18n:translate="">Sort on:</tal:block>
   </th>
   <td>
    <select tal:attributes="name python:'@sort%d'%n">
     <option value="" i18n:translate="">- nothing -</option>
     <option tal:repeat="col context/properties"
             tal:attributes="value col/_name;
                             selected python:key and col._name == key[1]"
             tal:content="col/_name"
             i18n:translate="">column</option>
    </select>
   </td>
   <th i18n:translate="">Descending:</th>
   <td><input type="checkbox" tal:attributes="name python:'@sortdir%d'%n;
              checked python:key and key[0] == '-'"/>
   </td>
  </tr>
  </tal:block>
  -->
  <tal:block tal:repeat="n python:range(n_sort)" tal:condition="batch">
  <tr tal:define="key python:len(request.group)>n and request.group[n]">
   <th>
    <tal:block tal:condition="not:n" i18n:translate="">Group on:</tal:block>
   </th>
   <td>
    <select tal:attributes="name python:'@group%d'%n">
     <option value="" i18n:translate="">- nothing -</option>
     <option tal:repeat="col context/properties"
             tal:attributes="value col/_name;
                             selected python:key and col._name == key[1]"
             tal:content="col/_name"
             i18n:translate="">column</option>
    </select>
   </td>
   <th i18n:translate="">Descending:</th>
   <td><input type="checkbox" tal:attributes="name python:'@groupdir%d'%n;
              checked python:key and key[0] == '-'"/>
   </td>
  </tr>
  </tal:block>
  <tr><td colspan="4">
              <input type="submit" value="Redisplay" i18n:attributes="value"/>
              <tal:block tal:replace="structure
                python:request.indexargs_form(sort=0, group=0)" />
  </td></tr>
 </table>
</form>

</tal:block>
</tal:block>
</tal:block>

blob
mark :591
data 5377
<!-- HEADER -->

<tal:block metal:use-macro="templates/page/macros/frame">
  <tal:block metal:fill-slot="body_title">
    <p class="header">Milestone<span tal:replace="context/id" /> Editing</p>
  </tal:block>

  <tal:block metal:fill-slot="content">

    <tal:block tal:condition="python:context.is_view_ok or context.is_edit_ok">

<!-- BODY -->

<form method="post" id="itemSynopsis" onSubmit="return submit_once()"
      enctype="multipart/form-data">

  <p><input type="hidden" name=":template" value="item" /></p>

  <table class="form">

    <!-- Title -->
    <tr>
      <th class="required">Title</th>
      <td colspan="5"
          tal:condition="python: request.user.hasPermission('Process')"
          tal:content="structure python:context.title.field(size=60)">
        title
      </td>
      <td colspan="5"
          tal:condition="python: not request.user.hasPermission('Process')"
          tal:content="structure context/title/plain">
        title
      </td>
    </tr>

    <!-- creation, creator, activity -->
    <tr tal:condition="context/id">
      <td colspan="6"
          tal:content="structure string:Created on
            <b>${context/creation}</b> by <b>${context/creator}</b>, last
            changed <b>${context/activity}</b>.">last changed
      </td>
    </tr>

    <!-- status -->
    <tr tal:condition="context/id">
      <th>
        <a href="javascript:help_window('status?:template=help&properties=name,d
escription', 500, 400)">status</a>
      </th>
      <td colspan="5"
          tal:condition="python: request.user.hasPermission('Process')"
          tal:content="structure context/status/menu">
        status
      </td>
      <td colspan="5"
          tal:condition="python: not request.user.hasPermission('Process')"
          tal:content="structure context/status/plain">
        status
      </td>
    </tr>

    <tr>
      <th>Bugs</th>
      <td colspan="2"
          tal:condition="python: request.user.hasPermission('Process')">
        <table>
          <tr>
	    <td>Add: <input name=":add:bugs"  size="20" /></td>
            </tr>
            <tr tal:repeat="bug context/bugs">
              <td>
                <a tal:attributes="href string:bug${bug/id}; title string:${bug/title}"
                   tal:content="string:bug${bug/id}">&nbsp</a>
              </td>
              <td>
                <input type="checkbox"
                       name=":remove:bugs"
                       tal:attributes="value bug/id" />
                remove
              </td>
            </tr>
        </table>
      </td>
      <td colspan="2"
        tal:condition="python: not request.user.hasPermission('Process')">
        <span tal:condition="context/bugs"
              tal:repeat="bug context/bugs">
          <br/>View:
          <a tal:attributes="href string:bug${bug/id};
                             title string:${bug/title}"
             tal:content="string:bug${bug/id}">
          &nbsp;
          </a>
        </span>
      </td>
    </tr>

    <!-- Comment -->
    <tr>  
      <th>Add Comment:</th>
      <td colspan="5" class="form-text">
        <textarea name=":note" wrap="hard" rows="5" cols="50"></textarea>
      </td>
    </tr>

    <!-- Files -->
    <tr>
      <th>File</th>
      <td colspan="5"><input type="file" name=":file" size="40" /></td>
    </tr>

    <!-- Nosy List -->
    <tr>
      <th>
        CC List:<span tal:replace="structure python:db.user.classhelp('username,realname,address', property='nosy', label='?', width=500)" />
      </th>
      <td colspan="5">
        <span tal:replace="structure context/nosy/field" />
      </td>
    </tr>
  </table>

  <!-- graph -->
  <p tal:condition="context/id">
View the <a tal:attributes="href string:/graph?type=milestone&id=${context/id}&output=cmap">dependency graph</a> for this milestone.
  </p>

  <!-- Submit -->
  <p tal:content="structure context/submit">
    submit button will go here
  </p>

  <tal:block tal:condition="context/id">
    <!-- Messages -->
    <table class="messages" tal:condition="context/messages">
      <tr><th colspan="3" class="header">Messages</th></tr>
      <tal:block tal:repeat="msg context/messages">
        <tr>
          <th tal:content="string:Author: ${msg/author}">author</th>
          <th tal:content="string:Date: ${msg/date}">date</th>
        </tr>
        <tr>
          <td colspan="2"><pre tal:content="msg/content">content</pre></td>
        </tr>
      </tal:block>
    </table>

    <!-- Files -->
    <table class="files" tal:condition="context/files">
      <tr><th colspan="2" class="header">Files</th></tr>
      <tr><th>File name</th><th>Uploaded</th></tr>
      <tr tal:repeat="file context/files">
        <td>
          <a tal:attributes="href string:file${file/id}/${file/name}"
             tal:content="file/name">dld link</a>
        </td>
        <td>
          <span tal:content="file/creator">creator's name</span>,
          <span tal:content="file/creation">creation date</span>
        </td>
      </tr>
    </table>

    <!-- Sort ascending -->
    <tal:block tal:replace="structure python:context.history(direction='ascending')" />   

  </tal:block>
</form>

<!-- FOOTER -->
    </tal:block>
    <span tal:condition="python:not (context.is_view_ok or context.is_edit_ok)">
You are not allowed to view this page.
    </span>

  </tal:block>
</tal:block>


blob
mark :592
data 937
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate=""
 >List of messages - <span tal:replace="config/TRACKER_NAME"
 i18n:name="tracker"/></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
 i18n:translate="">Message listing</span>
<td class="content" metal:fill-slot="content">
<table tal:define="batch request/batch" class="messages">
 <tr><th colspan=3 class="header" i18n:translate="">Messages</th></tr>
 <tal:block tal:repeat="msg batch">
  <tr>
   <th><a tal:attributes="href string:msg${msg/id}"><tal:x replace="msg/id"/></a></th>
   <th tal:content="string:Author: ${msg/author}">author</th>
   <th tal:content="string:Date: ${msg/date}">date</th>
  </tr>
  <tr>
   <td colspan="3"><pre tal:content="msg/content">content</pre></td>
  </tr>
 </tal:block>

 <metal:block use-macro="templates/issue.index/macros/batch-footer" />

</table>
</td>

</tal:block>

blob
mark :593
data 3981
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title">
<tal:block condition="context/id" i18n:translate=""
 >Message <span tal:replace="context/id" i18n:name="id"
 /> - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
<tal:block condition="not:context/id" i18n:translate=""
 >New Message - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
</title>
<tal:block metal:fill-slot="body_title">
 <span tal:condition="python: not (context.id or context.is_edit_ok())"
  tal:omit-tag="python:1" i18n:translate="">New Message</span>
 <span tal:condition="python: not context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">New Message Editing</span>
 <span tal:condition="python: context.id and not context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Message<tal:x
  replace="context/id" i18n:name="id" /></span>
 <span tal:condition="python: context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Message<tal:x
  replace="context/id" i18n:name="id" /> Editing</span>
</tal:block>
<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<div tal:condition="context/is_view_ok">
<table class="form">

<tr>
 <th i18n:translate="">Author</th>
 <td tal:content="context/author"></td>
</tr>

<tr>
 <th i18n:translate="">Recipients</th>
 <td tal:content="context/recipients"></td>
</tr>

<tr>
 <th i18n:translate="">Date</th>
 <td tal:content="context/date"></td>
</tr>

 <tr>
  <th i18n:translate="">Message-id</th>
  <td tal:content="context/messageid"></td>
 </tr>

 <tr>
  <th i18n:translate="">In-reply-to</th>
  <td tal:content="context/inreplyto"></td>
 </tr>

</table>

<!--<p tal:condition="python:utils.sb_is_spam(context)" class="error-message">
   Message has been classified as spam</p>-->

<table class="messages">

<!-- <tr>
   <th class="header" i18n:translate="">Content</th>
   <th class="header"
   tal:condition="python:request.user.hasPermission('SB: May Classify')">
     <form method="POST" onSubmit="return submit_once()"
       enctype="multipart/form-data"
       tal:attributes="action context/designator">
 
      <input type="hidden" name="@action" value="spambayes_classify">
      <input type="submit" name="trainspam" value="Mark as SPAM" i18n:attributes="value">
      <input type="submit" name="trainham" value="Mark as HAM (not SPAM)" i18n:attributes="value">
     </form>
   </th>

</tr>-->

 <tr>
  <td class="content" colspan="2"
      tal:condition="python:context.content.is_view_ok()">
      <pre
      tal:content="structure python:utils.localReplace(context.content.hyperlinked())"></pre></td>
  <td class="content" colspan="2"
      tal:condition="python:not context.content.is_view_ok()">
      You are not authorized to see this message.
<!--            Message has been classified as spam and is therefore not
      available to unathorized users. If you think this is
      incorrect, please login and report the message as being
      misclassified. -->
  </td> 
 </tr>
</table>

<table class="files" tal:condition="context/files">
 <tr><th colspan="2" class="header" i18n:translate="">Files</th></tr>
 <tr>
  <th i18n:translate="">File name</th>
  <th i18n:translate="">Uploaded</th>
 </tr>
 <tr tal:repeat="file context/files">
  <td>
   <a tal:attributes="href string:file${file/id}/${file/name}"
      tal:content="file/name">dld link</a>
  </td>
  <td>
   <span tal:content="file/creator">creator's name</span>,
   <span tal:content="file/creation">creation date</span>
  </td>
 </tr>
</table>

<tal:block tal:replace="structure context/history" />

</div>
</td>

</tal:block>

blob
mark :594
data 18321
<tal:block metal:define-macro="frame">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <title metal:define-slot="head_title">title goes here</title>
  <link rel="stylesheet" type="text/css" href="@@file/style.css" />
  <meta http-equiv="Content-Type"
        tal:attributes="content string:text/html;; charset=${request/client/charset}" />
  <script tal:replace="structure request/base_javascript"></script>
  <metal:x define-slot="more-javascript" />
 </head>
 <body tal:attributes="class request/classname"
       tal:define="kw_create python:request.user.hasPermission('Create', 'keyword');
                   bug_columns string:id,activity,title,creator,status;
                   bug_columns_showall string:id,activity,title,creator,assignee,status;
                   bug_status_notclosed string:-1,1,2,4;

                   task_columns string:id,activity,title,creator,status;
                   task_columns_showall string:id,activity,title,creator,assignee,status;
                   task_status_notclosed string:-1,1,2,4;

                   milestone_columns string:id,activity,title,creator,status;
                   milestone_columns_showall string:id,activity,title,creator,assignee,status;
                   milestone_status_notclosed string:-1,1,2,4;">
  <div class="header">
   <h1><a href="/">Roundup Demo Tracker</a></h1>
   <div id="searchbox">
    <form name="searchform" method="get" action="bug" id="searchform">
     <div id="search">
      <input type="hidden" name="@columns"
             tal:attributes="value bug_columns_showall"/>
      <input type="hidden" name="@sort" value="-activity" />
      <input type="hidden" name="@group" value="priority" />
      <input type="hidden" name="@filter" value="status"/>
      <input type="hidden" name="status" tal:attributes="value bug_status_notclosed"/>
      <input class="input-text" id="search-text" name="@search_text" size="10" />
      <input type="submit" id="submit" value="search in open bugs" name="submit" class="input-button"/>
     </div>
    </form>
   </div> <!-- searchbox -->
  </div> <!-- header -->
  <div class="navigation">
   <div class="menu">
    <ul>
     <li class="current"><a href="/" i18n:translate="">Bugs</a>
      <ul tal:condition="python:request.user.hasPermission('View', 'bug')">
       <li tal:condition="python:request.user.hasPermission('Create', 'bug')">
        <a href="bug?@template=item" i18n:translate="">Create New</a>
       </li>
       <li>
        <a href="#"
           tal:attributes="href python:request.indexargs_url('bug', {
                                '@sort': '-activity',
                                '@group': 'priority',
                                '@filter': 'status',
                                '@columns': bug_columns_showall,
                                '@search_text': '',
                                'status': bug_status_notclosed,
                                '@dispname': i18n.gettext('Show All'),
                                '@startwith': 0,
                                })"
                i18n:translate="">Show Open</a>
       </li>
       <li><a href="#"
              tal:attributes="href python:request.indexargs_url('bug', {
                                '@sort': '-activity',
                                '@group': 'priority',
                                '@filter': 'status,assignee',
                                '@columns': bug_columns,
                                '@search_text': '',
                                'status': bug_status_notclosed,
                                'assignee': '-1',
                                '@dispname': i18n.gettext('Show Unassigned'),
                                '@startwith': 0,
                                })"
                i18n:translate="">Show Unassigned</a>
       </li>
       <li>
        <a href="bug?@template=search&status=1" i18n:translate="">Search</a>
       </li>
       <li>
        <form method="post" action="#">
         <input type="submit" class="form-small" value="Show bug:" i18n:attributes="value"/>
         <input class="form-small" size="4" type="text" name="@number"/>
         <input type="hidden" name="@type" value="bug"/>
         <input type="hidden" name="@action" value="show"/>
        </form>
       </li>
      </ul>
     </li>
     <li class="current"><a href="/" i18n:translate="">Tasks</a>
      <ul tal:condition="python:request.user.hasPermission('View', 'task')">
       <li tal:condition="python:request.user.hasPermission('Create', 'task')">
        <a href="task?@template=item" i18n:translate="">Create New</a>
       </li>
       <li>
        <a href="#" tal:attributes="href python:request.indexargs_url('task', {
                                '@sort': '-activity',
                                '@group': 'priority',
                                '@filter': 'status',
                                '@columns': task_columns_showall,
                                '@search_text': '',
                                'status': task_status_notclosed,
                                '@dispname': i18n.gettext('Show All'),
                                '@startwith': 0,
                                })"
                i18n:translate="">Show Open</a>
       </li>
       <li>
        <a href="#" tal:attributes="href python:request.indexargs_url('task', {
                                '@sort': '-activity',
                                '@group': 'priority',
                                '@filter': 'status,assignee',
                                '@columns': task_columns,
                                '@search_text': '',
                                'status': task_status_notclosed,
                                'assignee': '-1',
                                '@dispname': i18n.gettext('Show Unassigned'),
                                '@startwith': 0,
                                })"
                i18n:translate="">Show Unassigned</a>
       </li>
       <li>
        <a href="task?@template=search&status=1" i18n:translate="">Search</a>
       </li>
       <li>
        <form method="post" action="#">
         <input type="submit" class="form-small" value="Show task:" i18n:attributes="value"/>
         <input class="form-small" size="4" type="text" name="@number"/>
         <input type="hidden" name="@type" value="task"/>
         <input type="hidden" name="@action" value="show"/>
        </form>
       </li>
      </ul>
     </li>
     <li class="current"><a href="milestone" i18n:translate="">Milestones</a>
      <ul tal:condition="python:request.user.hasPermission('View', 'milestone')">
       <li tal:condition="python:request.user.hasPermission('Create', 'milestone')">
        <a href="milestone?@template=item" i18n:translate="">Create New</a>
       </li>
       <li>
        <a href="#" tal:attributes="href python:request.indexargs_url('milestone', {
                                '@filter': 'status',
                                'status': milestone_status_notclosed,
                                '@dispname': i18n.gettext('Show Open'),
                                '@startwith': 0,
                                })"
                i18n:translate="">Show Open</a>
       </li>
      </ul>
     </li>
    </ul>
    <ul class="user">
     <li tal:condition="python:request.user.username=='anonymous'" class="submenu">
      <b i18n:translate="">User</b>
      <form method="post" action="#">
       <ul>
        <li>
         <tal:span i18n:translate="">Login</tal:span><br/>
         <input size="10" name="__login_name"/><br/>
         <input size="10" type="password" name="__login_password"/><br/>
         <input type="hidden" name="@action" value="Login"/>
         <input type="checkbox" name="remember" id="remember"/>
         <label for="remember" i18n:translate="">Remember me?</label><br/>
         <input class="form-small" type="submit" value="Login" i18n:attributes="value"/><br/>
         <input type="hidden" name="__came_from" tal:attributes="value string:${request/env/PATH_INFO}"/>
         <span tal:replace="structure request/indexargs_form" />
        </li>
        <li>
         <a href="user?@template=register"
            tal:condition="python:request.user.hasPermission('Create', 'user')"
            i18n:translate="">Register</a>
        </li>
        <li>
         <a href="user?@template=forgotten" i18n:translate="">Lost&nbsp;your&nbsp;login?</a>
        </li>
       </ul>
      </form>
     </li>
     <li tal:condition="python:request.user.username != 'anonymous'" class="submenu">
      <p class="label"><b tal:replace="request/user/username">username</b></p>
      <ul>
       <li>
        <a href="#" tal:attributes="href python:request.indexargs_url('bug', {
                                     '@sort': '-activity',
                                     '@group': 'priority',
                                     '@filter': 'status,assignee',
                                     '@columns': bug_columns,
                                     '@search_text': '',
                                     'status': bug_status_notclosed,
                                     'assignee': request.user.id,
                                     '@dispname': i18n.gettext('Bugs assigned to you'),
                                     '@startwith': 0})"
                    i18n:translate="">Bugs assigned to you</a>
       </li>
       <li>
        <a tal:attributes="href string:user${request/user/id}" i18n:translate="">Your Details</a>
       </li>
       <li>
        <a tal:attributes="href python:request.indexargs_url('', {'@action':'logout'})" 
           i18n:translate="">Logout</a>
       </li>
       <li class="" tal:condition="python:request.user.hasPermission('View', 'query')">
        <span i18n:translate=""><b>Your Queries</b> (<a class="nomargin" href="query?@template=edit">edit</a>)</span><br/>
        <ul tal:repeat="qs request/user/queries">
         <li>
          <a tal:attributes="href string:${qs/klass}?${qs/url}&@dispname=${qs/name}" tal:content="qs/name">link</a>
         </li>
        </ul>
       </li>
       <li class="" tal:condition="python:request.user.hasPermission('View', 'user')">
        <b i18n:translate="">Administration</b>
        <ul>
         <li tal:condition="python:request.user.hasPermission('Edit', None)">
          <a href="home?@template=classlist" i18n:translate="">Class List</a>
         </li>
         <li tal:condition="python:request.user.hasPermission('View', 'user')
                            or request.user.hasPermission('Edit', 'user')">
          <a href="user?@sort=username"  i18n:translate="">User List</a>
         </li>
         <li tal:condition="python:request.user.hasPermission('Create', 'user')">
          <a href="user?@template=item" i18n:translate="">Add User</a>
         </li>
         <li tal:condition="python:request.user.hasPermission('Edit', 'keyword')">
          <a href="keyword" i18n:translate="">Edit Keywords</a>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul> <!-- user -->
   </div> <!-- menu -->
  </div> <!-- navigation -->
  <div class="content">
   <h1 id="breadcrumb"><span metal:define-slot="body_title">body title</span></h1>
   <p tal:condition="options/error_message | nothing" class="error-message"
      tal:repeat="m options/error_message" tal:content="structure m" />
   <p tal:condition="options/ok_message | nothing" class="ok-message">
    <span tal:repeat="m options/ok_message" tal:content="structure string:$m <br/ > " />
    <a class="form-small" tal:attributes="href request/current_url" i18n:translate="">clear this message</a>
   </p>
   <tal:block metal:define-slot="content">Page content goes here</tal:block>
  </div> <!-- content -->
  <div class="footer">
<!-- Created: Wed Jan 14 11:55:38 EST 2009 -->
<!-- hhmts start -->
Last modified: Mon Jun  1 15:00:08 EDT 2009
<!-- hhmts end -->
  </div> <!-- footer -->
  <pre tal:condition="request/form/deissue | nothing" tal:content="request"></pre>
 </body>
</html>
</tal:block>

<!--
The following macros are intended to be used in search pages.

The invoking context must define a "name" variable which names the
property being searched.

See issue.search.html in the classic template for examples.
-->

<!-- creates a th and a label: -->
<th metal:define-macro="th_label"
    tal:define="required required | python:[]"
    tal:attributes="class python:(name in required) and 'required' or nothing">
  <label tal:attributes="for name" tal:content="label" i18n:translate="">text</label>
	<metal:x define-slot="behind_the_label" />
</th>

<td metal:define-macro="search_input">
  <input tal:attributes="value python:request.form.getvalue(name) or nothing;
                         name name;
                         id name"/>
</td>

<td metal:define-macro="search_date">
  <input tal:attributes="value python:request.form.getvalue(name) or nothing;
                         name name;
                         id name"/>
  <a class="classhelp"
	 tal:attributes="href python:'''javascript:help_window('task?@template=calendar&property=%s&form=itemSynopsis', 300, 200)'''%name">(cal)</a>
</td>

<td metal:define-macro="search_popup">
  <!--
    context needs to specify the popup "columns" as a comma-separated
    string (eg. "id,title" or "id,name,description") as well as name
  -->
  <input tal:attributes="value python:request.form.getvalue(name) or nothing;
                         name name;
                         id name"/>
  <span tal:replace="structure python:db.task.classhelp(columns,
                                      property=name)" />
</td>

<td metal:define-macro="search_select">
  <select tal:attributes="name name; id name"
          tal:define="value python:request.form.getvalue(name)">
    <option value="" i18n:translate="">don't care</option>
    <metal:slot define-slot="extra_options" />
    <option value="" i18n:translate="" disabled="disabled">------------</option>
    <option tal:repeat="s python:db[db_klass].list()"
            tal:attributes="value s/id; selected python:value == s.id"
            tal:content="python:s[db_content]"></option>
  </select>
</td>

<!-- like search_select, but translates the further values.
Could extend it (METAL 1.1 attribute "extend-macro")
-->
<td metal:define-macro="search_select_translated">
  <select tal:attributes="name name; id name"
          tal:define="value python:request.form.getvalue(name)">
    <option value="" i18n:translate="">don't care</option>
    <metal:slot define-slot="extra_options" />
    <option value="" i18n:translate="" disabled="disabled">------------</option>
    <option tal:repeat="s python:db[db_klass].list()"
            tal:attributes="value s/id; selected python:value == s.id"
						tal:content="python:s[db_content]"
						i18n:translate=""></option>
  </select>
</td>

<!-- currently, there is no convenient API to get a list of all roles -->
<td metal:define-macro="search_select_roles"
	  tal:define="onchange onchange | nothing">
  <select name=roles id=roles tal:attributes="onchange onchange">
    <option value="" i18n:translate="">don't care</option>
    <option value="" i18n:translate="" disabled="disabled">------------</option>
    <option value="User">User</option>
    <option value="Developer">Developer</option>
    <option value="Coordinator">Coordinator</option>
  </select>
</td>

<td metal:define-macro="search_multiselect">
  <input tal:attributes="value python:request.form.getvalue(name) or nothing;
                         name name;
                         id name"/>
  <span tal:replace="structure python:db[db_klass].classhelp(db_content,
                                        property=name, width='600')" />
</td>

<td metal:define-macro="search_checkboxes">
 <ul class="search-checkboxes"
     tal:define="value python:request.form.getvalue(name);
                 values python:value and value.split(',') or []">
 <li tal:repeat="s python:db[db_klass].list()">
  <input type="checkbox" tal:attributes="name name; id string:$name-${s/id};
    value s/id; checked python:s.id in values" />
  <label tal:attributes="for string:$name-${s/id}"
         tal:content="python:s[db_content]" />
 </li>
 <li metal:define-slot="no_value_item">
  <input type="checkbox" value="-1" tal:attributes="name name;
     id string:$name--1; checked python:value == '-1'" />
  <label tal:attributes="for string:$name--1" i18n:translate="">no value</label>
 </li>
 </ul>
</td>

<td metal:define-macro="column_input">
  <input type="checkbox" name="@columns"
         tal:attributes="value name;
                         checked python:name in cols"/>
</td>

<td metal:define-macro="sort_input">
  <input type="radio" name="@sort"
         tal:attributes="value name;
                         checked python:name == sort_on"/>
</td>

<td metal:define-macro="group_input">
  <input type="radio" name="@group"
         tal:attributes="value name;
                         checked python:name == group_on"/>
</td>

<!--
The following macros are intended for user editing.

The invoking context must define a "name" variable which names the
property being searched; the "edit_ok" variable tells whether the
current user is allowed to edit.

See user.item.html in the classic template for examples.
-->
<script metal:define-macro="user_utils" type="text/javascript" src="@@file/user_utils.js"></script>

<!-- src: value will be re-used for other input fields -->
<input metal:define-macro="user_src_input"
    type="text" tal:attributes="onblur python:edit_ok and 'split_name(this)';
    id name; name name; value value; readonly not:edit_ok"
    value="heinz.kunz"/>
<!-- normal: no re-using -->
<input metal:define-macro="user_normal_input" type="text"
    tal:attributes="id name; name name; value value; readonly not:edit_ok"
    value="heinz"/>
<!-- password: type; no initial value -->
    <input metal:define-macro="user_pw_input" type="password"
    tal:attributes="id name; name name; readonly not:edit_ok" value=""/>
    <input metal:define-macro="user_confirm_input" type="password"
    tal:attributes="id name; name string:@confirm@$name; readonly not:edit_ok" value=""/>


blob
mark :595
data 3707
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate=""
 >"Your Queries" Editing - <span tal:replace="config/TRACKER_NAME"
 i18n:name="tracker" /></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
 i18n:translate="">"Your Queries" Editing</span>

<td class="content" metal:fill-slot="content">

<span tal:condition="not:context/is_edit_ok"
 i18n:translate="">You are not allowed to edit queries.</span>

<script language="javascript">
// This exists solely because I can't figure how to get the & into an
// attributes TALES expression, and so it keeps getting quoted.
function retire(qid) {
    window.location = 'query'+qid+'?@action=retire&@template=edit';
}
</script>

<form method="POST" onSubmit="return submit_once()" action="query"
      enctype="multipart/form-data" tal:condition="context/is_edit_ok">

<table class="list" width="100%"
       tal:define="uid request/user/id; mine request/user/queries">

<tr><th i18n:translate="">Query</th>
    <th i18n:translate="">Include in "Your Queries"</th>
    <th i18n:translate="">Edit</th>
    <th i18n:translate="">Private to you?</th>
    <th>&nbsp;</th>
</tr>

<tr tal:repeat="query mine">
 <tal:block condition="query/is_retired">

 <td><a tal:attributes="href string:${query/klass}?${query/url}"
        tal:content="query/name">query</a></td>

 <td metal:define-macro="include">
  <select tal:condition="python:query.id not in mine"
          tal:attributes="name string:user${uid}@add@queries">
    <option value="" i18n:translate="">leave out</option>
    <option tal:attributes="value query/id" i18n:translate="">include</option>
  </select>
  <select tal:condition="python:query.id in mine"
          tal:attributes="name string:user${uid}@remove@queries">
    <option value="" i18n:translate="">leave in</option>
    <option tal:attributes="value query/id" i18n:translate="">remove</option>
  </select>
 </td>

 <td colspan="3" i18n:translate="">[query is retired]</td>

 <!-- <td> maybe offer "restore" some day </td> -->
 </tal:block>
</tr>

<tr tal:define="queries python:db.query.filter(filterspec={'private_for':uid})"
     tal:repeat="query queries">
 <td><a tal:attributes="href string:${query/klass}?${query/url}"
        tal:content="query/name">query</a></td>

 <td metal:use-macro="template/macros/include" />

 <td><a tal:attributes="href string:query${query/id}" i18n:translate="">edit</a></td>

 <td>
  <select tal:attributes="name string:query${query/id}@private_for">
   <option tal:attributes="selected python:query.private_for == uid;
           value uid" i18n:translate="">yes</option>
   <option tal:attributes="selected python:query.private_for == None"
           value="-1" i18n:translate="">no</option>
  </select>
 </td>

 <td>
  <input type="button" value="Delete" i18n:attributes="value"
  tal:attributes="onClick python:'''retire('%s')'''%query.id">
  </td>
</tr>

<tr tal:define="queries python:db.query.filter(filterspec={'private_for':None})"
     tal:repeat="query queries">
 <td><a tal:attributes="href string:${query/klass}?${query/url}"
        tal:content="query/name">query</a></td>

 <td metal:use-macro="template/macros/include" />

 <td colspan="3" tal:condition="query/is_edit_ok">
  <a tal:attributes="href string:query${query/id}" i18n:translate="">edit</a>
 </td>
 <td tal:condition="not:query/is_edit_ok" colspan="3"
    i18n:translate="">[not yours to edit]</td>

</tr>

<tr><td colspan="5">
   <input type="hidden" name="@action" value="edit">
   <input type="hidden" name="@template" value="edit">
   <input type="submit" value="Save Selection" i18n:attributes="value">
</td></tr>

</table>

</form>
</td>
</tal:block>

blob
mark :596
data 645
// Inspect a form element to construct a 'get' request,
// register it to the 'submit' event, and deactivate the
// form's submit action.
function bind_search()
{
  var form = $("form");
  var action = form.attr("action");
  form.attr("action",""); // reset

  function display(data)
  {
    var list = $("div.list");
    list.empty();
    list.append(data);
  }

  function query()
  {
    var inputs = $(":input");
    var data = {}
    for (var i = 0; i < inputs.length; i++)
      data[inputs[i].name] = inputs[i].value;
    jQuery.get(action, data, display);
    return false;
  }

  form.submit(query);
}


$(document).ready(bind_search);

blob
mark :597
data 2182
/* layout*/
body 
{
  font-family: sans-serif, Arial, Helvetica;
  background-color: white;
  color: #333;
  margin:0;
  padding: 0 3em 0 13em;
}
body > .header { margin: 0 0 0 -13em;}
body > .footer { margin: 0 0 0 -13em; clear:both;}
body > .navigation 
{
  margin-left: -13em;
  width: 13em;
  float: left;
}
body > .content 
{
  width: 100%;
  margin: 0;
}
body > .header > #searchbox { position: absolute; right: 1em; top: 1em;}

/* style */

.footer { padding: 1em;}

:link { color: #bb0000; text-decoration: none;}
:visited { color: #770000; text-decoration: none;}

.header h1 { margin-left: 1em; }

body
{
  font-family: sans-serif, Arial, Helvetica;
  background-color: #f5f5f5;
  color: #333;
}

.menu { padding: 0; margin-right: 1em;}
.menu ul 
{
  padding: 0;
  margin: 0;
}
.menu li
{
  margin: 5pt 0;
}
.menu > ul > li > *
{ 
  display: block;
  padding: 2pt 2pt 2pt 10pt;
  border: solid thin #dadada;
  background-color:#ffffff;
}
.menu > ul > li.current > *
{ 
  background-color:#dddddd;
}

.menu ul li:first-child { margin-top:0;}
.menu ul { list-style-type:none;}

/* sub-menus are indented */ 
.menu > ul > li > ul,
.menu > ul > li.current > ul
{
  border: none;
  background-color: inherit;
  margin: 0;
}
.menu ul ul 
{
  margin-left: 2em;
  font-size: smaller;
  margin: 0 0 0 5pt;
}

/* sub-menu items draw a separator */
.menu ul ul > li 
{  
  margin: 0;
  padding: 0;
  border: none;
  border-top: solid thin #dadada;
  background-color: inherit;
}
.menu ul ul > li:first-child
{  
  border-top: none;
}

.footer
{
  font-size: small;
  text-align: center;
  color: lightgrey;
}

.content
{ 
  padding: 1em;
  border: solid thin #dadada;
  background-color: #ffffff;
}

#search { text-align: right; }

p.ok-message 
{
  background-color: #eeffee;
  border: 1px solid #009900;
  padding: 5px;
  color: #009900;
  font-weight: bold;
}
p.error-message 
{
  background-color: #ffeeee;
  border: 1px solid #990000;
  padding: 5px;
  color: #990000;
  font-weight: bold;
}

table
{ 
  border-collapse: collapse;
  border-spacing: 1px;
  width: 100%;
  background-color: #fafafa;
}

tr.odd { background-color:#f5f5f5; }

input, textarea { border-width: 1px; }

blob
mark :598
data 7695
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" >
  <span tal:omit-tag="true" i18n:translate="" >List of tasks</span>
  <span tal:condition="request/dispname"
   tal:replace="python:' - %s '%request.dispname"
  /> - <span tal:replace="config/TRACKER_NAME" />
</title>
<span metal:fill-slot="body_title" tal:omit-tag="true">
  <span tal:omit-tag="true" i18n:translate="" >List of tasks</span>
  <span tal:condition="request/dispname"
   tal:replace="python:' - %s' % request.dispname" />
</span>
<tal:block metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<tal:block tal:define="batch request/batch" tal:condition="context/is_view_ok">
 <table class="list">
  <tr>
   <th tal:condition="request/show/severity" i18n:translate="">Severity</th>
   <th tal:condition="request/show/id" i18n:translate="">ID</th>
   <th tal:condition="request/show/creation" i18n:translate="">Creation</th>
   <th tal:condition="request/show/activity" i18n:translate="">Activity</th>
   <th tal:condition="request/show/actor" i18n:translate="">Actor</th>
   <th tal:condition="request/show/title" i18n:translate="">Title</th>
   <th tal:condition="request/show/components"  i18n:translate="">Components</th>
   <th tal:condition="request/show/versions" i18n:translate="">Versions</th>
   <th tal:condition="request/show/status"    i18n:translate="">Status</th>
   <th tal:condition="request/show/resolution" i18n:translate="">Resolution</th>
   <th tal:condition="request/show/creator" i18n:translate="">Creator</th>
   <th tal:condition="request/show/assignee" i18n:translate="">Assigned&nbsp;To</th>
   <th tal:condition="request/show/keywords" i18n:translate="">Keywords</th>
   <th tal:condition="request/show/dependencies" i18n:translate="">Depends On</th>
   <th tal:condition="request/show/type" i18n:translate="">Type</th>
  </tr>
 <tal:block tal:repeat="i batch" condition="true">
  <tr tal:define="group python:[r[1] for r in request.group]"
      tal:condition="python:group and batch.propchanged(*group)">
   <th tal:attributes="colspan python:len(request.columns)" class="group">
    <tal:block tal:repeat="g group">
     <tal:block tal:content="python:str(i[g]) or '(no %s set)'%g"/>
    </tal:block>
   </th>
  </tr>

  <tr tal:attributes="class python:['even','odd'][repeat['i'].even()]">
   <td tal:condition="request/show/severity"
       tal:content="python:i.severity.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/id" tal:content="i/id">&nbsp;</td>
   <td class="date" tal:condition="request/show/creation"
       tal:content="i/creation/reldate">&nbsp;</td>
   <td class="date" tal:condition="request/show/activity"
       tal:content="i/activity/reldate">&nbsp;</td>
   <td tal:condition="request/show/actor"
       tal:content="python:i.actor.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/title">
    <a tal:attributes="href string:task${i/id}"
		tal:content="python:str(i.title.plain(hyperlink=0)) or '[no title]'">title</a>
   </td>
   <td tal:condition="request/show/components"
       tal:content="python:i.components.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/versions"
       tal:content="python:i.versions.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/status"
       tal:content="python:i.status.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/resolution"
       tal:content="python:i.resolution.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/creator"
       tal:content="python:i.creator.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/assignee"
       tal:content="python:i.assignee.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/keywords"
       tal:content="python:i.keywords.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/dependencies"
       tal:content="python:i.dependencies.plain() or default">&nbsp;</td>
   <td tal:condition="request/show/type"
       tal:content="python:i.type.plain() or default">&nbsp;</td>
  </tr>

 </tal:block>

 <metal:index define-macro="batch-footer">
 <tr tal:condition="batch">
  <th tal:attributes="colspan python:len(request.columns)">
   <table width="100%">
    <tr class="navigation">
     <th>
      <a tal:define="prev batch/previous" tal:condition="prev"
         tal:attributes="href python:request.indexargs_url(request.classname,
         {'@startwith':prev.first, '@pagesize':prev.size})"
         i18n:translate="">&lt;&lt; previous</a>
      &nbsp;
     </th>
     <th i18n:translate=""><span tal:replace="batch/start" i18n:name="start"
     />..<span tal:replace="python: batch.start + batch.length -1" i18n:name="end"
     /> out of <span tal:replace="batch/sequence_length" i18n:name="total"
     /></th>
     <th>
      <a tal:define="next batch/next" tal:condition="next"
         tal:attributes="href python:request.indexargs_url(request.classname,
         {'@startwith':next.first, '@pagesize':next.size})"
         i18n:translate="">next &gt;&gt;</a>
      &nbsp;
     </th>
    </tr>
   </table>
  </th>
 </tr>
 </metal:index>
</table>
<!--
<a tal:attributes="href python:request.indexargs_url('task',
            {'@action':'export_csv'})" i18n:translate="">Download as CSV</a>
-->
<form method="get" class="index-controls"
    tal:attributes="action request/classname">

 <table class="form" tal:define="n_sort python:2">
<!--
<tal:block tal:repeat="n python:range(n_sort)" tal:condition="batch">
  <tr tal:define="key python:len(request.sort)>n and request.sort[n]">
   <th>
    <tal:block tal:condition="not:n" i18n:translate="">Sort on:</tal:block>
   </th>
   <td>
    <select tal:attributes="name python:'@sort%d'%n">
     <option value="" i18n:translate="">- nothing -</option>
     <option tal:repeat="col context/properties"
             tal:attributes="value col/_name;
                             selected python:key and col._name == key[1]"
             tal:content="col/_name"
             i18n:translate="">column</option>
    </select>
   </td>
   <th i18n:translate="">Descending:</th>
   <td><input type="checkbox" tal:attributes="name python:'@sortdir%d'%n;
              checked python:key and key[0] == '-'"/>
   </td>
  </tr>
  </tal:block>
  -->
  <tal:block tal:repeat="n python:range(n_sort)" tal:condition="batch">
  <tr tal:define="key python:len(request.group)>n and request.group[n]">
   <th>
    <tal:block tal:condition="not:n" i18n:translate="">Group on:</tal:block>
   </th>
   <td>
    <select tal:attributes="name python:'@group%d'%n">
     <option value="" i18n:translate="">- nothing -</option>
     <option tal:repeat="col context/properties"
             tal:attributes="value col/_name;
                             selected python:key and col._name == key[1]"
             tal:content="col/_name"
             i18n:translate="">column</option>
    </select>
   </td>
   <th i18n:translate="">Descending:</th>
   <td><input type="checkbox" tal:attributes="name python:'@groupdir%d'%n;
              checked python:key and key[0] == '-'"/>
   </td>
  </tr>
  </tal:block>
  <tr><td colspan="4">
              <input type="submit" value="Redisplay" i18n:attributes="value"/>
              <tal:block tal:replace="structure
                python:request.indexargs_form(sort=0, group=0)" />
  </td></tr>
 </table>
</form>

</tal:block>
</tal:block>
</tal:block>

blob
mark :599
data 9090
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title">
<tal:block condition="context/id" i18n:translate=""
 >Task <span tal:replace="context/id" i18n:name="id"
 />: <span tal:replace="context/title" i18n:name="title"
 /> - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
<tal:block condition="not:context/id" i18n:translate=""
 >New Task - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
</title>
<tal:block metal:fill-slot="body_title">
 <span tal:condition="python: not (context.id or context.is_edit_ok())"
  tal:omit-tag="python:1" i18n:translate="">New Task</span>
 <span tal:condition="python: not context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">New Task Editing</span>
 <span tal:condition="python: context.id and not context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Task <tal:x
  replace="context/id" i18n:name="id" /></span>
 <span tal:condition="python: context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Task<tal:x
  replace="context/id" i18n:name="id" /> Editing</span>
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<div tal:condition="context/is_view_ok">

<form method="POST" name="itemSynopsis"
      onSubmit="return submit_once()" enctype="multipart/form-data"
      tal:attributes="action context/designator">

<fieldset><legend>classification</legend>
<table class="form">
<tr>
 <th class="required" i18n:translate="">Title:</th>
 <td colspan="3" tal:condition="context/title/is_edit_ok"
     tal:content="structure python:context.title.field(size=60)">title</td>
 <td colspan="3" tal:condition="not:context/title/is_edit_ok">
  <span tal:content="structure context/title/plain"/>
  <input type="hidden" name="title" tal:attributes="value context/title">
 </td>
</tr>

<tr>
 <th class="required" i18n:translate="">
   <span tal:replace="structure python:db.task_type.classhelp('id,name,description',label='Type')" />:
 </th>
 <td tal:content="structure context/type/menu">type</td>
 <th i18n:translate="">
   <span tal:replace="structure python:db.component.classhelp('id,name,description',label='Components')" />:
 </th>
 <td tal:content="structure context/components/menu">components</td>
</tr>
</table>
</fieldset>

<fieldset><legend>process</legend>
<table class="form">
<tr tal:condition="context/id">
 <th i18n:translate="">
   <span tal:replace="structure python:db.status.classhelp('id,name,description',label='Status')" />:
 </th>
 <td tal:content="structure context/status/menu">status</td>
 <th i18n:translate="">Resolution:</th>
 <td tal:content="structure context/resolution/menu">resolution</td>
</tr>

<tr tal:condition="context/id">
 <th>
  <tal:block i18n:translate="">Dependencies</tal:block>:
  <span tal:condition="context/dependencies/is_edit_ok"
        tal:replace="structure python:db.task.classhelp('id,title', filter='status=0,1', property='dependencies')" />
 </th>
 <td>
  <span tal:replace="structure python:context.dependencies.field(showid=1,size=20)" />
  <span tal:condition="context/dependencies" tal:repeat="d python:context.dependencies.sorted('creation')">
   <br/>View: <a tal:attributes="href string:task${d/id}" tal:content="d/id"></a>
  </span>
 </td>
 <th i18n:translate="">
  <tal:block i18n:translate="">Superseder</tal:block>:
  <span tal:condition="context/superseder/is_edit_ok"
        tal:replace="structure python:db.task.classhelp('id,title', filter='status=0,1', property='superseder')" />
 </th>
 <td>
  <span tal:replace="structure python:context.superseder.field(showid=1, size=20)" />
 <span tal:condition="context/superseder">
<!--   <br><span i18n:translate="">View</span>:
     <a tal:repeat="sup context/superseder"
        tal:content="python:sup['id'] + ', '*(not repeat['sup'].end)"
        tal:attributes="href string:task${sup/id}; title sup/title;"></a> -->
   <br><span i18n:translate="">View</span>:
     <a tal:content="context/superseder/id"
        tal:attributes="href string:task${context/superseder/id}; title context/superseder/title;"></a> 
  </span> 
 </td>
 </tr>
 <tr>
 <th><tal:block i18n:translate="">Assigned To</tal:block>:</th>
 <td tal:content="structure context/assignee/menu">assignedto menu</td>
 <th><tal:block i18n:translate="">Nosy List</tal:block>:
  <span tal:condition="context/nosy/is_edit_ok"
        tal:replace="structure python:db.user.classhelp('username,realname,address', property='nosy')" />
 </th>
 <td>
  <span tal:replace="structure context/nosy/field" />
 </td>
</tr>
<tr>
 <th>
   <span tal:replace="structure python:db.priority.classhelp('id,name,description',label='Priority')" />:
 </th>
 <td tal:content="structure context/priority/menu">priority</td>
</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">Comment</tal:block>:</th>
 <td colspan="3">
  <textarea tal:content="request/form/@note/value | default"
            name="@note" wrap="hard" rows="10" cols="72"></textarea>
 </td>
</tr>

<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">File</tal:block>:</th>
 <td colspan=3>
   <input type="hidden" name="@link@files" value="file-1">
   <input type="file" name="file-1@content" size="40">
 </td>
</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">File Description</tal:block>:</th>
 <td colspan=3><input type="edit" name="file-1@description" size="40"></td>
</tr>
</table>
</fieldset>
<table class="form">
<tr tal:condition="context/is_edit_ok">
 <td>
  &nbsp;
  <input type="hidden" name="@template" value="item">
  <input type="hidden" name="@required" value="title">
 </td>
 <td colspan=3>
  <span tal:replace="structure context/submit">submit button</span>
  <a tal:condition="context/id" tal:attributes="href context/copy_url"
   i18n:translate="">Make a copy</a>
 </td>
</tr>
</table>
</form>

<p tal:condition="context/id" i18n:translate="">
 Created on <b><tal:x replace="python:context.creation.pretty('%Y-%m-%d %H:%M')" i18n:name="creation" /></b>
 by <b><tal:x replace="context/creator" i18n:name="creator" /></b>,
 last changed <b><tal:x replace="python:context.activity.pretty('%Y-%m-%d %H:%M')" i18n:name="activity" /></b>
 by <b><tal:x replace="context/actor" i18n:name="actor" /></b>.
</p>

<table class="files" tal:condition="context/files">
 <tr><th colspan="5" class="header" i18n:translate="">Files</th></tr>
 <tr>
  <th i18n:translate="">File name</th>
  <th i18n:translate="">Uploaded</th>
  <th i18n:translate="">Description</th>
  <th i18n:translate="">Edit</th>
  <th i18n:translate="">Remove</th>
 </tr>
 <tr tal:repeat="file python:context.files.sorted('creation')">
  <td>
   <a tal:attributes="href file/download_url"
      tal:content="file/name">dld link</a>
  </td>
  <td>
   <span tal:content="file/creator">creator's name</span>,
   <span tal:content="python:file.creation.pretty('%Y-%m-%d %H:%M')">creation date</span>
  </td>
  <td tal:content="file/description" />
  <td><a tal:condition="file/is_edit_ok"
          tal:attributes="href string:file${file/id}">edit</a>
  </td>
  <td>
   <form style="padding:0" tal:condition="file/is_edit_ok"
         tal:attributes="action string:task${context/id}">
    <input type="hidden" name="@remove@files" tal:attributes="value file/id">
    <input type="hidden" name="@action" value="edit">
    <input type="submit" value="remove" i18n:attributes="value">
   </form>
  </td>
 </tr>
</table>

<table class="messages" tal:condition="context/messages">
 <tr><th colspan="4" class="header" i18n:translate="">Messages</th></tr>
 <tal:block tal:repeat="msg context/messages">
  <tr>
   <th><a tal:attributes="href string:msg${msg/id}"
    i18n:translate="">msg<tal:x replace="msg/id" i18n:name="id" /></a></th>
   <th i18n:translate="">Author: <tal:x replace="python:msg.author.realname.plain()"
       i18n:name="author" /> (<tal:x replace="msg/author"/>)</th>
   <th i18n:translate="">Date: <tal:x replace="python:msg.date.pretty('%Y-%m-%d %H:%M')"
       i18n:name="date" /></th>
   <th>
    <form style="padding:0" tal:condition="msg/is_edit_ok"
          tal:attributes="action string:task${context/id}">
     <input type="hidden" name="@remove@messages" tal:attributes="value msg/id">
     <input type="hidden" name="@action" value="edit">
     <input type="submit" value="remove" i18n:attributes="value">
    </form>
   </th>
  </tr>
  <tr>
   <td colspan="4" class="content">
    <pre tal:condition="python:msg.content.is_view_ok()"
         tal:content="structure python:utils.localReplace(msg.content.hyperlinked())">content</pre>
   </td>
  </tr>
 </tal:block>
</table>

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</div>

</td>

</tal:block>

blob
mark :600
data 10722
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate="">Task searching - <span
 i18n:name="tracker" tal:replace="config/TRACKER_NAME" /></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
 i18n:translate="">Task searching</span>
<td class="content" metal:fill-slot="content">

<form method="get" name="itemSynopsis"
      tal:attributes="action request/classname">
      
<table class="form" tal:define="
   cols python:request.columns or 'id activity title status assignedto'.split();
   sort_on python:request.sort and request.sort[0] or nothing;
   sort_desc python:sort_on and sort_on[0] == '-';
   sort_on python:(sort_on and sort_on[1]) or 'activity';
   group_on python:request.group and request.group[0] or nothing;
   group_desc python:group_on and group_on[0] == '-';
   group_on python:(group_on and group_on[1]) or 'priority';

   search_input templates/page/macros/search_input;
   search_date templates/page/macros/search_date;
   column_input templates/page/macros/column_input;
   sort_input templates/page/macros/sort_input;
   group_input templates/page/macros/group_input;
   search_select templates/page/macros/search_select;
   search_select_translated templates/page/macros/search_select_translated;
   search_multiselect templates/page/macros/search_multiselect;">

<tr>
 <th class="header">&nbsp;</th>
 <th class="header" i18n:translate="">Filter on</th>
 <th class="header" i18n:translate="">Display</th>
 <th class="header" i18n:translate="">Sort on</th>
 <th class="header" i18n:translate="">Group on</th>
</tr>

<tr tal:define="name string:@search_text">
  <th i18n:translate="">All text*:</th>
  <td metal:use-macro="search_input"></td>
  <td>&nbsp;</td>
  <td>&nbsp;</td>
  <td>&nbsp;</td>
</tr>

<tr tal:define="name string:title">
  <th i18n:translate="">Title:</th>
  <td metal:use-macro="search_input"></td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td>&nbsp;</td>
</tr>

<tr tal:define="name string:id">
  <th i18n:translate="">ID:</th>
  <td metal:use-macro="search_input"></td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td>&nbsp;</td>
</tr>

<tr tal:define="name string:creation">
  <th i18n:translate="">Creation Date:</th>
  <td metal:use-macro="search_date"></td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:creator;
                db_klass string:user;
                db_content string:username;">
  <th i18n:translate="">Creator:</th>
  <td metal:use-macro="search_input">
    <option metal:fill-slot="extra_options" i18n:translate=""
            tal:attributes="value request/user/id">created by me</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:activity">
  <th i18n:translate="">Activity:</th>
  <td metal:use-macro="search_date"></td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td>&nbsp;</td>
</tr>

<tr tal:define="name string:actor;
                db_klass string:user;
                db_content string:username;">
  <th i18n:translate="">Last actor:</th>
  <td metal:use-macro="search_input">
    <option metal:fill-slot="extra_options" i18n:translate=""
            tal:attributes="value request/user/id">done by me</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td>&nbsp;</td>
</tr>

<tr tal:define="name string:nosy">
  <th i18n:translate="">Nosy list member:</th>
  <td metal:use-macro="search_input"></td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td>&nbsp;</td>
</tr>

<tr tal:define="name string:type;
                db_klass string:task_type;
                db_content string:name;">
  <th i18n:translate="">Type:</th>
  <td metal:use-macro="search_select_translated">
    <option metal:fill-slot="extra_options" value="-1" i18n:translate=""
            tal:attributes="selected python:value == '-1'">not selected</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:components;
                db_klass string:component;
                db_content string:name;">
  <th i18n:translate="">Components:</th>
  <td metal:use-macro="search_select_translated">
    <option metal:fill-slot="extra_options" value="-1" i18n:translate=""
            tal:attributes="selected python:value == '-1'">not selected</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:versions;
                db_klass string:version;
                db_content string:name;">
  <th i18n:translate="">Versions:</th>
  <td metal:use-macro="search_select_translated">
    <option metal:fill-slot="extra_options" value="-1" i18n:translate=""
            tal:attributes="selected python:value == '-1'">not selected</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<!--tr tal:define="name string:severity;
                db_klass string:severity;
                db_content string:name;">
  <th i18n:translate="">Severity:</th>
  <td metal:use-macro="search_select_translated">
    <option metal:fill-slot="extra_options" value="-1" i18n:translate=""
            tal:attributes="selected python:value == '-1'">not selected</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr-->

<tr tal:define="name string:dependencies;
                db_klass string:task;
                db_content string:id;">
  <th i18n:translate="">Depends on:</th>
  <td metal:use-macro="search_input"/>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:assignee;
                db_klass string:user;
                db_content string:username;">
  <th i18n:translate="">Assigned to:</th>
  <td metal:use-macro="search_input">
    <tal:block metal:fill-slot="extra_options">
      <option tal:attributes="value request/user/id"
       i18n:translate="">assigned to me</option>
      <option value="-1" tal:attributes="selected python:value == '-1'"
       i18n:translate="">unassigned</option>
    </tal:block>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:keywords;
                db_klass string:keyword;
                db_content string:name;">
  <th i18n:translate="">Keyword:</th>
  <td metal:use-macro="search_select_translated">
    <option metal:fill-slot="extra_options" value="-1" i18n:translate=""
            tal:attributes="selected python:value == '-1'">not set</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:priority;
                db_klass string:priority;
                db_content string:name;">
  <th i18n:translate="">Priority:</th>
  <td metal:use-macro="search_select_translated">
    <option metal:fill-slot="extra_options" value="-1" i18n:translate=""
            tal:attributes="selected python:value == '-1'">not selected</option>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:status;
                db_klass string:status;
                db_content string:name;">
  <th i18n:translate="">Status:</th>
  <td metal:use-macro="search_select_translated">
    <tal:block metal:fill-slot="extra_options">
      <option value="-1,1,2" i18n:translate=""
              tal:attributes="selected python:value == '-1,1,2'">not closed</option>
      <option value="-1" i18n:translate=""
              tal:attributes="selected python:value == '-1'">not selected</option>
    </tal:block>
  </td>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr tal:define="name string:resolution;
                db_klass string:resolution;
                db_content string:name;">
  <th i18n:translate="">Resolution:</th>
  <td metal:use-macro="search_select_translated"/>
  <td metal:use-macro="column_input"></td>
  <td metal:use-macro="sort_input"></td>
  <td metal:use-macro="group_input"></td>
</tr>

<tr>
 <th i18n:translate="">No Sort or group:</th>
 <td>&nbsp;</td>
 <td>&nbsp;</td>
 <td><input type="radio" name="@sort" value=""/></td>
 <td><input type="radio" name="@group" value=""/></td>
</tr>

<tr>
<th i18n:translate="">Pagesize:</th>
<td><input name="@pagesize" size="3" value="50"
           tal:attributes="value request/form/@pagesize/value | default"/></td>
</tr>

<tr>
<th i18n:translate="">Start With:</th>
<td><input name="@startwith" size="3" value="0"
           tal:attributes="value request/form/@startwith/value | default"/></td>
</tr>

<tr>
<th i18n:translate="">Sort Descending:</th>
<td><input type="checkbox" name="@sortdir"
           tal:attributes="checked sort_desc"/>
</td>
</tr>

<tr>
<th i18n:translate="">Group Descending:</th>
<td><input type="checkbox" name="@groupdir"
           tal:attributes="checked group_desc"/>
</td>
</tr>

<tr tal:condition="python:request.user.hasPermission('Edit', 'query')">
 <th i18n:translate="">Query name**:</th>
 <td tal:define="value request/form/@queryname/value | nothing">
  <input name="@queryname" tal:attributes="value value"/>
  <input type="hidden" name="@old-queryname" tal:attributes="value value"/>
 </td>
</tr>

<tr>
  <td>
   &nbsp;
   <input type="hidden" name="@action" value="search"/>
  </td>
  <td><input type="submit" value="Search" i18n:attributes="value"/></td>
</tr>

<tr><td>&nbsp;</td>
 <td colspan="4" class="help">
  <span i18n:translate="" tal:omit-tag="true">
   *: The "all text" field will look in message bodies and task titles
  </span><br>
  <span tal:condition="python:request.user.hasPermission('Edit', 'query')"
   i18n:translate="" tal:omit-tag="true"
  >
   **: If you supply a name, the query will be saved off and available as a
       link in the sidebar
  </span>
 </td>
</tr>
</table>

</form>
</td>

</tal:block>

blob
mark :601
data 335
#search { text-align: right; }

p.ok-message 
{
  background-color: #eeffee;
  border: 1px solid #009900;
  padding: 5px;
  color: #009900;
  font-weight: bold;
}
p.error-message 
{
  background-color: #ffeeee;
  border: 1px solid #990000;
  padding: 5px;
  color: #990000;
  font-weight: bold;
}

tr.odd { background-color:#f5f5f5; }

blob
mark :602
data 2130
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate="">Password reset request - <span
 i18n:name="tracker" tal:replace="config/TRACKER_NAME" /></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
 i18n:translate="">Password reset request</span>
<td class="content" metal:fill-slot="content">

<tal:askforinfo tal:condition="python:options['error_message'] or not request.form.has_key('@action')"> 

<p i18n:translate="">You have two options if you have forgotten your password.
If you know the email address you registered with, enter it below.</p>

<p i18n:translate="">If your  user was  automatically  created during
import  from  the old  sourceforge  tracker,  your  e-mail address  is
&lt;Sourceforge  username&gt;@users.sourceforge.net. The  mail address
associated with your account can be changed after login.</p>

<form method="POST" onSubmit="return submit_once()"
      tal:attributes="action context/designator">
    <table class="form">
      <tr>
        <th i18n:translate="">Email Address:</th>
        <td><input name="address"></td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>
          <input type="hidden" name="@action" value="passrst">
          <input type="hidden" name="@template" value="forgotten">
          <input type="submit" value="Request password reset"
           i18n:attributes="value">
        </td>
      </tr>
</table>

<p i18n:translate="">Or, if you know your username, then enter it below.</p>

<p i18n:translate="">If you have previously created or modified issue
reports in the sourceforge issue tracker, you have an account here with
the same username as your sourceforge username.</p>

<table class="form">
 <tr><th i18n:translate="">Username:</th> <td><input name="username"></td> </tr>
 <tr><td></td><td><input type="submit" value="Request password reset"
   i18n:attributes="value"></td></tr>
</table>
</form>

<p i18n:translate="">A confirmation email will be sent to you -
please follow the instructions within it to complete the reset process.</p>

</tal:askforinfo>

</td>
g
</tal:block>

blob
mark :603
data 2992
<html
  tal:define="form request/form/form/value;
  field request/form/property/value"
  >
  <head>
    <title>Search input for user helper</title>
    <script language="Javascript" type="text/javascript"
        tal:content="structure string:<!--
        // this is the name of the field in the original form that we're working on
        form  = parent.opener.document.${form};
        field  = '${field}';
        //-->">
    </script>
    <script type="text/javascript" src="@@file/help_controls.js"></script>
    <link rel="stylesheet" type="text/css" href="@@file/style.css" />
  </head>
  <body onload="parent.submit.url='...'"
    tal:define="
qs request/env/QUERY_STRING;
qs python:'&'.join([a for a in qs.split('&') if not a.startswith('@template=')])"
>
    <pre tal:content="request/env/QUERY_STRING" tal:condition=false />
    <form method="get" name="itemSynopsis"
      target="list"
      tal:attributes="action request/classname"
      tal:define="
      property request/form/property/value;
   cols python:request.columns or 'id username address realname roles'.split();
   sort_on request/sort | nothing;
   sort_desc python:sort_on and request.sort[0][0] == '-';
   sort_on python:sort_on and request.sort[0][1] or 'lastname';

   search_input templates/page/macros/search_input;
   search_select templates/page/macros/search_select;
   search_select_roles templates/page/macros/search_select_roles;
   required python:[];
   th_label templates/page/macros/th_label;
   ">
   <input type="hidden" name="@template" value="help-list">
   <input type="hidden" name="property" value="" tal:attributes="value property">
   <input type="hidden" name="form" value="" tal:attributes="value request/form/form/value">
   <table>
<tr tal:define="name string:username; label string:Username:">
  <th metal:use-macro="th_label">Name</th>
  <td metal:use-macro="search_input"><input type=text></td>
</tr>

<tr tal:define="name string:phone; label string:Phone number">
  <th metal:use-macro="th_label">Phone</th>
  <td metal:use-macro="search_input"><input type=text></td>
</tr>

<tr tal:define="name string:roles;
                onchange string:this.form.submit();
                label string:Roles:"
                >
  <th metal:use-macro="th_label">role</th>
  <td metal:use-macro="search_select_roles">
    <select>
      <option value="">jokester</option>
    </select>
  </td>
</tr>

<tr>
  <td>&nbsp;</td>
  <td>
    <input type="hidden" name="@action" value="search">
    <input type="submit" value="Search" i18n:attributes="value">
    <input type="reset">
    <input type="hidden" value="username,realname,phone,organisation,roles" name="properties">
    <input type="text" name="@pagesize" id="sp-pagesize" value="25" size="2">
    <label for="sp-pagesize" i18n:translate="">Pagesize</label>
  </td>
</tr>

   </table>

</form>
<pre tal:content="request" tal:condition=false />
<script type="text/javascript"><!--
  focus2id('username');
//--></script>
  </body>
</html>

blob
mark :604
data 5468
<tal:block metal:use-macro="templates/help/macros/frame">
<tal:block tal:define="property request/form/property/value;
                  qs request/env/QUERY_STRING;
                  qs python:'&'.join([a for a in qs.split('&') if not a.startswith('@template=')]);
                  form request/form/form/value;
                  field request/form/property/value">
  <tal:block metal:fill-slot="more-javascript">
     <script language="Javascript" type="text/javascript" tal:content="structure string:<!--
      // this is the name of the field in the original form that we're working on
      form  = parent.opener.document.${request/form/form/value};
      callingform=form
      field  = '${request/form/property/value}';
      var listform = null
      function listPresent() { return document.frm_help.cb_listpresent.checked}
      function getListForm()
      {
        if (listPresent()) { return parent.list.document.forms.dummyform}
        else { return null}
      }

      function checkListForm()
      {
        // global listform
        if (listform != null)
        if (parent.list.document.dummyform) 
        {
          listform = parent.list.document.dummyform
          alert(listform)
        }
        var bol= listform != null
        alert('checkListForm: bol='+bol)
        return bol
      }
      //-->">
    </script>
    <script src="@@file/jquery.js" type="text/javascript"></script>
    <script src="@@file/search.js" type="text/javascript"></script>
  </tal:block>
  <tal:block metal:fill-slot="content">
    <div name="search">
      <form method="get" name="itemSynopsis" target="list"
            tal:attributes="action request/classname" 
            tal:define="property request/form/property/value;
                        cols python:request.columns or 'id username address realname roles'.split();
                        sort_on request/sort | nothing;
                        sort_desc python:sort_on and request.sort[0][0] == '-';
                        sort_on python:sort_on and request.sort[0][1] or 'lastname';
                        search_input templates/page/macros/search_input;
                        search_select templates/page/macros/search_select;
                        search_select_roles templates/page/macros/search_select_roles;
                        required python:[];
                        th_label templates/page/macros/th_label; ">
       <input type="hidden" name="@template" value="help-list">
       <input type="hidden" name="property" value="" tal:attributes="value property">
       <input type="hidden" name="form" value="" tal:attributes="value request/form/form/value">
       <table>
        <tr tal:define="name string:username; label string:Username:">
         <th metal:use-macro="th_label">Name</th> 
         <td metal:use-macro="search_input"><input type=text></td>
        </tr>
        <tr tal:define="name string:phone; label string:Phone number">
         <th metal:use-macro="th_label">Phone</th>
         <td metal:use-macro="search_input"><input type=text></td>
        </tr>
        <tr tal:define="name string:roles; onchange string:this.form.submit(); label string:Roles:" >
         <th metal:use-macro="th_label">role</th>
         <td metal:use-macro="search_select_roles">
          <select>
           <option value="">jokester</option>
          </select>
         </td>
        </tr>
        <tr>
         <td>&nbsp;</td>
         <td>
          <input type="hidden" name="@action" value="search"/>
          <input type="submit" value="Search" i18n:attributes="value"/>
          <input type="reset"/>
          <input type="hidden" value="username,realname,phone,organisation,roles" name="properties"/>
          <input type="text" name="@pagesize" id="sp-pagesize" value="25" size="2"/>
          <label for="sp-pagesize" i18n:translate="">Pagesize</label>
         </td>
        </tr>
       </table>
      </form>
      <script type="text/javascript"><!-- focus2id('username'); //--></script>
    </div>
    <!-- for search results: help-list -->
    <div class="list"><p i18n:translate="">Please specify your search parameters!</p></div>
    <div class="submit" onload="parent.focus();" id="submit">
    <form name="frm_help"
          tal:define="batch request/batch;
                      props python:request.form['properties'].value.split(',')"
          class="help-submit"
          id="classhelp-controls">
    <div style="width:100%;text-align:left;margin-bottom:0.2em">
     <input type="text" name="text_preview" size="24" class="preview"
            onchange="f=getListForm();if(f){ reviseList_framed(f, this)};"/>
    </div>
    <input type=checkbox name="cb_listpresent" readonly="readonly" style="display:none"/>
    <input type="button" id="btn_cancel"
           value=" Cancel " onclick="parent.close();return false;"
           i18n:attributes="value" />
    <input type="reset" id="btn_reset"
           onclick="text_field.value=original_field;f=getListForm();if (f) {reviseList_framed(f, this)};return false"/>
    <input type="submit" id="btn_apply" class="apply"
           value=" Apply " onclick="callingform[field].value=text_field.value; parent.close();"
           i18n:attributes="value" />
   </form>
   <script type="text/javascript"><!--
var text_field = document.frm_help.text_preview;
original_field=form[field].value;
text_field.value=original_field;
//--></script>
  </div>
</tal:block>
</tal:block>
</tal:block>

blob
mark :605
data 3747
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate="">User listing - <span
 i18n:name="tracker" tal:replace="config/TRACKER_NAME" /></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
 i18n:translate="">User listing</span>
<td class="content" metal:fill-slot="content">

<span tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))"
 i18n:translate="">You are not allowed to view this page.</span>

<span tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')"
 i18n:translate="">Please login with your username and password.</span>

<form tal:condition="context/is_view_ok" method="get" name="itemSynopsis"
      tal:attributes="action request/classname">

<table class="form" tal:define="
       search_input templates/page/macros/search_input;">

   <tr><th class="header" colspan="5">Search for users</th></tr>
   <tr>
       <th class="header">Username</th>
       <td tal:define="name string:username">
           <input tal:attributes="value python:request.form.getvalue(name) or nothing;
                         name name;
                         id name"/>
       </td>
       <th class="header">Realname</th>
       <td tal:define="name string:realname">
           <input tal:attributes="value python:request.form.getvalue(name) or nothing;
                         name name;
                         id name"/>
       </td>

       <td><input class="form-small" type="submit" value="Search" i18n:attributes="value"/></td>
   </tr>

</table>
   <input type="hidden" name="@action" value="search"/>
</form>


<table width="100%" tal:condition="context/is_view_ok" class="list"
       tal:define="batch request/batch">
<tr>
 <th i18n:translate="">Username</th>
 <th i18n:translate="">Real name</th>
 <th i18n:translate="">Organisation</th>
 <th i18n:translate="">Email address</th>
 <th i18n:translate="">Phone number</th>
 <th tal:condition="context/is_edit_ok" i18n:translate="">Retire</th>
</tr>
<tal:block repeat="user batch">
<tr tal:attributes="class python:['normal', 'alt'][repeat['user'].index%6/3]">
 <td>
  <a tal:attributes="href string:user${user/id}"
     tal:content="user/username">username</a>
 </td>
 <td tal:content="python:user.realname.plain() or default">&nbsp;</td>
 <td tal:content="python:user.organisation.plain() or default">&nbsp;</td>
 <td tal:content="python:user.address.email() or default">&nbsp;</td>
 <td tal:content="python:user.phone.plain() or default">&nbsp;</td>
 <td tal:condition="context/is_edit_ok">
  <a tal:attributes="href string:user${user/id}?@action=retire&@template=index"
   i18n:translate="">retire</a>
 </td>
</tr>
</tal:block>
 <tr tal:condition="batch">
  <th tal:attributes="colspan python:len(request.columns)">
   <table width="100%">
    <tr class="navigation">
     <th>
      <a tal:define="prev batch/previous" tal:condition="prev"
         tal:attributes="href python:request.indexargs_url(request.classname,
         {'@startwith':prev.first, '@pagesize':prev.size})"
         i18n:translate="">&lt;&lt; previous</a>
      &nbsp;
     </th>
     <th i18n:translate=""><span tal:replace="batch/start" i18n:name="start"
     />..<span tal:replace="python: batch.start + batch.length -1" i18n:name="end"
     /> out of <span tal:replace="batch/sequence_length" i18n:name="total"
     /></th>
     <th>
      <a tal:define="next batch/next" tal:condition="next"
         tal:attributes="href python:request.indexargs_url(request.classname,
         {'@startwith':next.first, '@pagesize':next.size})"
         i18n:translate="">next &gt;&gt;</a>
      &nbsp;
     </th>
    </tr>
   </table>
  </th>
 </tr>

</table>
</td>



</tal:block>

blob
mark :606
data 6204
<tal:doc metal:use-macro="templates/page/macros/frame"
define="edit_ok context/is_edit_ok"
>
<title metal:fill-slot="head_title">
<tal:if condition="context/id" i18n:translate=""
 >User <span tal:replace="context/id" i18n:name="id"
 />: <span tal:replace="context/username" i18n:name="title"
 /> - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:if>
<tal:if condition="not:context/id" i18n:translate=""
 >New User - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:if>
</title>
<metal:slot fill-slot="more-javascript">
<script metal:use-macro="templates/page/macros/user_utils"></script>
<script type="text/javascript" src="@@file/help_controls.js"></script>
</metal:slot>
<tal:block metal:fill-slot="body_title"
  define="edit_ok context/is_edit_ok">
 <span tal:condition="python: not (context.id or edit_ok)"
  tal:omit-tag="python:1" i18n:translate="">New User</span>
 <span tal:condition="python: not context.id and edit_ok"
  tal:omit-tag="python:1" i18n:translate="">New User Editing</span>
 <span tal:condition="python: context.id and not edit_ok"
  tal:omit-tag="python:1" i18n:translate="">User<tal:x
  replace="context/id" i18n:name="id" /></span>
 <span tal:condition="python: context.id and edit_ok"
  tal:omit-tag="python:1" i18n:translate="">User<tal:x
  replace="context/id" i18n:name="id" /> Editing</span>
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<div tal:condition="context/is_view_ok">

<form method="POST"
      tal:define="required python:'username address'.split()"
      enctype="multipart/form-data"
      tal:attributes="action context/designator;
      onSubmit python:'return checkRequiredFields(\'%s\')'%'\', \''.join(required);
      ">
<table class="form" tal:define="
  th_label templates/page/macros/th_label;
  src_input templates/page/macros/user_src_input;
  normal_input templates/page/macros/user_normal_input;
  pw_input templates/page/macros/user_pw_input;
  confirm_input templates/page/macros/user_confirm_input;
  edit_ok context/is_edit_ok;
  ">
 <tr tal:define="name string:realname; label string:Name; value context/realname; edit_ok edit_ok">
  <th metal:use-macro="th_label">Name</th>
  <td><input name="realname" metal:use-macro="src_input"></td>
 </tr>
 <tr tal:define="name string:username; label string:Login Name; value context/username">
   <th metal:use-macro="th_label">Login Name</th>
   <td><input metal:use-macro="src_input"></td>
 </tr>
 <tal:if condition="edit_ok">
 <tr tal:define="name string:password; label string:Login Password">
  <th metal:use-macro="th_label">Login Password</th>
  <td><input metal:use-macro="pw_input" type="password"></td>
 </tr>
 <tr tal:define="name string:password; label string:Confirm Password">
  <th metal:use-macro="th_label">Confirm Password</th>
  <td><input metal:use-macro="confirm_input" type="password"></td>
 </tr>
 </tal:if>
 <tal:if condition="python:request.user.hasPermission('Web Roles')">
 <tr tal:define="name string:roles; label string:Roles;">
  <th><label for="roles" i18n:translate="">Roles</label></th>
  <td tal:define="gips context/id">
    <tal:subif condition=gips define="value context/roles">
      <input metal:use-macro="normal_input">
    </tal:subif>
    <tal:subif condition="not:gips" define="value db/config/NEW_WEB_USER_ROLES">
      <input metal:use-macro="normal_input">
    </tal:subif>
   <tal:block i18n:translate="">(to give the user more than one role,
    enter a comma,separated,list)</tal:block>
  </td>
 </tr>
 </tal:if>

 <tr tal:define="name string:phone; label string:Phone; value context/phone">
  <th metal:use-macro="th_label">Phone</th>
  <td><input name="phone" metal:use-macro="normal_input"></td>
 </tr>

 <tr tal:define="name string:organisation; label string:Organisation; value context/organisation">
  <th metal:use-macro="th_label">Organisation</th>
  <td><input name="organisation" metal:use-macro="normal_input"></td>
 </tr>

 <tr tal:condition="python:edit_ok or context.timezone"
     tal:define="name string:timezone; label string:Timezone; value context/timezone">
  <th metal:use-macro="th_label">Timezone</th>
  <td><input tal:replace="structure python:
       utils.tzfield(context.timezone, 'timezone', db.config.DEFAULT_TIMEZONE)"/>
  </td>
 </tr>

 <tr tal:define="name string:address; label string:E-mail address; value context/address">
  <th metal:use-macro="th_label">E-mail address</th>
  <td tal:define="mailto python:context.address.field(id='address');
	  mklink python:mailto and not edit_ok">
      <a href="mailto:calvin@the-z.org"
		  tal:attributes="href string:mailto:$value"
		  tal:content="value"
          tal:condition="python:mklink">calvin@the-z.org</a>
      <tal:if condition=edit_ok>
      <input metal:use-macro="src_input" value="calvin@the-z.org">
      </tal:if>
      &nbsp;
  </td>
 </tr>

 <tr>
  <th><label for="alternate_addresses" i18n:translate="">Alternate E-mail addresses<br>One address per line</label></th>
  <td>
    <textarea rows=5 cols=40 tal:replace="structure context/alternate_addresses/multiline">nobody@nowhere.org
anybody@everywhere.net
(alternate_addresses)
    </textarea>
  </td>
 </tr>

 <tr tal:condition="edit_ok">
  <td>
   &nbsp;
   <input type="hidden" name="@template" value="item">
   <input type="hidden" name="@required" value="username,address"
          tal:attributes="value python:','.join(required)">
  </td>
  <td><input type="submit" value="save" tal:replace="structure context/submit"><!--submit button here-->
    <input type="reset">
  </td>
 </tr>
</table>
</form>

<tal:block tal:condition="not:context/id" i18n:translate="">
<table class="form">
<tr>
 <td>Note:&nbsp;</td>
 <th class="required">highlighted</th>
 <td>&nbsp;fields are required.</td>
</tr>
</table>
</tal:block>

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</div>

</td>

</tal:doc>

blob
mark :607
data 3027
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title"
 i18n:translate="">Registering with <span i18n:name="tracker"
 tal:replace="db/config/TRACKER_NAME" /></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
 i18n:translate="">Registering with <span i18n:name="tracker"
 tal:replace="db/config/TRACKER_NAME" /></span>
<td class="content" metal:fill-slot="content">

<p><span style="color:red; font-size:large;">NOTE</span>: If you have previously created or modified issue
reports using the sourceforge issue tracker previously used for python
bugs, your username on sourceforge already exists in this tracker. Use
the <a href="user?@template=forgotten">Password recovery form</a> to
get a password for your account.</p>


<form method="POST" onSubmit="return submit_once()"
      enctype="multipart/form-data"
      tal:attributes="action context/designator">

<input type="hidden" name="opaque" tal:attributes="value python: utils.timestamp()" />
<table class="form">
 <tr>
  <th i18n:translate="">Name</th>
  <td tal:content="structure context/realname/field">realname</td>
 </tr>
 <tr>
  <th class="required" i18n:translate="">Login Name</th>
  <td tal:content="structure context/username/field">username</td>
 </tr>
 <tr>
  <th class="required" i18n:translate="">Login Password</th>
  <td tal:content="structure context/password/field">password</td>
 </tr>
 <tr>
  <th class="required" i18n:translate="">Confirm Password</th>
  <td tal:content="structure context/password/confirm">password</td>
 </tr>
 <tr tal:condition="python:request.user.hasPermission('Web Roles')">
  <th i18n:translate="">Roles</th>
  <td tal:condition="exists:item"
      tal:content="structure context/roles/field">roles</td>
  <td tal:condition="not:exists:item">
   <input name="roles" tal:attributes="value db/config/NEW_WEB_USER_ROLES">
  </td>
 </tr>
 <tr>
  <th i18n:translate="">Phone</th>
  <td tal:content="structure context/phone/field">phone</td>
 </tr>
 <tr>
  <th i18n:translate="">Organisation</th>
  <td tal:content="structure context/organisation/field">organisation</td>
 </tr>
 <tr>
  <th class="required" i18n:translate="">E-mail address</th>
  <td tal:content="structure context/address/field">address</td>
 </tr>
 <tr>
  <th i18n:translate="">Alternate E-mail addresses<br>One address per line</th>
  <td tal:content="structure context/alternate_addresses/multiline">alternate_addresses</td>
 </tr>

 <tr>
  <td>&nbsp;</td>
  <td>
   <input type="hidden" name="@template" value="register">
   <input type="hidden" name="@required" value="username,password,address">
   <input type="hidden" name="@action" value="register">
   <input type="submit" name="submit" value="Register" i18n:attributes="value">
  </td>
 </tr>
</table>
</form>

<tal:block tal:condition="not:context/id" i18n:translate="">
<table class="form">
<tr>
 <td>Note:&nbsp;</td>
 <th class="required">highlighted</th>
 <td>&nbsp;fields are required.</td>
</tr>
</table>
</tal:block>

</td>

</tal:block>

blob
mark :608
data 560
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title"
 i18n:translate="">Registration in progress - <span i18n:name="tracker"
 tal:replace="config/TRACKER_NAME" /></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
 i18n:translate="">Registration in progress...</span>
<td class="content" metal:fill-slot="content">

<p i18n:translate="">You will shortly receive an email
to confirm your registration. To complete the registration process,
visit the link indicated in the email.
</p>

</td>
</tal:block>

blob
mark :609
data 3008
// User Editing Utilities

/**
 * for new users:
 * Depending on the input field which calls it, takes the value
 * and dispatches it to certain other input fields:
 *
 * address
 *  +-> username
 *  |    `-> realname
 *  `-> organisation
 */
function split_name(that) {
    var raw = that.value
    var val = trim(raw)
    if (val == '') {
        return
    }
    var username=''
    var realname=''
    var address=''
    switch (that.name) {
        case 'address':
            address=val
            break
        case 'username':
            username=val
            break
        case 'realname':
            realname=val
            break
        default:
            alert('Ooops - unknown name field '+that.name+'!')
            return
    }
    var the_form = that.form;

    function field_empty(name) {
        return the_form[name].value == ''
    }
    
    // no break statements - on purpose!
    switch (that.name) {
        case 'address':
            var split1 = address.split('@')
            if (field_empty('username')) {
                username = split1[0]
                the_form.username.value = username
            }
            if (field_empty('organisation')) {
                the_form.organisation.value = default_organisation(split1[1])
            }
        case 'username':
            if (field_empty('realname')) {
                realname = Cap(username.split('.').join(' '))
                the_form.realname.value = realname
            }
        case 'realname':
            if (field_empty('username')) {
                username = Cap(realname.replace(' ', '.'))
                the_form.username.value = username
            }
            if (the_form.firstname && the_form.lastname) {
                var split2 = realname.split(' ')
                var firstname='', lastname=''
                firstname = split2[0]
                lastname = split2.slice(1).join(' ')
                if (field_empty('firstname')) {
                    the_form.firstname.value = firstname
                }
                if (field_empty('lastname')) {
                    the_form.lastname.value = lastname
                }
            }
    }
}

function SubCap(str) {
    switch (str) {
        case 'de': case 'do': case 'da':
        case 'du': case 'von':
            return str;
    }
    if (str.toLowerCase().slice(0,2) == 'mc') {
        return 'Mc'+str.slice(2,3).toUpperCase()+str.slice(3).toLowerCase()
    }
    return str.slice(0,1).toUpperCase()+str.slice(1).toLowerCase()
}

function Cap(str) {
    var liz = str.split(' ')
    for (var i=0; i<liz.length; i++) {
        liz[i] = SubCap(liz[i])
    }
    return liz.join(' ')
}

/**
 * Takes a domain name (behind the @ part of an email address)
 * Customise this to handle the mail domains you're interested in 
 */
function default_organisation(orga) {
    switch (orga.toLowerCase()) {
        case 'gmx':
        case 'yahoo':
            return ''
        default:
            return orga
    }
}


blob
mark :610
data 3184
from roundup.password import Password

#
# TRACKER INITIAL PRIORITY AND STATUS VALUES
#

bug_type = db.getclass('bug_type')
bug_type.create(name='crash', order='1')
bug_type.create(name='compile error', order='2')
bug_type.create(name='resource usage', order='3')
bug_type.create(name='security', order='4')
bug_type.create(name='behavior', order='5')
bug_type.create(name='rfe', order='6')

component = db.getclass('component')
#component.create(name="any", order="1")
#component.create(name="3rd party modifications", order="2")
#component.create(name="command-line interface", order="3")
#component.create(name="database", order="4")
#component.create(name="documentation", order="5")
#component.create(name="installation", order="6")
#component.create(name="mail interface", order="7")
#component.create(name="web interface", order="8")

version = db.getclass('version')
version.create(name='devel', order='1')
version.create(name='1.0', order='2')
version.create(name='1.1', order='3')
version.create(name='1.2', order='4')
version.create(name='1.3', order='5')
version.create(name='1.4', order='6')


severity = db.getclass('severity')
severity.create(name='critical', order='1')
severity.create(name='urgent', order='2')
severity.create(name='major', order='3')
severity.create(name='normal', order='4')
severity.create(name='minor', order='5')

priority = db.getclass('priority')
priority.create(name='immediate', order='1')
priority.create(name='urgent', order='2')
priority.create(name='high', order='3')
priority.create(name='normal', order='4')
priority.create(name='low', order='5')

status = db.getclass('status')
status.create(name = "new", order = "1")
status.create(name='open', order='2')
status.create(name='closed', order='3')
status.create(name='pending', description='user feedback required', order='4')

resolution = db.getclass('resolution')
resolution.create(name='accepted', order='1')
resolution.create(name='duplicate', order='2')
resolution.create(name='fixed', order='3')
resolution.create(name='invalid', order='4')
resolution.create(name='later', order='5')
resolution.create(name='out of date', order='6')
resolution.create(name='postponed', order='7')
resolution.create(name='rejected', order='8')
resolution.create(name='remind', order='9')
resolution.create(name='wont fix', order='10')
resolution.create(name='works for me', order='11')

keyword = db.getclass("keyword")
keyword.create(name="patch", description="Contains patch")

#
# create the two default users
user = db.getclass('user')
user.create(username="admin", password=adminpw, address=admin_email, roles='Admin')
user.create(username="anonymous", roles='Anonymous')
user.create(username="user", roles='User')
user.create(username="developer", roles='User, Developer')
user.create(username="coordinator", roles='User, Developer, Coordinator')

bug = db.getclass('bug')
bug.create(title="the first")
bug.create(title="the second")
bug.create(title="the third")

task = db.getclass('task')
task.create(title="the first")
task.create(title="the second")
task.create(title="the third")

milestone = db.getclass('milestone')
milestone.create(title="release 1", bugs=['1','2'], tasks=['3'])


blob
mark :611
data 12822

#
# TRACKER SCHEMA
#

# Class automatically gets these properties:
#   creation = Date()
#   activity = Date()
#   creator = Link('user')
#   actor = Link('user')

# Component
component = Class(db, 'component',
                  name=String(),
                  description=String(),
                  order=Number(),
                  assign_to=Link('user'))
component.setkey('name')

# Version
version = Class(db, 'version',
                name=String(),
                description=String(),
                order=Number())
version.setkey('name')

# Severity
severity = Class(db, 'severity',
                 name=String(),
                 description=String(),
                 order=Number())
severity.setkey('name')

# Priority
priority = Class(db, 'priority',
                 name=String(),
                 description=String(),
                 order=Number())
priority.setkey('name')

# Status
status = Class(db, "status",
               name=String(),
               description=String(),
               order=Number())
status.setkey("name")

# Resolution
resolution = Class(db, "resolution",
                   name=String(),
                   description=String(),
                   order=Number())
resolution.setkey('name')

# Keyword
keyword = Class(db, "keyword",
                name=String(),
                description=String())
keyword.setkey("name")
                

# User-defined saved searches
query = Class(db, "query",
              klass=String(),
              name=String(),
              url=String(),
              private_for=Link('user'))

# add any additional database schema configuration here

user = Class(db, "user",
             username=String(),
             password=Password(),
             address=String(),
             realname=String(),
             phone=String(),
             organisation=String(),
             alternate_addresses=String(),
             queries=Multilink('query'),
             roles=String(),     # comma-separated string of Role names
             timezone=String())
user.setkey("username")

# FileClass automatically gets this property in addition to the Class ones:
#   content = String()    [saved to disk in <tracker home>/db/files/]
#   type = String()       [MIME type of the content, default 'text/plain']
msg = FileClass(db, "msg",
                author=Link("user", do_journal='no'),
                recipients=Multilink("user", do_journal='no'),
                date=Date(),
                summary=String(),
                files=Multilink("file"),
                messageid=String(),
                inreplyto=String())

file = FileClass(db, "file",
                name=String(),
                description=String(indexme='yes'))

# Bug Type
bug_type = Class(db, 'bug_type',
                 name=String(),
                 description=String(),
                 order=Number())
bug_type.setkey('name')

# IssueClass automatically gets these properties in addition to the Class ones:
#   title = String()
#   messages = Multilink("msg")
#   files = Multilink("file")
#   nosy = Multilink("user")
#   superseder = Multilink("issue")
bug = IssueClass(db, "bug",
                 type=Link('bug_type'),
                 components=Multilink('component'),
                 versions=Multilink('version'),
                 severity=Link('severity'),
                 priority=Link('priority'),
                 dependencies=Multilink('bug'),
                 assignee=Link('user'),
                 status=Link('status'),
                 resolution=Link('resolution'),
                 superseder=Link('bug'),
                 keywords=Multilink('keyword'))

# Task Type
task_type = Class(db, 'task_type',
                 name=String(),
                 description=String(),
                 order=Number())
task_type.setkey('name')

# IssueClass automatically gets these properties in addition to the Class ones:
#   title = String()
#   messages = Multilink("msg")
#   files = Multilink("file")
#   nosy = Multilink("user")
#   superseder = Multilink("issue")
task = IssueClass(db, "task",
                  type=Link('task_type'),
                  components=Multilink('component'),
                  priority=Link('priority'),
                  dependencies=Multilink('task'),
                  assignee=Multilink('user'),
                  status=Link('status'),
                  resolution=Link('resolution'),
                  solves=Link('bug'))

milestone = IssueClass(db, "milestone",
                       bugs=Multilink("bug"),
                       tasks=Multilink("task"),
                       status=Link("status"),
                       release_date=String())

#
# TRACKER SECURITY SETTINGS
#
# See the configuration and customisation document for information
# about security setup.

db.security.addRole(name='Developer', description='A developer')
db.security.addRole(name='Coordinator', description='A coordinator')

#
# REGULAR USERS
#
# Give the regular users access to the web and email interface
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, 'Web Access')
    db.security.addPermissionToRole(r, 'Email Access')

##########################
# User permissions
##########################

for cl in ('severity', 'component',
           'version', 'priority', 'status', 'resolution',
           'bug_type', 'bug', 'task_type', 'task', 'milestone',
           'keyword', 'file', 'msg'):
    db.security.addPermissionToRole('User', 'View', cl)
    db.security.addPermissionToRole('Anonymous', 'View', cl)
    db.security.addPermissionToRole('User', 'Create', cl)
    

def may_edit_file(db, userid, itemid):
    return userid == db.file.get(itemid, "creator")

p = db.security.addPermission(name='Edit', klass='file', check=may_edit_file,
    description="User is allowed to remove their own files")
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Create', klass='bug',
                              properties=('title', 'bug_type',
                                          'components', 'versions',
                                          'severity',
                                          'messages', 'files', 'nosy'),
                              description='User can report and discuss bugs')
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Edit', klass='bug',
                              properties=('title', 'bug_type',
                                          'components', 'versions',
                                          'severity',
                                          'messages', 'files', 'nosy'),
                              description='User can report and discuss bugs')
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Create', klass='task',
                              properties=('title', 'task_type',
                                          'components',
                                          'messages', 'files', 'nosy'),
                              description='Developer can create and discuss tasks')
db.security.addPermissionToRole('Developer', p)

p = db.security.addPermission(name='Edit', klass='task',
                              properties=('title', 'task_type',
                                          'components',
                                          'messages', 'files', 'nosy'),
                              description='Developer can create and discuss tasks')
db.security.addPermissionToRole('Developer', p)

p = db.security.addPermission(name='Create', klass='milestone',
                              description='Coordinator can create and discuss milestones')
db.security.addPermissionToRole('Coordinator', p)

p = db.security.addPermission(name='Edit', klass='milestone',
                              description='Coordinator can create and discuss milestones')
db.security.addPermissionToRole('Coordinator', p)


##########################
# Developer permissions
##########################
for cl in ('bug_type', 'severity', 'component',
           'version', 'priority', 'status', 'resolution',
           'bug', 'file', 'msg', 'keyword'):
    db.security.addPermissionToRole('Developer', 'View', cl)

for cl in ('bug', 'file', 'msg', 'keyword'):
    db.security.addPermissionToRole('Developer', 'Edit', cl)
    db.security.addPermissionToRole('Developer', 'Create', cl)


##########################
# Coordinator permissions
##########################
for cl in ('bug_type', 'task_type', 'severity', 'component',
           'version', 'priority', 'status', 'resolution', 'bug', 'task', 'file', 'msg'):
    db.security.addPermissionToRole('Coordinator', 'View', cl)
    db.security.addPermissionToRole('Coordinator', 'Edit', cl)
    db.security.addPermissionToRole('Coordinator', 'Create', cl)

# May users view other user information? Comment these lines out
# if you don't want them to
db.security.addPermissionToRole('User', 'View', 'user')
db.security.addPermissionToRole('Developer', 'View', 'user')
db.security.addPermissionToRole('Coordinator', 'View', 'user')

# Allow Coordinator to edit any user, including their roles.
db.security.addPermissionToRole('Coordinator', 'Edit', 'user')
db.security.addPermissionToRole('Coordinator', 'Web Roles')

# Users should be able to edit their own details -- this permission is
# limited to only the situation where the Viewed or Edited item is their own.
def own_record(db, userid, itemid):
    '''Determine whether the userid matches the item being accessed.'''
    return userid == itemid
p = db.security.addPermission(name='View', klass='user', check=own_record,
    description="User is allowed to view their own user details")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Edit', klass='user', check=own_record,
    description="User is allowed to edit their own user details",
    properties=('username', 'password',
                'address', 'realname',
                'phone', 'organization',
                'alternate_addresses',
                'queries',
                'timezone')) # Note: 'roles' excluded - users should not be able to edit their own roles. 
for r in 'User', 'Developer':
    db.security.addPermissionToRole(r, p)

# Users should be able to edit and view their own queries. They should also
# be able to view any marked as not private. They should not be able to
# edit others' queries, even if they're not private
def view_query(db, userid, itemid):
    private_for = db.query.get(itemid, 'private_for')
    if not private_for: return True
    return userid == private_for
def edit_query(db, userid, itemid):
    return userid == db.query.get(itemid, 'creator')
p = db.security.addPermission(name='View', klass='query', check=view_query,
    description="User is allowed to view their own and public queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Edit', klass='query', check=edit_query,
    description="User is allowed to edit their queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Create', klass='query',
    description="User is allowed to create queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)


#
# ANONYMOUS USER PERMISSIONS
#
# Let anonymous users access the web interface. Note that almost all
# trackers will need this Permission. The only situation where it's not
# required is in a tracker that uses an HTTP Basic Authenticated front-end.
db.security.addPermissionToRole('Anonymous', 'Web Access')

# Let anonymous users access the email interface (note that this implies
# that they will be registered automatically, hence they will need the
# "Create" user Permission below)
# This is disabled by default to stop spam from auto-registering users on
# public trackers.
#db.security.addPermissionToRole('Anonymous', 'Email Access')

# Assign the appropriate permissions to the anonymous user's Anonymous
# Role. Choices here are:
# - Allow anonymous users to register
db.security.addPermissionToRole('Anonymous', 'Create', 'user')

# Allow anonymous users access to view issues (and the related, linked
# information).

for cl in 'bug', 'task', 'milestone', 'severity', 'status', 'resolution', 'msg', 'file':
    db.security.addPermissionToRole('Anonymous', 'View', cl)

# [OPTIONAL]
# Allow anonymous users access to create or edit "issue" items (and the
# related file and message items)
#for cl in 'issue', 'file', 'msg':
#   db.security.addPermissionToRole('Anonymous', 'Create', cl)
#   db.security.addPermissionToRole('Anonymous', 'Edit', cl)


# vim: set filetype=python sts=4 sw=4 et si :


commit refs/heads/gsoc-2009
mark :612
author Stefan Seefeld <stefan@users.sourceforge.net> 1243903317 +0000
committer Stefan Seefeld <stefan@users.sourceforge.net> 1243903317 +0000
data 34
Add new tracker template sandbox.
from :557
property svn 4 4215
M 100644 :558 share/roundup/templates/devel/TEMPLATE-INFO.txt
M 100644 :559 share/roundup/templates/devel/config.ini
M 100644 :560 share/roundup/templates/devel/detectors/messagesummary.py
M 100644 :561 share/roundup/templates/devel/detectors/no_texthtml.py
M 100644 :562 share/roundup/templates/devel/detectors/nosyreaction.py
M 100644 :563 share/roundup/templates/devel/detectors/patches.py
M 100644 :564 share/roundup/templates/devel/detectors/severityauditor.py
M 100644 :565 share/roundup/templates/devel/detectors/statusauditor.py
M 100644 :566 share/roundup/templates/devel/detectors/userauditor.py
M 100644 :567 share/roundup/templates/devel/extensions/local_replace.py
M 100644 :568 share/roundup/templates/devel/extensions/spambayes.py
M 100644 :569 share/roundup/templates/devel/extensions/timestamp.py
M 100644 :570 share/roundup/templates/devel/extensions/timezone.py
M 100644 :186 share/roundup/templates/devel/html/_generic.404.html
M 100644 :187 share/roundup/templates/devel/html/_generic.calendar.html
M 100644 :571 share/roundup/templates/devel/html/_generic.collision.html
M 100644 :189 share/roundup/templates/devel/html/_generic.help-empty.html
M 100644 :572 share/roundup/templates/devel/html/_generic.help-list.html
M 100644 :191 share/roundup/templates/devel/html/_generic.help-search.html
M 100644 :192 share/roundup/templates/devel/html/_generic.help-submit.html
M 100644 :573 share/roundup/templates/devel/html/_generic.help.html
M 100644 :574 share/roundup/templates/devel/html/_generic.index.html
M 100644 :575 share/roundup/templates/devel/html/_generic.item.html
M 100644 :576 share/roundup/templates/devel/html/bug.index.html
M 100644 :577 share/roundup/templates/devel/html/bug.item.html
M 100644 :578 share/roundup/templates/devel/html/bug.search.html
M 100644 :579 share/roundup/templates/devel/html/favicon.ico
M 100644 :580 share/roundup/templates/devel/html/file.index.html
M 100644 :581 share/roundup/templates/devel/html/file.item.html
M 100644 :582 share/roundup/templates/devel/html/help.css
M 100644 :583 share/roundup/templates/devel/html/help.html
M 100644 :584 share/roundup/templates/devel/html/help_controls.js
M 100644 :585 share/roundup/templates/devel/html/home.classlist.html
M 100644 :586 share/roundup/templates/devel/html/home.html
M 100644 :587 share/roundup/templates/devel/html/jquery.js
M 100644 :588 share/roundup/templates/devel/html/keyword.index.html
M 100644 :589 share/roundup/templates/devel/html/keyword.item.html
M 100644 :590 share/roundup/templates/devel/html/milestone.index.html
M 100644 :591 share/roundup/templates/devel/html/milestone.item.html
M 100644 :592 share/roundup/templates/devel/html/msg.index.html
M 100644 :593 share/roundup/templates/devel/html/msg.item.html
M 100644 :594 share/roundup/templates/devel/html/page.html
M 100644 :595 share/roundup/templates/devel/html/query.edit.html
M 100644 :210 share/roundup/templates/devel/html/query.item.html
M 100644 :596 share/roundup/templates/devel/html/search.js
M 100644 :597 share/roundup/templates/devel/html/style.css
M 100644 :598 share/roundup/templates/devel/html/task.index.html
M 100644 :599 share/roundup/templates/devel/html/task.item.html
M 100644 :600 share/roundup/templates/devel/html/task.search.html
M 100644 :601 share/roundup/templates/devel/html/tracker.css
M 100644 :602 share/roundup/templates/devel/html/user.forgotten.html
M 100644 :603 share/roundup/templates/devel/html/user.help-search.html
M 100644 :604 share/roundup/templates/devel/html/user.help.html
M 100644 :605 share/roundup/templates/devel/html/user.index.html
M 100644 :606 share/roundup/templates/devel/html/user.item.html
M 100644 :607 share/roundup/templates/devel/html/user.register.html
M 100644 :608 share/roundup/templates/devel/html/user.rego_progress.html
M 100644 :609 share/roundup/templates/devel/html/user_utils.js
M 100644 :610 share/roundup/templates/devel/initial_data.py
M 100644 :611 share/roundup/templates/devel/schema.py

blob
mark :613
data 5155
#! /usr/bin/env python
#
# Copyright (c) 2003 Richard Jones (richard@mechanicalcat.net)
#

import errno
import os
import socket
import sys
import urlparse
from glob import glob
import getopt

from roundup import configuration
from roundup.scripts import roundup_server

def install_demo(home, backend, template):
    """Install a demo tracker

    Parameters:
        home:
            tracker home directory path
        backend:
            database backend name
        template:
            tracker template

    """

    from roundup import init, instance, password, backends

    # set up the config for this tracker
    config = configuration.CoreConfig()
    config['TRACKER_HOME'] = home
    config['MAIL_DOMAIN'] = 'localhost'
    config['DATABASE'] = 'db'
    config['WEB_DEBUG'] = True
    if backend in ('mysql', 'postgresql'):
        config['RDBMS_HOST'] = 'localhost'
        config['RDBMS_USER'] = 'rounduptest'
        config['RDBMS_PASSWORD'] = 'rounduptest'
        config['RDBMS_NAME'] = 'rounduptest'

    # see if we have further db nuking to perform
    module = backends.get_backend(backend)
    if module.db_exists(config):
        module.db_nuke(config)

    template_dir = os.path.join('share', 'roundup', 'templates', template)
    init.install(home, template_dir)
    # don't have email flying around
    os.remove(os.path.join(home, 'detectors', 'nosyreaction.py'))
    try:
        os.remove(os.path.join(home, 'detectors', 'nosyreaction.pyc'))
    except os.error, error:
        if error.errno != errno.ENOENT:
            raise
    init.write_select_db(home, backend)

    # figure basic params for server
    hostname = 'localhost'
    # pick a fairly odd, random port
    port = 8917
    while 1:
        print 'Trying to set up web server on port %d ...'%port,
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        try:
            s.connect((hostname, port))
        except socket.error, e:
            if not hasattr(e, 'args') or e.args[0] != errno.ECONNREFUSED:
                raise
            print 'should be ok.'
            break
        else:
            s.close()
            print 'already in use.'
            port += 100
    config['TRACKER_WEB'] = 'http://%s:%s/demo/'%(hostname, port)

    # write the config
    config['INSTANT_REGISTRATION'] = 1
    config.save(os.path.join(home, config.INI_FILE))

    # open the tracker and initialise
    tracker = instance.open(home)
    tracker.init(password.Password('admin'))

    # add the "demo" user
    db = tracker.open('admin')
    db.user.create(username='demo', password=password.Password('demo'),
        realname='Demo User', roles='User')
    db.commit()
    db.close()

def run_demo(home):
    """Run the demo tracker installed in ``home``"""
    cfg = configuration.CoreConfig(home)
    url = cfg["TRACKER_WEB"]
    hostname, port = urlparse.urlparse(url)[1].split(':')
    port = int(port)
    success_message = '''Server running - connect to:
    %s
1. Log in as "demo"/"demo" or "admin"/"admin".
2. Hit Control-C to stop the server.
3. Re-start the server by running "roundup-demo" again.
4. Re-initialise the server by running "roundup-demo nuke".

Demo tracker is set up to be accessed by localhost browser.  If you
run demo on a server host, please stop the demo, open file
"demo/config.ini" with your editor, change the host name in the "web"
option in section "[tracker]", save the file, then re-run the demo
program.

''' % url

    # disable command line processing in roundup_server
    sys.argv = sys.argv[:1] + ['-p', str(port), 'demo=' + home]
    roundup_server.run(success_message=success_message)


def usage(msg = ''):

    if msg: print msg
    print 'Usage: %s [options] [nuke]'%sys.argv[0]
    print """
Options:
 -h                -- print this help message
 -t template       -- specify the tracker template to use
 -b backend        -- specify the database backend to use
"""


def main():
    """Run a demo server for users to play with for instant gratification.

    Sets up the web service on localhost. Disables nosy lists.
    """

    try:
        opts, args = getopt.getopt(sys.argv[1:], 't:b:h')
    except getopt.GetoptError, e:
        usage(str(e))
        return 1

    home = os.path.abspath('demo')
    nuke = args and args[0] == 'nuke'
    if not os.path.exists(home) or nuke:
        backend = 'anydbm'
        template = 'classic'
        for opt, arg in opts:
            if opt == '-h':
                usage()
                return 0
            elif opt == '-t':
                template = arg
            elif opt == '-b':
                backend = arg
        if (len(args) > 1 or
            (len(args) == 1 and args[0] != 'nuke')):
            usage()
            return 1

        install_demo(home, backend, template)
    elif opts:
        print "Error: Arguments are not allowed when running an existing demo."
        print "       Use the 'nuke' command to start over."
        sys.exit(1)

    run_demo(home)


if __name__ == '__main__':
    sys.exit(main())

# vim: set filetype=python sts=4 sw=4 et si :

commit refs/heads/gsoc-2009
mark :614
author Stefan Seefeld <stefan@users.sourceforge.net> 1244859175 +0000
committer Stefan Seefeld <stefan@users.sourceforge.net> 1244859175 +0000
data 28
Allow options '-t' and '-b'
from :612
property svn 4 4216
M 100644 :613 demo.py

blob
mark :615
data 1818
#
# Copyright (C) 2009 Stefan Seefeld
# All rights reserved.
# For license terms see the file COPYING.txt.
#

from roundup.exceptions import *
from roundup import hyperdb
from roundup.i18n import _

class Action:
    def __init__(self, db, translator):
        self.db = db
        self.translator = translator

    def handle(self, *args):
        """Action handler procedure"""
        raise NotImplementedError

    def execute(self, *args):
        """Execute the action specified by this object."""

        self.permission(*args)
        return self.handle(*args)


    def permission(self, *args):
        """Check whether the user has permission to execute this action.

        If not, raise Unauthorised."""

        pass


    def gettext(self, msgid):
        """Return the localized translation of msgid"""
        return self.translator.gettext(msgid)


    _ = gettext


class Retire(Action):

    def handle(self, designator):

        classname, itemid = hyperdb.splitDesignator(designator)

        # make sure we don't try to retire admin or anonymous
        if (classname == 'user' and
            self.db.user.get(itemid, 'username') in ('admin', 'anonymous')):
            raise ValueError, self._(
                'You may not retire the admin or anonymous user')

        # do the retire
        self.db.getclass(classname).retire(itemid)
        self.db.commit()


    def permission(self, designator):

        classname, itemid = hyperdb.splitDesignator(designator)

        if not self.db.security.hasPermission('Edit', self.db.getuid(),
                                              classname=classname, itemid=itemid):
            raise Unauthorised(self._('You do not have permission to '
                                      'retire the %(classname)s class.')%classname)
            

blob
mark :616
data 42840
import re, cgi, StringIO, urllib, time, random, csv, codecs

from roundup import hyperdb, token, date, password
from roundup.actions import Action as BaseAction
from roundup.i18n import _
import roundup.exceptions
from roundup.cgi import exceptions, templating
from roundup.mailgw import uidFromAddress

__all__ = ['Action', 'ShowAction', 'RetireAction', 'SearchAction',
           'EditCSVAction', 'EditItemAction', 'PassResetAction',
           'ConfRegoAction', 'RegisterAction', 'LoginAction', 'LogoutAction',
           'NewItemAction', 'ExportCSVAction']

# used by a couple of routines
chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

class Action:
    def __init__(self, client):
        self.client = client
        self.form = client.form
        self.db = client.db
        self.nodeid = client.nodeid
        self.template = client.template
        self.classname = client.classname
        self.userid = client.userid
        self.base = client.base
        self.user = client.user
        self.context = templating.context(client)

    def handle(self):
        """Action handler procedure"""
        raise NotImplementedError

    def execute(self):
        """Execute the action specified by this object."""
        self.permission()
        return self.handle()

    name = ''
    permissionType = None
    def permission(self):
        """Check whether the user has permission to execute this action.

        True by default. If the permissionType attribute is a string containing
        a simple permission, check whether the user has that permission.
        Subclasses must also define the name attribute if they define
        permissionType.

        Despite having this permission, users may still be unauthorised to
        perform parts of actions. It is up to the subclasses to detect this.
        """
        if (self.permissionType and
                not self.hasPermission(self.permissionType)):
            info = {'action': self.name, 'classname': self.classname}
            raise exceptions.Unauthorised, self._(
                'You do not have permission to '
                '%(action)s the %(classname)s class.')%info

    _marker = []
    def hasPermission(self, permission, classname=_marker, itemid=None, property=None):
        """Check whether the user has 'permission' on the current class."""
        if classname is self._marker:
            classname = self.client.classname
        return self.db.security.hasPermission(permission, self.client.userid,
            classname=classname, itemid=itemid, property=property)

    def gettext(self, msgid):
        """Return the localized translation of msgid"""
        return self.client.translator.gettext(msgid)

    _ = gettext

class ShowAction(Action):

    typere=re.compile('[@:]type')
    numre=re.compile('[@:]number')

    def handle(self):
        """Show a node of a particular class/id."""
        t = n = ''
        for key in self.form.keys():
            if self.typere.match(key):
                t = self.form[key].value.strip()
            elif self.numre.match(key):
                n = self.form[key].value.strip()
        if not t:
            raise ValueError, self._('No type specified')
        if not n:
            raise exceptions.SeriousError, self._('No ID entered')
        try:
            int(n)
        except ValueError:
            d = {'input': n, 'classname': t}
            raise exceptions.SeriousError, self._(
                '"%(input)s" is not an ID (%(classname)s ID required)')%d
        url = '%s%s%s'%(self.base, t, n)
        raise exceptions.Redirect, url

class RetireAction(Action):
    name = 'retire'
    permissionType = 'Edit'

    def handle(self):
        """Retire the context item."""
        # ensure modification comes via POST
        if self.client.env['REQUEST_METHOD'] != 'POST':
            raise roundup.exceptions.Reject(self._('Invalid request'))

        # if we want to view the index template now, then unset the itemid
        # context info (a special-case for retire actions on the index page)
        itemid = self.nodeid
        if self.template == 'index':
            self.client.nodeid = None

        # make sure we don't try to retire admin or anonymous
        if self.classname == 'user' and \
                self.db.user.get(itemid, 'username') in ('admin', 'anonymous'):
            raise ValueError, self._(
                'You may not retire the admin or anonymous user')

        # check permission
        if not self.hasPermission('Retire', classname=self.classname,
                itemid=itemid):
            raise exceptions.Unauthorised, self._(
                'You do not have permission to retire %(class)s'
            ) % {'class': self.classname}

        # do the retire
        self.db.getclass(self.classname).retire(itemid)
        self.db.commit()

        self.client.ok_message.append(
            self._('%(classname)s %(itemid)s has been retired')%{
                'classname': self.classname.capitalize(), 'itemid': itemid})


class SearchAction(Action):
    name = 'search'
    permissionType = 'View'

    def handle(self):
        """Mangle some of the form variables.

        Set the form ":filter" variable based on the values of the filter
        variables - if they're set to anything other than "dontcare" then add
        them to :filter.

        Handle the ":queryname" variable and save off the query to the user's
        query list.

        Split any String query values on whitespace and comma.

        """
        self.fakeFilterVars()
        queryname = self.getQueryName()

        # editing existing query name?
        old_queryname = self.getFromForm('old-queryname')

        # handle saving the query params
        if queryname:
            # parse the environment and figure what the query _is_
            req = templating.HTMLRequest(self.client)

            url = self.getCurrentURL(req)

            key = self.db.query.getkey()
            if key:
                # edit the old way, only one query per name
                try:
                    qid = self.db.query.lookup(old_queryname)
                    if not self.hasPermission('Edit', 'query', itemid=qid):
                        raise exceptions.Unauthorised, self._(
                            "You do not have permission to edit queries")
                    self.db.query.set(qid, klass=self.classname, url=url)
                except KeyError:
                    # create a query
                    if not self.hasPermission('Create', 'query'):
                        raise exceptions.Unauthorised, self._(
                            "You do not have permission to store queries")
                    qid = self.db.query.create(name=queryname,
                        klass=self.classname, url=url)
            else:
                # edit the new way, query name not a key any more
                # see if we match an existing private query
                uid = self.db.getuid()
                qids = self.db.query.filter(None, {'name': old_queryname,
                        'private_for': uid})
                if not qids:
                    # ok, so there's not a private query for the current user
                    # - see if there's one created by them
                    qids = self.db.query.filter(None, {'name': old_queryname,
                        'creator': uid})

                if qids and old_queryname:
                    # edit query - make sure we get an exact match on the name
                    for qid in qids:
                        if old_queryname != self.db.query.get(qid, 'name'):
                            continue
                        if not self.hasPermission('Edit', 'query', itemid=qid):
                            raise exceptions.Unauthorised, self._(
                            "You do not have permission to edit queries")
                        self.db.query.set(qid, klass=self.classname,
                            url=url, name=queryname)
                else:
                    # create a query
                    if not self.hasPermission('Create', 'query'):
                        raise exceptions.Unauthorised, self._(
                            "You do not have permission to store queries")
                    qid = self.db.query.create(name=queryname,
                        klass=self.classname, url=url, private_for=uid)

            # and add it to the user's query multilink
            queries = self.db.user.get(self.userid, 'queries')
            if qid not in queries:
                queries.append(qid)
                self.db.user.set(self.userid, queries=queries)

            # commit the query change to the database
            self.db.commit()

    def fakeFilterVars(self):
        """Add a faked :filter form variable for each filtering prop."""
        cls = self.db.classes[self.classname]
        for key in self.form.keys():
            prop = cls.get_transitive_prop(key)
            if not prop:
                continue
            if isinstance(self.form[key], type([])):
                # search for at least one entry which is not empty
                for minifield in self.form[key]:
                    if minifield.value:
                        break
                else:
                    continue
            else:
                if not self.form[key].value:
                    continue
                if isinstance(prop, hyperdb.String):
                    v = self.form[key].value
                    l = token.token_split(v)
                    if len(l) != 1 or l[0] != v:
                        self.form.value.remove(self.form[key])
                        # replace the single value with the split list
                        for v in l:
                            self.form.value.append(cgi.MiniFieldStorage(key, v))

            self.form.value.append(cgi.MiniFieldStorage('@filter', key))

    def getCurrentURL(self, req):
        """Get current URL for storing as a query.

        Note: We are removing the first character from the current URL,
        because the leading '?' is not part of the query string.

        Implementation note:
        But maybe the template should be part of the stored query:
        template = self.getFromForm('template')
        if template:
            return req.indexargs_url('', {'@template' : template})[1:]
        """
        return req.indexargs_url('', {})[1:]

    def getFromForm(self, name):
        for key in ('@' + name, ':' + name):
            if self.form.has_key(key):
                return self.form[key].value.strip()
        return ''

    def getQueryName(self):
        return self.getFromForm('queryname')

class EditCSVAction(Action):
    name = 'edit'
    permissionType = 'Edit'

    def handle(self):
        """Performs an edit of all of a class' items in one go.

        The "rows" CGI var defines the CSV-formatted entries for the class. New
        nodes are identified by the ID 'X' (or any other non-existent ID) and
        removed lines are retired.
        """
        # ensure modification comes via POST
        if self.client.env['REQUEST_METHOD'] != 'POST':
            raise roundup.exceptions.Reject(self._('Invalid request'))

        # figure the properties list for the class
        cl = self.db.classes[self.classname]
        props_without_id = cl.getprops(protected=0).keys()

        # the incoming CSV data will always have the properties in colums
        # sorted and starting with the "id" column
        props_without_id.sort()
        props = ['id'] + props_without_id

        # do the edit
        rows = StringIO.StringIO(self.form['rows'].value)
        reader = csv.reader(rows)
        found = {}
        line = 0
        for values in reader:
            line += 1
            if line == 1: continue
            # skip property names header
            if values == props:
                continue

            # extract the itemid
            itemid, values = values[0], values[1:]
            found[itemid] = 1

            # see if the node exists
            if itemid in ('x', 'X') or not cl.hasnode(itemid):
                exists = 0

                # check permission to create this item
                if not self.hasPermission('Create', classname=self.classname):
                    raise exceptions.Unauthorised, self._(
                        'You do not have permission to create %(class)s'
                    ) % {'class': self.classname}
            else:
                exists = 1

            # confirm correct weight
            if len(props_without_id) != len(values):
                self.client.error_message.append(
                    self._('Not enough values on line %(line)s')%{'line':line})
                return

            # extract the new values
            d = {}
            for name, value in zip(props_without_id, values):
                # check permission to edit this property on this item
                if exists and not self.hasPermission('Edit', itemid=itemid,
                        classname=self.classname, property=name):
                    raise exceptions.Unauthorised, self._(
                        'You do not have permission to edit %(class)s'
                    ) % {'class': self.classname}

                prop = cl.properties[name]
                value = value.strip()
                # only add the property if it has a value
                if value:
                    # if it's a multilink, split it
                    if isinstance(prop, hyperdb.Multilink):
                        value = value.split(':')
                    elif isinstance(prop, hyperdb.Password):
                        value = password.Password(value)
                    elif isinstance(prop, hyperdb.Interval):
                        value = date.Interval(value)
                    elif isinstance(prop, hyperdb.Date):
                        value = date.Date(value)
                    elif isinstance(prop, hyperdb.Boolean):
                        value = value.lower() in ('yes', 'true', 'on', '1')
                    elif isinstance(prop, hyperdb.Number):
                        value = float(value)
                    d[name] = value
                elif exists:
                    # nuke the existing value
                    if isinstance(prop, hyperdb.Multilink):
                        d[name] = []
                    else:
                        d[name] = None

            # perform the edit
            if exists:
                # edit existing
                cl.set(itemid, **d)
            else:
                # new node
                found[cl.create(**d)] = 1

        # retire the removed entries
        for itemid in cl.list():
            if not found.has_key(itemid):
                # check permission to retire this item
                if not self.hasPermission('Retire', itemid=itemid,
                        classname=self.classname):
                    raise exceptions.Unauthorised, self._(
                        'You do not have permission to retire %(class)s'
                    ) % {'class': self.classname}
                cl.retire(itemid)

        # all OK
        self.db.commit()

        self.client.ok_message.append(self._('Items edited OK'))

class EditCommon(Action):
    '''Utility methods for editing.'''

    def _editnodes(self, all_props, all_links):
        ''' Use the props in all_props to perform edit and creation, then
            use the link specs in all_links to do linking.
        '''
        # figure dependencies and re-work links
        deps = {}
        links = {}
        for cn, nodeid, propname, vlist in all_links:
            numeric_id = int (nodeid or 0)
            if not (numeric_id > 0 or all_props.has_key((cn, nodeid))):
                # link item to link to doesn't (and won't) exist
                continue

            for value in vlist:
                if not all_props.has_key(value):
                    # link item to link to doesn't (and won't) exist
                    continue
                deps.setdefault((cn, nodeid), []).append(value)
                links.setdefault(value, []).append((cn, nodeid, propname))

        # figure chained dependencies ordering
        order = []
        done = {}
        # loop detection
        change = 0
        while len(all_props) != len(done):
            for needed in all_props.keys():
                if done.has_key(needed):
                    continue
                tlist = deps.get(needed, [])
                for target in tlist:
                    if not done.has_key(target):
                        break
                else:
                    done[needed] = 1
                    order.append(needed)
                    change = 1
            if not change:
                raise ValueError, 'linking must not loop!'

        # now, edit / create
        m = []
        for needed in order:
            props = all_props[needed]
            cn, nodeid = needed
            if props:
                if nodeid is not None and int(nodeid) > 0:
                    # make changes to the node
                    props = self._changenode(cn, nodeid, props)

                    # and some nice feedback for the user
                    if props:
                        info = ', '.join(map(self._, props.keys()))
                        m.append(
                            self._('%(class)s %(id)s %(properties)s edited ok')
                            % {'class':cn, 'id':nodeid, 'properties':info})
                    else:
                        m.append(self._('%(class)s %(id)s - nothing changed')
                            % {'class':cn, 'id':nodeid})
                else:
                    assert props

                    # make a new node
                    newid = self._createnode(cn, props)
                    if nodeid is None:
                        self.nodeid = newid
                    nodeid = newid

                    # and some nice feedback for the user
                    m.append(self._('%(class)s %(id)s created')
                        % {'class':cn, 'id':newid})

            # fill in new ids in links
            if links.has_key(needed):
                for linkcn, linkid, linkprop in links[needed]:
                    props = all_props[(linkcn, linkid)]
                    cl = self.db.classes[linkcn]
                    propdef = cl.getprops()[linkprop]
                    if not props.has_key(linkprop):
                        if linkid is None or linkid.startswith('-'):
                            # linking to a new item
                            if isinstance(propdef, hyperdb.Multilink):
                                props[linkprop] = [newid]
                            else:
                                props[linkprop] = newid
                        else:
                            # linking to an existing item
                            if isinstance(propdef, hyperdb.Multilink):
                                existing = cl.get(linkid, linkprop)[:]
                                existing.append(nodeid)
                                props[linkprop] = existing
                            else:
                                props[linkprop] = newid

        return '<br>'.join(m)

    def _changenode(self, cn, nodeid, props):
        """Change the node based on the contents of the form."""
        # check for permission
        if not self.editItemPermission(props, classname=cn, itemid=nodeid):
            raise exceptions.Unauthorised, self._(
                'You do not have permission to edit %(class)s'
            ) % {'class': cn}

        # make the changes
        cl = self.db.classes[cn]
        return cl.set(nodeid, **props)

    def _createnode(self, cn, props):
        """Create a node based on the contents of the form."""
        # check for permission
        if not self.newItemPermission(props, classname=cn):
            raise exceptions.Unauthorised, self._(
                'You do not have permission to create %(class)s'
            ) % {'class': cn}

        # create the node and return its id
        cl = self.db.classes[cn]
        return cl.create(**props)

    def isEditingSelf(self):
        """Check whether a user is editing his/her own details."""
        return (self.nodeid == self.userid
                and self.db.user.get(self.nodeid, 'username') != 'anonymous')

    _cn_marker = []
    def editItemPermission(self, props, classname=_cn_marker, itemid=None):
        """Determine whether the user has permission to edit this item."""
        if itemid is None:
            itemid = self.nodeid
        if classname is self._cn_marker:
            classname = self.classname
        # The user must have permission to edit each of the properties
        # being changed.
        for p in props:
            if not self.hasPermission('Edit', itemid=itemid,
                    classname=classname, property=p):
                return 0
        # Since the user has permission to edit all of the properties,
        # the edit is OK.
        return 1

    def newItemPermission(self, props, classname=None):
        """Determine whether the user has permission to create this item.

        Base behaviour is to check the user can edit this class. No additional
        property checks are made.
        """

        if not classname :
            classname = self.client.classname
        
        if not self.hasPermission('Create', classname=classname):
            return 0

        # Check Edit permission for each property, to avoid being able
        # to set restricted ones on new item creation
        for key in props:
            if not self.hasPermission('Edit', classname=classname,
                                      property=key):
                # We restrict by default and special-case allowed properties
                if key == 'date' or key == 'content':
                    continue
                elif key == 'author' and props[key] == self.userid:
                    continue
                return 0
        return 1

class EditItemAction(EditCommon):
    def lastUserActivity(self):
        if self.form.has_key(':lastactivity'):
            d = date.Date(self.form[':lastactivity'].value)
        elif self.form.has_key('@lastactivity'):
            d = date.Date(self.form['@lastactivity'].value)
        else:
            return None
        d.second = int(d.second)
        return d

    def lastNodeActivity(self):
        cl = getattr(self.client.db, self.classname)
        activity = cl.get(self.nodeid, 'activity').local(0)
        activity.second = int(activity.second)
        return activity

    def detectCollision(self, user_activity, node_activity):
        '''Check for a collision and return the list of props we edited
        that conflict.'''
        if user_activity and user_activity < node_activity:
            props, links = self.client.parsePropsFromForm()
            key = (self.classname, self.nodeid)
            # we really only collide for direct prop edit conflicts
            return props[key].keys()
        else:
            return []

    def handleCollision(self, props):
        message = self._('Edit Error: someone else has edited this %s (%s). '
            'View <a target="new" href="%s%s">their changes</a> '
            'in a new window.')%(self.classname, ', '.join(props),
            self.classname, self.nodeid)
        self.client.error_message.append(message)
        return

    def handle(self):
        """Perform an edit of an item in the database.

        See parsePropsFromForm and _editnodes for special variables.

        """
        # ensure modification comes via POST
        if self.client.env['REQUEST_METHOD'] != 'POST':
            raise roundup.exceptions.Reject(self._('Invalid request'))

        user_activity = self.lastUserActivity()
        if user_activity:
            props = self.detectCollision(user_activity, self.lastNodeActivity())
            if props:
                self.handleCollision(props)
                return

        props, links = self.client.parsePropsFromForm()

        # handle the props
        try:
            message = self._editnodes(props, links)
        except (ValueError, KeyError, IndexError,
                roundup.exceptions.Reject), message:
            self.client.error_message.append(
                self._('Edit Error: %s') % str(message))
            return

        # commit now that all the tricky stuff is done
        self.db.commit()

        # redirect to the item's edit page
        # redirect to finish off
        url = self.base + self.classname
        # note that this action might have been called by an index page, so
        # we will want to include index-page args in this URL too
        if self.nodeid is not None:
            url += self.nodeid
        url += '?@ok_message=%s&@template=%s'%(urllib.quote(message),
            urllib.quote(self.template))
        if self.nodeid is None:
            req = templating.HTMLRequest(self.client)
            url += '&' + req.indexargs_url('', {})[1:]
        raise exceptions.Redirect, url

class NewItemAction(EditCommon):
    def handle(self):
        ''' Add a new item to the database.

            This follows the same form as the EditItemAction, with the same
            special form values.
        '''
        # ensure modification comes via POST
        if self.client.env['REQUEST_METHOD'] != 'POST':
            raise roundup.exceptions.Reject(self._('Invalid request'))

        # parse the props from the form
        try:
            props, links = self.client.parsePropsFromForm(create=1)
        except (ValueError, KeyError), message:
            self.client.error_message.append(self._('Error: %s')
                % str(message))
            return

        # handle the props - edit or create
        try:
            # when it hits the None element, it'll set self.nodeid
            messages = self._editnodes(props, links)
        except (ValueError, KeyError, IndexError,
                roundup.exceptions.Reject), message:
            # these errors might just be indicative of user dumbness
            self.client.error_message.append(_('Error: %s') % str(message))
            return

        # commit now that all the tricky stuff is done
        self.db.commit()

        # redirect to the new item's page
        raise exceptions.Redirect, '%s%s%s?@ok_message=%s&@template=%s' % (
            self.base, self.classname, self.nodeid, urllib.quote(messages),
            urllib.quote(self.template))

class PassResetAction(Action):
    def handle(self):
        """Handle password reset requests.

        Presence of either "name" or "address" generates email. Presence of
        "otk" performs the reset.

        """
        otks = self.db.getOTKManager()
        if self.form.has_key('otk'):
            # pull the rego information out of the otk database
            otk = self.form['otk'].value
            uid = otks.get(otk, 'uid', default=None)
            if uid is None:
                self.client.error_message.append(
                    self._("Invalid One Time Key!\n"
                        "(a Mozilla bug may cause this message "
                        "to show up erroneously, please check your email)"))
                return

            # re-open the database as "admin"
            if self.user != 'admin':
                self.client.opendb('admin')
                self.db = self.client.db
                otks = self.db.getOTKManager()

            # change the password
            newpw = password.generatePassword()

            cl = self.db.user
            # XXX we need to make the "default" page be able to display errors!
            try:
                # set the password
                cl.set(uid, password=password.Password(newpw))
                # clear the props from the otk database
                otks.destroy(otk)
                self.db.commit()
            except (ValueError, KeyError), message:
                self.client.error_message.append(str(message))
                return

            # user info
            address = self.db.user.get(uid, 'address')
            name = self.db.user.get(uid, 'username')

            # send the email
            tracker_name = self.db.config.TRACKER_NAME
            subject = 'Password reset for %s'%tracker_name
            body = '''
The password has been reset for username "%(name)s".

Your password is now: %(password)s
'''%{'name': name, 'password': newpw}
            if not self.client.standard_message([address], subject, body):
                return

            self.client.ok_message.append(
                self._('Password reset and email sent to %s') % address)
            return

        # no OTK, so now figure the user
        if self.form.has_key('username'):
            name = self.form['username'].value
            try:
                uid = self.db.user.lookup(name)
            except KeyError:
                self.client.error_message.append(self._('Unknown username'))
                return
            address = self.db.user.get(uid, 'address')
        elif self.form.has_key('address'):
            address = self.form['address'].value
            uid = uidFromAddress(self.db, ('', address), create=0)
            if not uid:
                self.client.error_message.append(
                    self._('Unknown email address'))
                return
            name = self.db.user.get(uid, 'username')
        else:
            self.client.error_message.append(
                self._('You need to specify a username or address'))
            return

        # generate the one-time-key and store the props for later
        otk = ''.join([random.choice(chars) for x in range(32)])
        while otks.exists(otk):
            otk = ''.join([random.choice(chars) for x in range(32)])
        otks.set(otk, uid=uid)
        self.db.commit()

        # send the email
        tracker_name = self.db.config.TRACKER_NAME
        subject = 'Confirm reset of password for %s'%tracker_name
        body = '''
Someone, perhaps you, has requested that the password be changed for your
username, "%(name)s". If you wish to proceed with the change, please follow
the link below:

  %(url)suser?@template=forgotten&@action=passrst&otk=%(otk)s

You should then receive another email with the new password.
'''%{'name': name, 'tracker': tracker_name, 'url': self.base, 'otk': otk}
        if not self.client.standard_message([address], subject, body):
            return

        self.client.ok_message.append(self._('Email sent to %s') % address)

class RegoCommon(Action):
    def finishRego(self):
        # log the new user in
        self.client.userid = self.userid
        user = self.client.user = self.db.user.get(self.userid, 'username')
        # re-open the database for real, using the user
        self.client.opendb(user)

        # update session data
        self.client.session_api.set(user=user)

        # nice message
        message = self._('You are now registered, welcome!')
        url = '%suser%s?@ok_message=%s'%(self.base, self.userid,
            urllib.quote(message))

        # redirect to the user's page (but not 302, as some email clients seem
        # to want to reload the page, or something)
        return '''<html><head><title>%s</title></head>
            <body><p><a href="%s">%s</a></p>
            <script type="text/javascript">
            window.setTimeout('window.location = "%s"', 1000);
            </script>'''%(message, url, message, url)

class ConfRegoAction(RegoCommon):
    def handle(self):
        """Grab the OTK, use it to load up the new user details."""
        try:
            # pull the rego information out of the otk database
            self.userid = self.db.confirm_registration(self.form['otk'].value)
        except (ValueError, KeyError), message:
            self.client.error_message.append(str(message))
            return
        return self.finishRego()

class RegisterAction(RegoCommon, EditCommon):
    name = 'register'
    permissionType = 'Create'

    def handle(self):
        """Attempt to create a new user based on the contents of the form
        and then remember it in session.

        Return 1 on successful login.
        """
        # ensure modification comes via POST
        if self.client.env['REQUEST_METHOD'] != 'POST':
            raise roundup.exceptions.Reject(self._('Invalid request'))

        # parse the props from the form
        try:
            props, links = self.client.parsePropsFromForm(create=1)
        except (ValueError, KeyError), message:
            self.client.error_message.append(self._('Error: %s')
                % str(message))
            return

        # registration isn't allowed to supply roles
        user_props = props[('user', None)]
        if user_props.has_key('roles'):
            raise exceptions.Unauthorised, self._(
                "It is not permitted to supply roles at registration.")

        # skip the confirmation step?
        if self.db.config['INSTANT_REGISTRATION']:
            # handle the create now
            try:
                # when it hits the None element, it'll set self.nodeid
                messages = self._editnodes(props, links)
            except (ValueError, KeyError, IndexError,
                    roundup.exceptions.Reject), message:
                # these errors might just be indicative of user dumbness
                self.client.error_message.append(_('Error: %s') % str(message))
                return

            # fix up the initial roles
            self.db.user.set(self.nodeid,
                roles=self.db.config['NEW_WEB_USER_ROLES'])

            # commit now that all the tricky stuff is done
            self.db.commit()

            # finish off by logging the user in
            self.userid = self.nodeid
            return self.finishRego()

        # generate the one-time-key and store the props for later
        for propname, proptype in self.db.user.getprops().items():
            value = user_props.get(propname, None)
            if value is None:
                pass
            elif isinstance(proptype, hyperdb.Date):
                user_props[propname] = str(value)
            elif isinstance(proptype, hyperdb.Interval):
                user_props[propname] = str(value)
            elif isinstance(proptype, hyperdb.Password):
                user_props[propname] = str(value)
        otks = self.db.getOTKManager()
        otk = ''.join([random.choice(chars) for x in range(32)])
        while otks.exists(otk):
            otk = ''.join([random.choice(chars) for x in range(32)])
        otks.set(otk, **user_props)

        # send the email
        tracker_name = self.db.config.TRACKER_NAME
        tracker_email = self.db.config.TRACKER_EMAIL
        if self.db.config['EMAIL_REGISTRATION_CONFIRMATION']:
            subject = 'Complete your registration to %s -- key %s'%(tracker_name,
                                                                  otk)
            body = """To complete your registration of the user "%(name)s" with
%(tracker)s, please do one of the following:

- send a reply to %(tracker_email)s and maintain the subject line as is (the
reply's additional "Re:" is ok),

- or visit the following URL:

%(url)s?@action=confrego&otk=%(otk)s

""" % {'name': user_props['username'], 'tracker': tracker_name,
        'url': self.base, 'otk': otk, 'tracker_email': tracker_email}
        else:
            subject = 'Complete your registration to %s'%(tracker_name)
            body = """To complete your registration of the user "%(name)s" with
%(tracker)s, please visit the following URL:

%(url)s?@action=confrego&otk=%(otk)s

""" % {'name': user_props['username'], 'tracker': tracker_name,
        'url': self.base, 'otk': otk}
        if not self.client.standard_message([user_props['address']], subject,
                body, (tracker_name, tracker_email)):
            return

        # commit changes to the database
        self.db.commit()

        # redirect to the "you're almost there" page
        raise exceptions.Redirect, '%suser?@template=rego_progress'%self.base

class LogoutAction(Action):
    def handle(self):
        """Make us really anonymous - nuke the session too."""
        # log us out
        self.client.make_user_anonymous()
        self.client.session_api.destroy()

        # Let the user know what's going on
        self.client.ok_message.append(self._('You are logged out'))

        # reset client context to render tracker home page
        # instead of last viewed page (may be inaccessibe for anonymous)
        self.client.classname = None
        self.client.nodeid = None
        self.client.template = None

class LoginAction(Action):
    def handle(self):
        """Attempt to log a user in.

        Sets up a session for the user which contains the login credentials.

        """
        # ensure modification comes via POST
        if self.client.env['REQUEST_METHOD'] != 'POST':
            raise roundup.exceptions.Reject(self._('Invalid request'))

        # we need the username at a minimum
        if not self.form.has_key('__login_name'):
            self.client.error_message.append(self._('Username required'))
            return

        # get the login info
        self.client.user = self.form['__login_name'].value
        if self.form.has_key('__login_password'):
            password = self.form['__login_password'].value
        else:
            password = ''

        try:
            self.verifyLogin(self.client.user, password)
        except exceptions.LoginError, err:
            self.client.make_user_anonymous()
            self.client.error_message.extend(list(err.args))
            return

        # now we're OK, re-open the database for real, using the user
        self.client.opendb(self.client.user)

        # save user in session
        self.client.session_api.set(user=self.client.user)
        if self.form.has_key('remember'):
            self.client.session_api.update(set_cookie=True, expire=24*3600*365)

        # If we came from someplace, go back there
        if self.form.has_key('__came_from'):
            raise exceptions.Redirect, self.form['__came_from'].value

    def verifyLogin(self, username, password):
        # make sure the user exists
        try:
            self.client.userid = self.db.user.lookup(username)
        except KeyError:
            raise exceptions.LoginError, self._('Invalid login')

        # verify the password
        if not self.verifyPassword(self.client.userid, password):
            raise exceptions.LoginError, self._('Invalid login')

        # Determine whether the user has permission to log in.
        # Base behaviour is to check the user has "Web Access".
        if not self.hasPermission("Web Access"):
            raise exceptions.LoginError, self._(
                "You do not have permission to login")

    def verifyPassword(self, userid, password):
        '''Verify the password that the user has supplied'''
        stored = self.db.user.get(userid, 'password')
        if password == stored:
            return 1
        if not password and not stored:
            return 1
        return 0

class ExportCSVAction(Action):
    name = 'export'
    permissionType = 'View'

    def handle(self):
        ''' Export the specified search query as CSV. '''
        # figure the request
        request = templating.HTMLRequest(self.client)
        filterspec = request.filterspec
        sort = request.sort
        group = request.group
        columns = request.columns
        klass = self.db.getclass(request.classname)

        # full-text search
        if request.search_text:
            matches = self.db.indexer.search(
                re.findall(r'\b\w{2,25}\b', request.search_text), klass)
        else:
            matches = None

        h = self.client.additional_headers
        h['Content-Type'] = 'text/csv; charset=%s' % self.client.charset
        # some browsers will honor the filename here...
        h['Content-Disposition'] = 'inline; filename=query.csv'

        self.client.header()

        if self.client.env['REQUEST_METHOD'] == 'HEAD':
            # all done, return a dummy string
            return 'dummy'

        wfile = self.client.request.wfile
        if self.client.charset != self.client.STORAGE_CHARSET:
            wfile = codecs.EncodedFile(wfile,
                self.client.STORAGE_CHARSET, self.client.charset, 'replace')

        writer = csv.writer(wfile)
        self.client._socket_op(writer.writerow, columns)

        # and search
        for itemid in klass.filter(matches, filterspec, sort, group):
            row = []
            for name in columns:
                # check permission to view this property on this item
                if not self.hasPermission('View', itemid=itemid,
                        classname=request.classname, property=name):
                    raise exceptions.Unauthorised, self._(
                        'You do not have permission to view %(class)s'
                    ) % {'class': request.classname}
                row.append(str(klass.get(itemid, name)))
            self.client._socket_op(writer.writerow, row)

        return '\n'


class Bridge(BaseAction):
    """Make roundup.actions.Action executable via CGI request.

    Using this allows users to write actions executable from multiple frontends.
    CGI Form content is translated into a dictionary, which then is passed as
    argument to 'handle()'. XMLRPC requests have to pass this dictionary
    directly.
    """

    def __init__(self, *args):

        # As this constructor is callable from multiple frontends, each with
        # different Action interfaces, we have to look at the arguments to
        # figure out how to complete construction.
        if (len(args) == 1 and
            hasattr(args[0], '__class__') and
            args[0].__class__.__name__ == 'Client'):
            self.cgi = True
            self.execute = self.execute_cgi
            self.client = args[0]
            self.form = self.client.form
        else:
            self.cgi = False

    def execute_cgi(self):
        args = {}
        for key in self.form.keys():
            args[key] = self.form.getvalue(key)
        self.permission(args)
        return self.handle(args)

    def permission(self, args):
        """Raise Unauthorised if the current user is not allowed to execute
        this action. Users may override this method."""

        pass

    def handle(self, args):

        raise NotImplementedError

# vim: set filetype=python sts=4 sw=4 et si :

blob
mark :617
data 6001
#
# Copyright (C) 2007 Stefan Seefeld
# All rights reserved.
# For license terms see the file COPYING.txt.
#

from roundup import hyperdb
from roundup.cgi.exceptions import *
from roundup.exceptions import UsageError
from roundup.date import Date, Range, Interval
from roundup import actions
from SimpleXMLRPCServer import *

def translate(value):
    """Translate value to becomes valid for XMLRPC transmission."""

    if isinstance(value, (Date, Range, Interval)):
        return repr(value)
    elif type(value) is list:
        return [translate(v) for v in value]
    elif type(value) is tuple:
        return tuple([translate(v) for v in value])
    elif type(value) is dict:
        return dict([[translate(k), translate(value[k])] for k in value])
    else:
        return value


def props_from_args(db, cl, args, itemid=None):
    """Construct a list of properties from the given arguments,
    and return them after validation."""

    props = {}
    for arg in args:
        if arg.find('=') == -1:
            raise UsageError, 'argument "%s" not propname=value'%arg
        l = arg.split('=')
        if len(l) < 2:
            raise UsageError, 'argument "%s" not propname=value'%arg
        key, value = l[0], '='.join(l[1:])
        if value:
            try:
                props[key] = hyperdb.rawToHyperdb(db, cl, itemid,
                                                  key, value)
            except hyperdb.HyperdbValueError, message:
                raise UsageError, message
        else:
            props[key] = None

    return props

class RoundupInstance:
    """The RoundupInstance provides the interface accessible through
    the Python XMLRPC mapping."""

    def __init__(self, db, actions, translator):

        self.db = db
        self.actions = actions
        self.translator = translator

    def list(self, classname, propname=None):
        cl = self.db.getclass(classname)
        if not propname:
            propname = cl.labelprop()
        result = [cl.get(itemid, propname)
                  for itemid in cl.list()
                  if self.db.security.hasPermission('View', self.db.getuid(),
                                                    classname, propname, itemid)
                  ]
        return result

    def filter(self, classname, search_matches, filterspec,
               sort=[], group=[]):
        cl = self.db.getclass(classname)
        result = cl.filter(search_matches, filterspec, sort=sort, group=group)
        return result

    def display(self, designator, *properties):
        classname, itemid = hyperdb.splitDesignator(designator)
        cl = self.db.getclass(classname)
        props = properties and list(properties) or cl.properties.keys()
        props.sort()
        for p in props:
            if not self.db.security.hasPermission('View', self.db.getuid(),
                                                  classname, p, itemid):
                raise Unauthorised('Permission to view %s of %s denied'%
                                   (p, designator))
            result = [(prop, cl.get(itemid, prop)) for prop in props]
        return dict(result)

    def create(self, classname, *args):
        
        if not self.db.security.hasPermission('Create', self.db.getuid(), classname):
            raise Unauthorised('Permission to create %s denied'%classname)

        cl = self.db.getclass(classname)

        # convert types
        props = props_from_args(self.db, cl, args)

        # check for the key property
        key = cl.getkey()
        if key and not props.has_key(key):
            raise UsageError, 'you must provide the "%s" property.'%key

        for key in props:
            if not self.db.security.hasPermission('Edit', self.db.getuid(), classname,
                                                  property=key):
                raise Unauthorised('Permission to create %s denied'%classname)

        # do the actual create
        try:
            result = cl.create(**props)
        except (TypeError, IndexError, ValueError), message:
            raise UsageError, message
        return result

    def set(self, designator, *args):

        classname, itemid = hyperdb.splitDesignator(designator)
        cl = self.db.getclass(classname)
        props = props_from_args(self.db, cl, args, itemid) # convert types
        for p in props.iterkeys():
            if not self.db.security.hasPermission('Edit', self.db.getuid(),
                                                  classname, p, itemid):
                raise Unauthorised('Permission to edit %s of %s denied'%
                                   (p, designator))
        try:
            return cl.set(itemid, **props)
        except (TypeError, IndexError, ValueError), message:
            raise UsageError, message


    builtin_actions = {'retire': actions.Retire}

    def action(self, name, *args):
        """Execute a named action."""
        
        if name in self.actions:
            action_type = self.actions[name]
        elif name in self.builtin_actions:
            action_type = self.builtin_actions[name]
        else:
            raise Exception('action "%s" is not supported %s' % (name, ','.join(self.actions.keys())))
        action = action_type(self.db, self.translator)
        return action.execute(*args)


class RoundupDispatcher(SimpleXMLRPCDispatcher):
    """RoundupDispatcher bridges from cgi.client to RoundupInstance.
    It expects user authentication to be done."""

    def __init__(self, db, actions, translator,
                 allow_none=False, encoding=None):

        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)
        self.register_instance(RoundupInstance(db, actions, translator))
                 

    def dispatch(self, input):
        return self._marshaled_dispatch(input)

    def _dispatch(self, method, params):

        retn = SimpleXMLRPCDispatcher._dispatch(self, method, params)
        retn = translate(retn)
        return retn
    

commit refs/heads/gsoc-2009
mark :618
author Stefan Seefeld <stefan@users.sourceforge.net> 1245204127 +0000
committer Stefan Seefeld <stefan@users.sourceforge.net> 1245204127 +0000
data 18
Merge from trunk.
from :614
property svn 4 4223
M 100644 :615 roundup/actions.py
M 100755 :616 roundup/cgi/actions.py
M 100644 :617 roundup/xmlrpc.py

blob
mark :619
data 18325
<tal:block metal:define-macro="frame">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <title metal:define-slot="head_title">title goes here</title>
  <link rel="stylesheet" type="text/css" href="@@file/style.css" />
  <meta http-equiv="Content-Type"
        tal:attributes="content string:text/html;; charset=${request/client/charset}" />
  <script tal:replace="structure request/base_javascript"></script>
  <metal:x define-slot="more-javascript" />
 </head>
 <body tal:attributes="class request/classname"
       tal:define="kw_create python:request.user.hasPermission('Create', 'keyword');
                   bug_columns string:id,activity,title,creator,status;
                   bug_columns_showall string:id,activity,title,creator,assignee,status;
                   bug_status_notclosed string:-1,1,2,4;

                   task_columns string:id,activity,title,creator,status;
                   task_columns_showall string:id,activity,title,creator,assignee,status;
                   task_status_notclosed string:-1,1,2,4;

                   milestone_columns string:id,activity,title,creator,status;
                   milestone_columns_showall string:id,activity,title,creator,assignee,status;
                   milestone_status_notclosed string:-1,1,2,4;">
  <div class="header">
   <h1><a href="/">Roundup Demo Tracker</a></h1>
   <div id="searchbox">
    <form name="searchform" method="get" action="bug" id="searchform">
     <div id="search">
      <input type="hidden" name="@columns"
             tal:attributes="value bug_columns_showall"/>
      <input type="hidden" name="@sort" value="-activity" />
      <input type="hidden" name="@group" value="priority" />
      <input type="hidden" name="@filter" value="status"/>
      <input type="hidden" name="status" tal:attributes="value bug_status_notclosed"/>
      <input class="input-text" id="search-text" name="@search_text" size="10" />
      <input type="submit" id="submit" value="search in open bugs" name="submit" class="input-button"/>
     </div>
    </form>
   </div> <!-- searchbox -->
  </div> <!-- header -->
  <div class="navigation">
   <div class="menu">
    <ul>
     <li class="current"><a href="/" i18n:translate="">Bugs</a>
      <ul tal:condition="python:request.user.hasPermission('View', 'bug')">
       <li tal:condition="python:request.user.hasPermission('Create', 'bug')">
        <a href="bug?@template=item" i18n:translate="">Create New</a>
       </li>
       <li>
        <a href="#"
           tal:attributes="href python:request.indexargs_url('bug', {
                                '@sort': '-activity',
                                '@group': 'priority',
                                '@filter': 'status',
                                '@columns': bug_columns_showall,
                                '@search_text': '',
                                'status': bug_status_notclosed,
                                '@dispname': i18n.gettext('Show All'),
                                '@startwith': 0,
                                })"
                i18n:translate="">Show Open</a>
       </li>
       <li><a href="#"
              tal:attributes="href python:request.indexargs_url('bug', {
                                '@sort': '-activity',
                                '@group': 'priority',
                                '@filter': 'status,assignee',
                                '@columns': bug_columns,
                                '@search_text': '',
                                'status': bug_status_notclosed,
                                'assignee': '-1',
                                '@dispname': i18n.gettext('Show Unassigned'),
                                '@startwith': 0,
                                })"
                i18n:translate="">Show Unassigned</a>
       </li>
       <li>
        <a href="bug?@template=search&status=1" i18n:translate="">Search</a>
       </li>
       <li>
        <form method="post" action="#">
         <input type="submit" class="form-small" value="Show bug:" i18n:attributes="value"/>
         <input class="form-small" size="4" type="text" name="@number"/>
         <input type="hidden" name="@type" value="bug"/>
         <input type="hidden" name="@action" value="show"/>
        </form>
       </li>
      </ul>
     </li>
     <li class="current"><a href="/" i18n:translate="">Tasks</a>
      <ul tal:condition="python:request.user.hasPermission('View', 'task')">
       <li tal:condition="python:request.user.hasPermission('Create', 'task')">
        <a href="task?@template=item" i18n:translate="">Create New</a>
       </li>
       <li>
        <a href="#" tal:attributes="href python:request.indexargs_url('task', {
                                '@sort': '-activity',
                                '@group': 'priority',
                                '@filter': 'status',
                                '@columns': task_columns_showall,
                                '@search_text': '',
                                'status': task_status_notclosed,
                                '@dispname': i18n.gettext('Show All'),
                                '@startwith': 0,
                                })"
                i18n:translate="">Show Open</a>
       </li>
       <li>
        <a href="#" tal:attributes="href python:request.indexargs_url('task', {
                                '@sort': '-activity',
                                '@group': 'priority',
                                '@filter': 'status,assignee',
                                '@columns': task_columns,
                                '@search_text': '',
                                'status': task_status_notclosed,
                                'assignee': '-1',
                                '@dispname': i18n.gettext('Show Unassigned'),
                                '@startwith': 0,
                                })"
                i18n:translate="">Show Unassigned</a>
       </li>
       <li>
        <a href="task?@template=search&status=1" i18n:translate="">Search</a>
       </li>
       <li>
        <form method="post" action="#">
         <input type="submit" class="form-small" value="Show task:" i18n:attributes="value"/>
         <input class="form-small" size="4" type="text" name="@number"/>
         <input type="hidden" name="@type" value="task"/>
         <input type="hidden" name="@action" value="show"/>
        </form>
       </li>
      </ul>
     </li>
     <li class="current"><a href="milestone" i18n:translate="">Milestones</a>
      <ul tal:condition="python:request.user.hasPermission('View', 'milestone')">
       <li tal:condition="python:request.user.hasPermission('Create', 'milestone')">
        <a href="milestone?@template=item" i18n:translate="">Create New</a>
       </li>
       <li>
        <a href="#" tal:attributes="href python:request.indexargs_url('milestone', {
                                '@filter': 'status',
                                'status': milestone_status_notclosed,
                                '@dispname': i18n.gettext('Show Open'),
                                '@startwith': 0,
                                })"
                i18n:translate="">Show Open</a>
       </li>
      </ul>
     </li>
    </ul>
    <ul class="user">
     <li tal:condition="python:request.user.username=='anonymous'" class="submenu">
      <b i18n:translate="">User</b>
      <form method="post" action="#">
       <ul>
        <li>
         <tal:span i18n:translate="">Login</tal:span><br/>
         <input size="10" name="__login_name"/><br/>
         <input size="10" type="password" name="__login_password"/><br/>
         <input type="hidden" name="@action" value="Login"/>
         <input type="checkbox" name="remember" id="remember"/>
         <label for="remember" i18n:translate="">Remember me?</label><br/>
         <input class="form-small" type="submit" value="Login" i18n:attributes="value"/><br/>
         <input type="hidden" name="__came_from" tal:attributes="value string:${request/env/PATH_INFO}"/>
         <span tal:replace="structure request/indexargs_form" />
        </li>
        <li>
         <a href="user?@template=register"
            tal:condition="python:request.user.hasPermission('Create', 'user')"
            i18n:translate="">Register</a>
        </li>
        <li>
         <a href="user?@template=forgotten" i18n:translate="">Lost&nbsp;your&nbsp;login?</a>
        </li>
       </ul>
      </form>
     </li>
     <li tal:condition="python:request.user.username != 'anonymous'" class="submenu">
      <p class="label"><b tal:replace="request/user/username">username</b></p>
      <ul>
       <li>
        <a href="#" tal:attributes="href python:request.indexargs_url('bug', {
                                     '@sort': '-activity',
                                     '@group': 'priority',
                                     '@filter': 'status,assignee',
                                     '@columns': bug_columns,
                                     '@search_text': '',
                                     'status': bug_status_notclosed,
                                     'assignee': request.user.id,
                                     '@dispname': i18n.gettext('Bugs assigned to you'),
                                     '@startwith': 0})"
                    i18n:translate="">Bugs assigned to you</a>
       </li>
       <li>
        <a tal:attributes="href string:user${request/user/id}" i18n:translate="">Your Details</a>
       </li>
       <li>
        <a tal:attributes="href python:request.indexargs_url('', {'@action':'logout'})" 
           i18n:translate="">Logout</a>
       </li>
       <li class="" tal:condition="python:request.user.hasPermission('View', 'query')">
        <span i18n:translate=""><b>Your Queries</b> (<a class="nomargin" href="query?@template=edit">edit</a>)</span><br/>
        <ul tal:repeat="qs request/user/queries">
         <li>
          <a tal:attributes="href string:${qs/klass}?${qs/url}&@dispname=${qs/name}" tal:content="qs/name">link</a>
         </li>
        </ul>
       </li>
       <li class="" tal:condition="python:request.user.hasPermission('View', 'user')">
        <b i18n:translate="">Administration</b>
        <ul>
         <li tal:condition="python:request.user.hasPermission('Edit', None)">
          <a href="home?@template=classlist" i18n:translate="">Class List</a>
         </li>
         <li tal:condition="python:request.user.hasPermission('View', 'user')
                            or request.user.hasPermission('Edit', 'user')">
          <a href="user?@sort=username"  i18n:translate="">User List</a>
         </li>
         <li tal:condition="python:request.user.hasPermission('Create', 'user')">
          <a href="user?@template=item" i18n:translate="">Add User</a>
         </li>
         <li tal:condition="python:request.user.hasPermission('Edit', 'keyword')">
          <a href="keyword" i18n:translate="">Edit Keywords</a>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul> <!-- user -->
   </div> <!-- menu -->
  </div> <!-- navigation -->
  <div class="content">
   <h1 id="breadcrumb"><span metal:define-slot="body_title">body title</span></h1>
   <p tal:condition="options/error_message | nothing" class="error-message"
      tal:repeat="m options/error_message" tal:content="structure m" />
   <p tal:condition="options/ok_message | nothing" class="ok-message">
    <span tal:repeat="m options/ok_message" tal:content="structure string:$m <br/ > " />
    <a class="form-small" tal:attributes="href request/current_url" i18n:translate="">clear this message</a>
   </p>
   <tal:block metal:define-slot="content">Page content goes here</tal:block>
  </div> <!-- content -->
  <div class="footer">
<!-- Created: Wed Jan 14 11:55:38 EST 2009 -->
<!-- hhmts start -->
Last modified: Wed Jun  3 00:02:37 EDT 2009
<!-- hhmts end -->
  </div> <!-- footer -->
  <pre tal:condition="request/form/deissue | nothing" tal:content="request"></pre>
 </body>
</html>
</tal:block>

<!--
The following macros are intended to be used in search pages.

The invoking context must define a "name" variable which names the
property being searched.

See issue.search.html in the classic template for examples.
-->

<!-- creates a th and a label: -->
<th metal:define-macro="th_label"
    tal:define="required required | python:[]"
    tal:attributes="class python:(name in required) and 'required' or nothing">
  <label tal:attributes="for name" tal:content="label" i18n:translate="">text</label>
	<metal:x define-slot="behind_the_label" />
</th>

<td metal:define-macro="search_input">
  <input tal:attributes="value python:request.form.getvalue(name) or nothing;
                         name name;
                         id name"/>
</td>

<td metal:define-macro="search_date">
  <input tal:attributes="value python:request.form.getvalue(name) or nothing;
                         name name;
                         id name"/>
  <a class="classhelp"
	 tal:attributes="href python:'''javascript:help_window('task?@template=calendar&property=%s&form=itemSynopsis', 300, 200)'''%name">(cal)</a>
</td>

<td metal:define-macro="search_popup">
  <!--
    context needs to specify the popup "columns" as a comma-separated
    string (eg. "id,title" or "id,name,description") as well as name
  -->
  <input tal:attributes="value python:request.form.getvalue(name) or nothing;
                         name name;
                         id name"/>
  <span tal:replace="structure python:db.task.classhelp(columns,
                                      property=name)" />
</td>

<td metal:define-macro="search_select">
  <select tal:attributes="name name; id name"
          tal:define="value python:request.form.getvalue(name)">
    <option value="" i18n:translate="">don't care</option>
    <metal:slot define-slot="extra_options" />
    <option value="" i18n:translate="" disabled="disabled">------------</option>
    <option tal:repeat="s python:db[db_klass].list()"
            tal:attributes="value s/id; selected python:value == s.id"
            tal:content="python:s[db_content]"></option>
  </select>
</td>

<!-- like search_select, but translates the further values.
Could extend it (METAL 1.1 attribute "extend-macro")
-->
<td metal:define-macro="search_select_translated">
  <select tal:attributes="name name; id name"
          tal:define="value python:request.form.getvalue(name)">
    <option value="" i18n:translate="">don't care</option>
    <metal:slot define-slot="extra_options" />
    <option value="" i18n:translate="" disabled="disabled">------------</option>
    <option tal:repeat="s python:db[db_klass].list()"
            tal:attributes="value s/id; selected python:value == s.id"
						tal:content="python:s[db_content]"
						i18n:translate=""></option>
  </select>
</td>

<!-- currently, there is no convenient API to get a list of all roles -->
<td metal:define-macro="search_select_roles"
	  tal:define="onchange onchange | nothing">
  <select name="roles" id="roles" tal:attributes="onchange onchange">
    <option value="" i18n:translate="">don't care</option>
    <option value="" i18n:translate="" disabled="disabled">------------</option>
    <option value="User">User</option>
    <option value="Developer">Developer</option>
    <option value="Coordinator">Coordinator</option>
  </select>
</td>

<td metal:define-macro="search_multiselect">
  <input tal:attributes="value python:request.form.getvalue(name) or nothing;
                         name name;
                         id name"/>
  <span tal:replace="structure python:db[db_klass].classhelp(db_content,
                                        property=name, width='600')" />
</td>

<td metal:define-macro="search_checkboxes">
 <ul class="search-checkboxes"
     tal:define="value python:request.form.getvalue(name);
                 values python:value and value.split(',') or []">
 <li tal:repeat="s python:db[db_klass].list()">
  <input type="checkbox" tal:attributes="name name; id string:$name-${s/id};
    value s/id; checked python:s.id in values" />
  <label tal:attributes="for string:$name-${s/id}"
         tal:content="python:s[db_content]" />
 </li>
 <li metal:define-slot="no_value_item">
  <input type="checkbox" value="-1" tal:attributes="name name;
     id string:$name--1; checked python:value == '-1'" />
  <label tal:attributes="for string:$name--1" i18n:translate="">no value</label>
 </li>
 </ul>
</td>

<td metal:define-macro="column_input">
  <input type="checkbox" name="@columns"
         tal:attributes="value name;
                         checked python:name in cols"/>
</td>

<td metal:define-macro="sort_input">
  <input type="radio" name="@sort"
         tal:attributes="value name;
                         checked python:name == sort_on"/>
</td>

<td metal:define-macro="group_input">
  <input type="radio" name="@group"
         tal:attributes="value name;
                         checked python:name == group_on"/>
</td>

<!--
The following macros are intended for user editing.

The invoking context must define a "name" variable which names the
property being searched; the "edit_ok" variable tells whether the
current user is allowed to edit.

See user.item.html in the classic template for examples.
-->
<script metal:define-macro="user_utils" type="text/javascript" src="@@file/user_utils.js"></script>

<!-- src: value will be re-used for other input fields -->
<input metal:define-macro="user_src_input"
    type="text" tal:attributes="onblur python:edit_ok and 'split_name(this)';
    id name; name name; value value; readonly not:edit_ok"
    value="heinz.kunz"/>
<!-- normal: no re-using -->
<input metal:define-macro="user_normal_input" type="text"
    tal:attributes="id name; name name; value value; readonly not:edit_ok"
    value="heinz"/>
<!-- password: type; no initial value -->
    <input metal:define-macro="user_pw_input" type="password"
    tal:attributes="id name; name name; readonly not:edit_ok" value=""/>
    <input metal:define-macro="user_confirm_input" type="password"
    tal:attributes="id name; name string:@confirm@$name; readonly not:edit_ok" value=""/>


commit refs/heads/gsoc-2009
mark :620
author Stefan Seefeld <stefan@users.sourceforge.net> 1245204199 +0000
committer Stefan Seefeld <stefan@users.sourceforge.net> 1245204199 +0000
data 20
Fix validity issue.
from :618
property svn 4 4224
M 100644 :619 share/roundup/templates/devel/html/page.html

blob
mark :621
data 5436
<tal:block metal:use-macro="templates/help/macros/frame">
<tal:block tal:define="property request/form/property/value;
                  qs request/env/QUERY_STRING;
                  qs python:'&'.join([a for a in qs.split('&') if not a.startswith('@template=')]);
                  form request/form/form/value;
                  field request/form/property/value">
  <tal:block metal:fill-slot="more-javascript">
     <script language="Javascript" type="text/javascript" tal:content="structure string:<!--
      // this is the name of the field in the original form that we're working on
      form  = parent.opener.document.${request/form/form/value};
      callingform=form
      field  = '${request/form/property/value}';
      var listform = null
      function listPresent() { return document.frm_help.cb_listpresent.checked}
      function getListForm()
      {
        if (listPresent()) { return parent.list.document.forms.dummyform}
        else { return null}
      }

      function checkListForm()
      {
        // global listform
        if (listform != null)
        if (parent.list.document.dummyform) 
        {
          listform = parent.list.document.dummyform
          alert(listform)
        }
        var bol= listform != null
        alert('checkListForm: bol='+bol)
        return bol
      }
      //-->">
    </script>
    <script src="@@file/jquery.js" type="text/javascript"></script>
    <script src="@@file/search.js" type="text/javascript"></script>
  </tal:block>
  <tal:block metal:fill-slot="content">
    <div name="search">
      <form method="get" name="itemSynopsis" target="list"
            tal:attributes="action request/classname" 
            tal:define="property request/form/property/value;
                        cols python:request.columns or 'id username address realname roles'.split();
                        sort_on request/sort | nothing;
                        sort_desc python:sort_on and request.sort[0][0] == '-';
                        sort_on python:sort_on and request.sort[0][1] or 'lastname';
                        search_input templates/page/macros/search_input;
                        search_select templates/page/macros/search_select;
                        search_select_roles templates/page/macros/search_select_roles;
                        required python:[];
                        th_label templates/page/macros/th_label; ">
       <input type="hidden" name="@template" value="help-list">
       <input type="hidden" name="property" value="" tal:attributes="value property">
       <input type="hidden" name="form" value="" tal:attributes="value request/form/form/value">
       <table>
        <tr tal:define="name string:username; label string:Username:">
         <th metal:use-macro="th_label">Name</th> 
         <td metal:use-macro="search_input"><input type="text"></td>
        </tr>
        <tr tal:define="name string:phone; label string:Phone number">
         <th metal:use-macro="th_label">Phone</th>
         <td metal:use-macro="search_input"><input type="text"></td>
        </tr>
        <tr tal:define="name string:roles; label string:Roles:" >
         <th metal:use-macro="th_label">role</th>
         <td metal:use-macro="search_select_roles">
          <select>
           <option value="">jokester</option>
          </select>
         </td>
        </tr>
        <tr>
         <td>&nbsp;</td>
         <td>
          <input type="hidden" name="@action" value="search"/>
          <input type="submit" value="Search" i18n:attributes="value"/>
          <input type="reset"/>
          <input type="hidden" value="username,realname,phone,organisation,roles" name="properties"/>
          <input type="text" name="@pagesize" id="sp-pagesize" value="25" size="2"/>
          <label for="sp-pagesize" i18n:translate="">Pagesize</label>
         </td>
        </tr>
       </table>
      </form>
      <script type="text/javascript"><!-- focus2id('username'); //--></script>
    </div>
    <!-- for search results: help-list -->
    <div class="list"><p i18n:translate="">Please specify your search parameters!</p></div>
    <div class="submit" onload="parent.focus();" id="submit">
    <form name="frm_help"
          tal:define="batch request/batch;
                      props python:request.form['properties'].value.split(',')"
          class="help-submit"
          id="classhelp-controls">
    <div style="width:100%;text-align:left;margin-bottom:0.2em">
     <input type="text" name="text_preview" size="24" class="preview"
            onchange="f=getListForm();if(f){ reviseList_framed(f, this)};"/>
    </div>
    <input type=checkbox name="cb_listpresent" readonly="readonly" style="display:none"/>
    <input type="button" id="btn_cancel"
           value=" Cancel " onclick="parent.close();return false;"
           i18n:attributes="value" />
    <input type="reset" id="btn_reset"
           onclick="text_field.value=original_field;f=getListForm();if (f) {reviseList_framed(f, this)};return false"/>
    <input type="submit" id="btn_apply" class="apply"
           value=" Apply " onclick="callingform[field].value=text_field.value; parent.close();"
           i18n:attributes="value" />
   </form>
   <script type="text/javascript"><!--
var text_field = document.frm_help.text_preview;
original_field=form[field].value;
text_field.value=original_field;
//--></script>
  </div>
</tal:block>
</tal:block>
</tal:block>

commit refs/heads/gsoc-2009
mark :622
author Stefan Seefeld <stefan@users.sourceforge.net> 1245204254 +0000
committer Stefan Seefeld <stefan@users.sourceforge.net> 1245204254 +0000
data 22
Small validity fixes.
from :620
property svn 4 4225
M 100644 :621 share/roundup/templates/devel/html/user.help.html

blob
mark :623
data 13613

#
# TRACKER SCHEMA
#

# Class automatically gets these properties:
#   creation = Date()
#   activity = Date()
#   creator = Link('user')
#   actor = Link('user')


# This is the repository class, then you can see/edit repositories in pages like
# "http://tracker/url/svn_repo1"
svn_repo = Class(db, "svn_repo",
name=String(),
host=String(),
path=String(),
viewcvs_url=String())
svn_repo.setkey('name')

# Stores revision data, lets you see/edit revisions in pages like
# "http://tracker/url/svn_rev1". The svn_rev.item.html template is currently
# broken, but this works fine without it.
svn_rev = Class(db, "svn_rev",
repository=Link('svn_repo'),
revision=Number())



# Component
component = Class(db, 'component',
                  name=String(),
                  description=String(),
                  order=Number(),
                  assign_to=Link('user'))
component.setkey('name')

# Version
version = Class(db, 'version',
                name=String(),
                description=String(),
                order=Number())
version.setkey('name')

# Severity
severity = Class(db, 'severity',
                 name=String(),
                 description=String(),
                 order=Number())
severity.setkey('name')

# Priority
priority = Class(db, 'priority',
                 name=String(),
                 description=String(),
                 order=Number())
priority.setkey('name')

# Status
status = Class(db, "status",
               name=String(),
               description=String(),
               order=Number())
status.setkey("name")

# Resolution
resolution = Class(db, "resolution",
                   name=String(),
                   description=String(),
                   order=Number())
resolution.setkey('name')

# Keyword
keyword = Class(db, "keyword",
                name=String(),
                description=String())
keyword.setkey("name")
                

# User-defined saved searches
query = Class(db, "query",
              klass=String(),
              name=String(),
              url=String(),
              private_for=Link('user'))

# add any additional database schema configuration here

user = Class(db, "user",
             username=String(),
             password=Password(),
             address=String(),
             realname=String(),
             phone=String(),
             organisation=String(),
             alternate_addresses=String(),
             queries=Multilink('query'),
             roles=String(),     # comma-separated string of Role names
             timezone=String(),
             svn_name=String())

user.setkey("username")

# Permissions for revision creation and repository viewing.
for role in ('User',):
    db.security.addPermissionToRole(role, 'Create', 'svn_rev')
    db.security.addPermissionToRole(role, 'View', 'svn_repo')

# FileClass automatically gets this property in addition to the Class ones:
#   content = String()    [saved to disk in <tracker home>/db/files/]
#   type = String()       [MIME type of the content, default 'text/plain']
msg = FileClass(db, "msg",
                author=Link("user", do_journal='no'),
                recipients=Multilink("user", do_journal='no'),
                date=Date(),
                summary=String(),
                files=Multilink("file"),
                messageid=String(),
                inreplyto=String(),
                revision=Link("svn_rev"))

file = FileClass(db, "file",
                name=String(),
                description=String(indexme='yes'))

# Bug Type
bug_type = Class(db, 'bug_type',
                 name=String(),
                 description=String(),
                 order=Number())
bug_type.setkey('name')

# IssueClass automatically gets these properties in addition to the Class ones:
#   title = String()
#   messages = Multilink("msg")
#   files = Multilink("file")
#   nosy = Multilink("user")
#   superseder = Multilink("issue")
bug = IssueClass(db, "bug",
                 type=Link('bug_type'),
                 components=Multilink('component'),
                 versions=Multilink('version'),
                 severity=Link('severity'),
                 priority=Link('priority'),
                 dependencies=Multilink('bug'),
                 assignee=Link('user'),
                 status=Link('status'),
                 resolution=Link('resolution'),
                 superseder=Link('bug'),
                 keywords=Multilink('keyword'))

# Task Type
task_type = Class(db, 'task_type',
                 name=String(),
                 description=String(),
                 order=Number())
task_type.setkey('name')

# IssueClass automatically gets these properties in addition to the Class ones:
#   title = String()
#   messages = Multilink("msg")
#   files = Multilink("file")
#   nosy = Multilink("user")
#   superseder = Multilink("issue")
task = IssueClass(db, "task",
                  type=Link('task_type'),
                  components=Multilink('component'),
                  priority=Link('priority'),
                  dependencies=Multilink('task'),
                  assignee=Multilink('user'),
                  status=Link('status'),
                  resolution=Link('resolution'),
                  solves=Link('bug'))

milestone = IssueClass(db, "milestone",
                       bugs=Multilink("bug"),
                       tasks=Multilink("task"),
                       status=Link("status"),
                       release_date=String())

#
# TRACKER SECURITY SETTINGS
#
# See the configuration and customisation document for information
# about security setup.

db.security.addRole(name='Developer', description='A developer')
db.security.addRole(name='Coordinator', description='A coordinator')

#
# REGULAR USERS
#
# Give the regular users access to the web and email interface
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, 'Web Access')
    db.security.addPermissionToRole(r, 'Email Access')

##########################
# User permissions
##########################

for cl in ('severity', 'component',
           'version', 'priority', 'status', 'resolution',
           'bug_type', 'bug', 'task_type', 'task', 'milestone',
           'keyword', 'file', 'msg'):
    db.security.addPermissionToRole('User', 'View', cl)
    db.security.addPermissionToRole('Anonymous', 'View', cl)
    db.security.addPermissionToRole('User', 'Create', cl)
    

def may_edit_file(db, userid, itemid):
    return userid == db.file.get(itemid, "creator")

p = db.security.addPermission(name='Edit', klass='file', check=may_edit_file,
    description="User is allowed to remove their own files")
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Create', klass='bug',
                              properties=('title', 'bug_type',
                                          'components', 'versions',
                                          'severity',
                                          'messages', 'files', 'nosy'),
                              description='User can report and discuss bugs')
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Edit', klass='bug',
                              properties=('title', 'bug_type',
                                          'components', 'versions',
                                          'severity',
                                          'messages', 'files', 'nosy'),
                              description='User can report and discuss bugs')
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Create', klass='task',
                              properties=('title', 'task_type',
                                          'components',
                                          'messages', 'files', 'nosy'),
                              description='Developer can create and discuss tasks')
db.security.addPermissionToRole('Developer', p)

p = db.security.addPermission(name='Edit', klass='task',
                              properties=('title', 'task_type',
                                          'components',
                                          'messages', 'files', 'nosy'),
                              description='Developer can create and discuss tasks')
db.security.addPermissionToRole('Developer', p)

p = db.security.addPermission(name='Create', klass='milestone',
                              description='Coordinator can create and discuss milestones')
db.security.addPermissionToRole('Coordinator', p)

p = db.security.addPermission(name='Edit', klass='milestone',
                              description='Coordinator can create and discuss milestones')
db.security.addPermissionToRole('Coordinator', p)


##########################
# Developer permissions
##########################
for cl in ('bug_type', 'severity', 'component',
           'version', 'priority', 'status', 'resolution',
           'bug', 'file', 'msg', 'keyword'):
    db.security.addPermissionToRole('Developer', 'View', cl)

for cl in ('bug', 'file', 'msg', 'keyword'):
    db.security.addPermissionToRole('Developer', 'Edit', cl)
    db.security.addPermissionToRole('Developer', 'Create', cl)


##########################
# Coordinator permissions
##########################
for cl in ('bug_type', 'task_type', 'severity', 'component',
           'version', 'priority', 'status', 'resolution', 'bug', 'task', 'file', 'msg'):
    db.security.addPermissionToRole('Coordinator', 'View', cl)
    db.security.addPermissionToRole('Coordinator', 'Edit', cl)
    db.security.addPermissionToRole('Coordinator', 'Create', cl)

# May users view other user information? Comment these lines out
# if you don't want them to
db.security.addPermissionToRole('User', 'View', 'user')
db.security.addPermissionToRole('Developer', 'View', 'user')
db.security.addPermissionToRole('Coordinator', 'View', 'user')

# Allow Coordinator to edit any user, including their roles.
db.security.addPermissionToRole('Coordinator', 'Edit', 'user')
db.security.addPermissionToRole('Coordinator', 'Web Roles')

# Users should be able to edit their own details -- this permission is
# limited to only the situation where the Viewed or Edited item is their own.
def own_record(db, userid, itemid):
    '''Determine whether the userid matches the item being accessed.'''
    return userid == itemid
p = db.security.addPermission(name='View', klass='user', check=own_record,
    description="User is allowed to view their own user details")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Edit', klass='user', check=own_record,
    description="User is allowed to edit their own user details",
    properties=('username', 'password',
                'address', 'realname',
                'phone', 'organization',
                'alternate_addresses',
                'queries',
                'timezone')) # Note: 'roles' excluded - users should not be able to edit their own roles. 
for r in 'User', 'Developer':
    db.security.addPermissionToRole(r, p)

# Users should be able to edit and view their own queries. They should also
# be able to view any marked as not private. They should not be able to
# edit others' queries, even if they're not private
def view_query(db, userid, itemid):
    private_for = db.query.get(itemid, 'private_for')
    if not private_for: return True
    return userid == private_for
def edit_query(db, userid, itemid):
    return userid == db.query.get(itemid, 'creator')
p = db.security.addPermission(name='View', klass='query', check=view_query,
    description="User is allowed to view their own and public queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Edit', klass='query', check=edit_query,
    description="User is allowed to edit their queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Create', klass='query',
    description="User is allowed to create queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)


#
# ANONYMOUS USER PERMISSIONS
#
# Let anonymous users access the web interface. Note that almost all
# trackers will need this Permission. The only situation where it's not
# required is in a tracker that uses an HTTP Basic Authenticated front-end.
db.security.addPermissionToRole('Anonymous', 'Web Access')

# Let anonymous users access the email interface (note that this implies
# that they will be registered automatically, hence they will need the
# "Create" user Permission below)
# This is disabled by default to stop spam from auto-registering users on
# public trackers.
#db.security.addPermissionToRole('Anonymous', 'Email Access')

# Assign the appropriate permissions to the anonymous user's Anonymous
# Role. Choices here are:
# - Allow anonymous users to register
db.security.addPermissionToRole('Anonymous', 'Create', 'user')

# Allow anonymous users access to view issues (and the related, linked
# information).

for cl in 'bug', 'task', 'milestone', 'severity', 'status', 'resolution', 'msg', 'file':
    db.security.addPermissionToRole('Anonymous', 'View', cl)

# [OPTIONAL]
# Allow anonymous users access to create or edit "issue" items (and the
# related file and message items)
#for cl in 'issue', 'file', 'msg':
#   db.security.addPermissionToRole('Anonymous', 'Create', cl)
#   db.security.addPermissionToRole('Anonymous', 'Edit', cl)


# vim: set filetype=python sts=4 sw=4 et si :


commit refs/heads/gsoc-2009
mark :624
author Pygi <pygi@users.sourceforge.net> 1246301988 +0000
committer Pygi <pygi@users.sourceforge.net> 1246301988 +0000
data 51
Implemented schema changes for svn-roundup support
from :622
property svn 4 4234
M 100644 :623 share/roundup/templates/devel/schema.py

blob
mark :625
data 12141
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket


# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
except:
    logger.exception('Exception while importing Roundup and SVN')
    sys.exit(1)

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]
    revision = int(sys.argv[3])

    # get a handle on the revision in the repository
    repos = Repository(repos_dir, revision, pool)

    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        svn_repo_id = db.svn_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    messages = db.issue.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass = db.getclass(repos.klass)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class Repository:
    '''Hold roots and other information about the repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)

        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)

#
# 2005-05-16 - 1.2
# 
#   - Status wasn't being set by ID in local mode
#   - Wasn't catching errors in local changes, hence not cleaning up db
#     correctly
#   - svnauditor.py wasn't handling the fifth argument from notify-roundup.py
#   - viewcvs_url formatting wasn't quite right
#
# 2005-05-04 - 1.1
#   - Several fixes from  Ron Alford
#   - Don't change issue titles to "SVN commit message..."
# 
# 2005-04-26 - 1.0
#   - Initial version released
#

commit refs/heads/gsoc-2009
mark :626
author Pygi <pygi@users.sourceforge.net> 1246304657 +0000
committer Pygi <pygi@users.sourceforge.net> 1246304657 +0000
data 32
Import notify-roundup.py script
from :624
property svn 4 4235
M 100755 :625 scripts/notify-roundup.py

blob
mark :627
data 12139
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket


# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
except:
    logger.exception('Exception while importing Roundup and SVN')
    sys.exit(1)

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]
    revision = int(sys.argv[3])

    # get a handle on the revision in the repository
    repos = Repository(repos_dir, revision, pool)

    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        svn_repo_id = db.svn_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    messages = db.bug.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass = db.getclass(repos.klass)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class Repository:
    '''Hold roots and other information about the repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)

        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)

#
# 2005-05-16 - 1.2
# 
#   - Status wasn't being set by ID in local mode
#   - Wasn't catching errors in local changes, hence not cleaning up db
#     correctly
#   - svnauditor.py wasn't handling the fifth argument from notify-roundup.py
#   - viewcvs_url formatting wasn't quite right
#
# 2005-05-04 - 1.1
#   - Several fixes from  Ron Alford
#   - Don't change issue titles to "SVN commit message..."
# 
# 2005-04-26 - 1.0
#   - Initial version released
#

commit refs/heads/gsoc-2009
mark :628
author Pygi <pygi@users.sourceforge.net> 1246304709 +0000
committer Pygi <pygi@users.sourceforge.net> 1246304709 +0000
data 48
Fixed notify-roundup to work with devel tracker
from :626
property svn 4 4236
M 100755 :627 scripts/notify-roundup.py

blob
mark :629
data 12138
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket


# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
except:
    logger.exception('Exception while importing Roundup and SVN')
    sys.exit(1)

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]
    revision = int(sys.argv[3])

    # get a handle on the revision in the repository
    repos = Repository(repos_dir, revision, pool)

    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        svn_repo_id = db.svn_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class Repository:
    '''Hold roots and other information about the repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)

        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)

#
# 2005-05-16 - 1.2
# 
#   - Status wasn't being set by ID in local mode
#   - Wasn't catching errors in local changes, hence not cleaning up db
#     correctly
#   - svnauditor.py wasn't handling the fifth argument from notify-roundup.py
#   - viewcvs_url formatting wasn't quite right
#
# 2005-05-04 - 1.1
#   - Several fixes from  Ron Alford
#   - Don't change issue titles to "SVN commit message..."
# 
# 2005-04-26 - 1.0
#   - Initial version released
#

commit refs/heads/gsoc-2009
mark :630
author Pygi <pygi@users.sourceforge.net> 1246309197 +0000
committer Pygi <pygi@users.sourceforge.net> 1246309197 +0000
data 71
Blind attempt at fixing issue where we dont respect item-class support
from :628
property svn 4 4237
M 100755 :629 scripts/notify-roundup.py

commit refs/heads/gsoc-2009
mark :631
author Pygi <pygi@users.sourceforge.net> 1246532948 +0000
committer Pygi <pygi@users.sourceforge.net> 1246532948 +0000
data 52
Create notify-roundup directory for related scripts
from :630
property svn 4 4241

commit refs/heads/gsoc-2009
mark :632
author Pygi <pygi@users.sourceforge.net> 1246533309 +0000
committer Pygi <pygi@users.sourceforge.net> 1246533309 +0000
data 42
Move notify-roundup.py to appropriate dir
from :631
property svn 4 4242
R "scripts/notify-roundup.py" "scripts/notify-roundup/notify-roundup.py"

blob
mark :633
data 1377
; notify-roundup.py configuration file

[main]
; notify a local or emailed tracker -- 'email' or 'local'
;mode = email
mode = local

; change this to detect other issue types
; multiple issue classes are possible (use regular expression "either" syntax)
item-class = task|bug
; item-class = system
; item-class = dev|system|network

; only set this if socket.gethostname() doesn't return the host's name as
; registered with your tracker
; host = host.name.example

[local]
; if notifying a local tracker, configure this variable
tracker-home = /home/mario/Projects/mojtest/demo

[email]
; if notifying a tracker by email, configure these variables
smtp-host = smtp-host.example
tracker-address = issues@host.example
; email-domain is used in conjuntion with the address mappings below
default-domain = @host.example

[address mappings]
; map Subversion author names to email addresses that the tracker will
; recognise. The "email :: default-domain" var will be appended if the
; address doesn't specify a domain.
;richard = rjones
; richard = ni@spam.example
mario = roundup-admin1@localhost
admin = roundup-admin@localhost

; If no mapping is defined for a particular author, we either:
; 1. use the <Subversion author name>@<default-domain> address or,
; 2. if a "*" entry is defined under address mappings, then we use
;    that address as the from address.
;* = unknown


commit refs/heads/gsoc-2009
mark :634
author Pygi <pygi@users.sourceforge.net> 1246533349 +0000
committer Pygi <pygi@users.sourceforge.net> 1246533349 +0000
data 42
Added sample notify-roundup configuration
from :632
property svn 4 4243
M 100644 :633 scripts/notify-roundup/notify-roundup.ini

blob
mark :635
data 1301
; notify-roundup.py configuration file

[main]
; notify a local or emailed tracker -- 'email' or 'local'
;mode = email
mode = local

; change this to detect other issue types
; multiple issue classes are possible (use regular expression "either" syntax)
item-class = issue
; item-class = system
; item-class = dev|system|network

; only set this if socket.gethostname() doesn't return the host's name as
; registered with your tracker
; host = host.name.example

[local]
; if notifying a local tracker, configure this variable
tracker-home = /path/to/your/tracker-home

[email]
; if notifying a tracker by email, configure these variables
smtp-host = smtp-host.example
tracker-address = issues@host.example
; email-domain is used in conjuntion with the address mappings below
default-domain = @host.example

[address mappings]
; map Subversion author names to email addresses that the tracker will
; recognise. The "email :: default-domain" var will be appended if the
; address doesn't specify a domain.
richard = rjones
; richard = ni@spam.example

; If no mapping is defined for a particular author, we either:
; 1. use the <Subversion author name>@<default-domain> address or,
; 2. if a "*" entry is defined under address mappings, then we use
;    that address as the from address.
;* = unknown


commit refs/heads/gsoc-2009
mark :636
author Pygi <pygi@users.sourceforge.net> 1246533407 +0000
committer Pygi <pygi@users.sourceforge.net> 1246533407 +0000
data 63
Added sample notify-roundup configuration without my config :P
from :634
property svn 4 4244
M 100644 :635 scripts/notify-roundup/notify-roundup.ini

blob
mark :637
data 1299
; notify-roundup.py configuration file

[main]
; notify a local or emailed tracker -- 'email' or 'local'
;mode = email
mode = local

; change this to detect other issue types
; multiple issue classes are possible (use regular expression "either" syntax)
item-class = bug
; item-class = system
; item-class = dev|system|network

; only set this if socket.gethostname() doesn't return the host's name as
; registered with your tracker
; host = host.name.example

[local]
; if notifying a local tracker, configure this variable
tracker-home = /path/to/your/tracker-home

[email]
; if notifying a tracker by email, configure these variables
smtp-host = smtp-host.example
tracker-address = issues@host.example
; email-domain is used in conjuntion with the address mappings below
default-domain = @host.example

[address mappings]
; map Subversion author names to email addresses that the tracker will
; recognise. The "email :: default-domain" var will be appended if the
; address doesn't specify a domain.
richard = rjones
; richard = ni@spam.example

; If no mapping is defined for a particular author, we either:
; 1. use the <Subversion author name>@<default-domain> address or,
; 2. if a "*" entry is defined under address mappings, then we use
;    that address as the from address.
;* = unknown


commit refs/heads/gsoc-2009
mark :638
author Pygi <pygi@users.sourceforge.net> 1246533440 +0000
committer Pygi <pygi@users.sourceforge.net> 1246533440 +0000
data 42
Adapt configuration file to devel tracker
from :636
property svn 4 4245
M 100644 :637 scripts/notify-roundup/notify-roundup.ini

commit refs/heads/gsoc-2009
mark :639
author Pygi <pygi@users.sourceforge.net> 1246533591 +0000
committer Pygi <pygi@users.sourceforge.net> 1246533591 +0000
data 22
Created detectors dir
from :638
property svn 4 4246

blob
mark :640
data 2454
# Subversion integration auditor
# 
# Watches for messages formatted by the notify-roundup.py Subversion hook
# script, and parses the meta-data out of them, removing it from the
# message body in the process.
#
# Place this file in your tracker's "detectors" directory.
#
# See end of file for change history

import re, sets

import roundup.date

svn_msg = re.compile('^(revision|repos|host|date|summary)=(.*)$')

def parse_message(db, cl, nodeid, newvalues):
    '''Parse an incoming message for Subversion information.
    '''

    # collect up our meta-data from the message
    info = {}
    content = []
    for line in newvalues.get('content', '').splitlines():
        m = svn_msg.match(line)
        if not m:
            content.append(line)
            continue
        info[m.group(1)] = m.group(2).strip()

    # only continue if all five pieces of information are present
    if len(info) != 5:
        return

    # look up the repository id
    try:
        svn_repo_id = db.svn_repo.stringFind(path=info['repos'],
            host=info['host'])[0]
    except IndexError:
        #logger.error('no repository %s in tracker'%repos.repos_dir)
        return

    # create the subversion revision item
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id,
        revision=int(info['revision']))

    # minor bit of content cleaning - remove the single leading blank line
    if content and not content[0].strip():
        del content[0]

    # set the info on the message
    newvalues['content'] = '\n'.join(content)
    newvalues['date'] = roundup.date.Date(info['date'])
    newvalues['summary'] = info['summary']
    newvalues['revision'] = svn_rev_id

def undo_title(db, cl, nodeid, newvalues):
    '''Don't change the title of issues to "SVN commit message..."'''
    if newvalues.get('title', '').lower().startswith('svn commit message'):
        del newvalues['title']


def init(db):
    db.msg.audit('create', parse_message)
    db.issue.audit('set', undo_title)

#
# 2005-05-16 - 1.2
# 
#   - Status wasn't being set by ID in local mode
#   - Wasn't catching errors in local changes, hence not cleaning up db
#     correctly
#   - svnauditor.py wasn't handling the fifth argument from notify-roundup.py
#   - viewcvs_url formatting wasn't quite right
#
# 2005-05-04 - 1.1
#   - Several fixes from  Ron Alford
#   - Don't change issue titles to "SVN commit message..."
# 
# 2005-04-26 - 1.0
#   - Initial version released
#

commit refs/heads/gsoc-2009
mark :641
author Pygi <pygi@users.sourceforge.net> 1246533624 +0000
committer Pygi <pygi@users.sourceforge.net> 1246533624 +0000
data 16
Add svn auditor
from :639
property svn 4 4247
M 100644 :640 scripts/notify-roundup/detectors/svnauditor.py

commit refs/heads/gsoc-2009
mark :642
author Pygi <pygi@users.sourceforge.net> 1246533702 +0000
committer Pygi <pygi@users.sourceforge.net> 1246533702 +0000
data 28
Create extensions directory
from :641
property svn 4 4248

blob
mark :643
data 1603
# Subversion integration information fetcher
# 
# Extracts information about a specific revision from a local repository.
#
# Place this file in your tracker's "extensions" directory.

import sys, os, time
from svn import core, fs, delta, repos

def inner(pool, path, rev):
    repos_ptr = repos.svn_repos_open(path, pool)
    fs_ptr = repos.svn_repos_fs(repos_ptr)

    root = fs.revision_root(fs_ptr, rev, pool)
    base_rev = rev - 1

    # get all changes
    editor = repos.RevisionChangeCollector(fs_ptr, rev, pool)
    e_ptr, e_baton = delta.make_editor(editor, pool)
    repos.svn_repos_replay(root, e_ptr, e_baton, pool)

    changelist = editor.changes.items()
    changelist.sort()

    base_root = fs.revision_root(fs_ptr, base_rev, pool)

    l = []
    for filepath, change in changelist:
        d = {'path': filepath, 'info': ''}
        if change.path:
            if change.added:
                d['action'] = 'new'
            else:
                d['action'] = 'modify'
                differ = fs.FileDiff(base_root, change.path, root, filepath,
                    pool, '-L \t(original) -L \t(new) -u'.split(' '))
                d['info'] = differ.get_pipe().read()
        else:
            d['action'] = 'delete'
        l.append(d)
    return l


def getRevisionInfo(revision):
    #path = '/Users/richard/tmp/test_repo'
    #rev = 2
    return core.run_app(inner, str(revision['repository']['path']),
        int(revision['revision']))

def init(instance):
    instance.registerUtil('getRevisionInfo', getRevisionInfo)

if __name__ == '__main__':
    print getRevision(1)


commit refs/heads/gsoc-2009
mark :644
author Pygi <pygi@users.sourceforge.net> 1246533786 +0000
committer Pygi <pygi@users.sourceforge.net> 1246533786 +0000
data 56
Add revision_info.py that allows revisions info display
from :642
property svn 4 4249
M 100644 :643 scripts/notify-roundup/extensions/revision_info.py

commit refs/heads/gsoc-2009
mark :645
author Pygi <pygi@users.sourceforge.net> 1246533838 +0000
committer Pygi <pygi@users.sourceforge.net> 1246533838 +0000
data 23
Created html directory
from :644
property svn 4 4250

blob
mark :646
data 836
<tal:block metal:use-macro="templates/page/macros/icing">
<title metal:fill-slot="head_title">
 SVN Revision <span tal:replace="context/revision" />
</title>
<tal:block metal:fill-slot="body_title">
 SVN Revision <span tal:replace="context/revision" />
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="not:context/is_view_ok" i18n:translate="">You are not
    allowed to view this page.</p>

<div tal:condition="context/is_view_ok">

<table class="messages">
<tal:block repeat="file python:utils.getRevisionInfo(context)">
 <tr>
  <th tal:content="string: ${file/action} ${file/path}" />
 </tr>
 <tr tal:condition="file/info"><td><pre tal:content="file/info" /></td></tr>
</tal:block>
</table>

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</div>

</td>

</tal:block>

commit refs/heads/gsoc-2009
mark :647
author Pygi <pygi@users.sourceforge.net> 1246533871 +0000
committer Pygi <pygi@users.sourceforge.net> 1246533871 +0000
data 44
Add html template for showing revision info
from :645
property svn 4 4251
M 100644 :646 scripts/notify-roundup/html/svn_rev.item.html

blob
mark :648
data 2536
# Subversion integration auditor
# 
# Watches for messages formatted by the notify-roundup.py Subversion hook
# script, and parses the meta-data out of them, removing it from the
# message body in the process.
#
# Place this file in your tracker's "detectors" directory.
#
# See end of file for change history

import re, sets

import roundup.date

svn_msg = re.compile('^(revision|repos|host|date|summary)=(.*)$')

def parse_message(db, cl, nodeid, newvalues):
    '''Parse an incoming message for Subversion information.
    '''

    # collect up our meta-data from the message
    info = {}
    content = []
    for line in newvalues.get('content', '').splitlines():
        m = svn_msg.match(line)
        if not m:
            content.append(line)
            continue
        info[m.group(1)] = m.group(2).strip()

    # only continue if all five pieces of information are present
    if len(info) != 5:
        return

    # look up the repository id
    try:
        svn_repo_id = db.svn_repo.stringFind(path=info['repos'],
            host=info['host'])[0]
    except IndexError:
        #logger.error('no repository %s in tracker'%repos.repos_dir)
        return

    # create the subversion revision item
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id,
        revision=int(info['revision']))

    # minor bit of content cleaning - remove the single leading blank line
    if content and not content[0].strip():
        del content[0]

    # set the info on the message
    newvalues['content'] = '\n'.join(content)
    newvalues['date'] = roundup.date.Date(info['date'])
    newvalues['summary'] = info['summary']
    newvalues['revision'] = svn_rev_id

def undo_title(db, cl, nodeid, newvalues):
    '''Don't change the title of issues to "SVN commit message..."'''
    if newvalues.get('title', '').lower().startswith('svn commit message'):
        del newvalues['title']


def init(db):
    db.msg.audit('create', parse_message)
    repos.klass = cfg.get('main', 'item-class')
    klass = db.getclass(repos.klass)
    klass.audit('set', undo_title)

#
# 2005-05-16 - 1.2
# 
#   - Status wasn't being set by ID in local mode
#   - Wasn't catching errors in local changes, hence not cleaning up db
#     correctly
#   - svnauditor.py wasn't handling the fifth argument from notify-roundup.py
#   - viewcvs_url formatting wasn't quite right
#
# 2005-05-04 - 1.1
#   - Several fixes from  Ron Alford
#   - Don't change issue titles to "SVN commit message..."
# 
# 2005-04-26 - 1.0
#   - Initial version released
#

commit refs/heads/gsoc-2009
mark :649
author Pygi <pygi@users.sourceforge.net> 1246534198 +0000
committer Pygi <pygi@users.sourceforge.net> 1246534198 +0000
data 29
Attempt at fixing svnauditor
from :647
property svn 4 4252
M 100644 :648 scripts/notify-roundup/detectors/svnauditor.py

blob
mark :650
data 2595
# Subversion integration auditor
# 
# Watches for messages formatted by the notify-roundup.py Subversion hook
# script, and parses the meta-data out of them, removing it from the
# message body in the process.
#
# Place this file in your tracker's "detectors" directory.
#
# See end of file for change history

import re, sets

import roundup.date

import ConfigParser

svn_msg = re.compile('^(revision|repos|host|date|summary)=(.*)$')

def parse_message(db, cl, nodeid, newvalues):
    '''Parse an incoming message for Subversion information.
    '''

    # collect up our meta-data from the message
    info = {}
    content = []
    for line in newvalues.get('content', '').splitlines():
        m = svn_msg.match(line)
        if not m:
            content.append(line)
            continue
        info[m.group(1)] = m.group(2).strip()

    # only continue if all five pieces of information are present
    if len(info) != 5:
        return

    # look up the repository id
    try:
        svn_repo_id = db.svn_repo.stringFind(path=info['repos'],
            host=info['host'])[0]
    except IndexError:
        #logger.error('no repository %s in tracker'%repos.repos_dir)
        return

    # create the subversion revision item
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id,
        revision=int(info['revision']))

    # minor bit of content cleaning - remove the single leading blank line
    if content and not content[0].strip():
        del content[0]

    # set the info on the message
    newvalues['content'] = '\n'.join(content)
    newvalues['date'] = roundup.date.Date(info['date'])
    newvalues['summary'] = info['summary']
    newvalues['revision'] = svn_rev_id

def undo_title(db, cl, nodeid, newvalues):
    '''Don't change the title of issues to "SVN commit message..."'''
    if newvalues.get('title', '').lower().startswith('svn commit message'):
        del newvalues['title']


def init(db):
    db.msg.audit('create', parse_message)
    cfg = ConfigParser.ConfigParser()
    repos.klass = cfg.get('main', 'item-class')
    klass = db.getclass(repos.klass)
    klass.audit('set', undo_title)

#
# 2005-05-16 - 1.2
# 
#   - Status wasn't being set by ID in local mode
#   - Wasn't catching errors in local changes, hence not cleaning up db
#     correctly
#   - svnauditor.py wasn't handling the fifth argument from notify-roundup.py
#   - viewcvs_url formatting wasn't quite right
#
# 2005-05-04 - 1.1
#   - Several fixes from  Ron Alford
#   - Don't change issue titles to "SVN commit message..."
# 
# 2005-04-26 - 1.0
#   - Initial version released
#

commit refs/heads/gsoc-2009
mark :651
author Pygi <pygi@users.sourceforge.net> 1246534392 +0000
committer Pygi <pygi@users.sourceforge.net> 1246534392 +0000
data 38
Forgot to import ConfigParser, fix it
from :649
property svn 4 4253
M 100644 :650 scripts/notify-roundup/detectors/svnauditor.py

blob
mark :652
data 2659
# Subversion integration auditor
# 
# Watches for messages formatted by the notify-roundup.py Subversion hook
# script, and parses the meta-data out of them, removing it from the
# message body in the process.
#
# Place this file in your tracker's "detectors" directory.
#
# See end of file for change history

import re, sets

import roundup.date

import ConfigParser

svn_msg = re.compile('^(revision|repos|host|date|summary)=(.*)$')
ini_path = '/path/to/notify-roundup.ini'

def parse_message(db, cl, nodeid, newvalues):
    '''Parse an incoming message for Subversion information.
    '''

    # collect up our meta-data from the message
    info = {}
    content = []
    for line in newvalues.get('content', '').splitlines():
        m = svn_msg.match(line)
        if not m:
            content.append(line)
            continue
        info[m.group(1)] = m.group(2).strip()

    # only continue if all five pieces of information are present
    if len(info) != 5:
        return

    # look up the repository id
    try:
        svn_repo_id = db.svn_repo.stringFind(path=info['repos'],
            host=info['host'])[0]
    except IndexError:
        #logger.error('no repository %s in tracker'%repos.repos_dir)
        return

    # create the subversion revision item
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id,
        revision=int(info['revision']))

    # minor bit of content cleaning - remove the single leading blank line
    if content and not content[0].strip():
        del content[0]

    # set the info on the message
    newvalues['content'] = '\n'.join(content)
    newvalues['date'] = roundup.date.Date(info['date'])
    newvalues['summary'] = info['summary']
    newvalues['revision'] = svn_rev_id

def undo_title(db, cl, nodeid, newvalues):
    '''Don't change the title of issues to "SVN commit message..."'''
    if newvalues.get('title', '').lower().startswith('svn commit message'):
        del newvalues['title']


def init(db):
    db.msg.audit('create', parse_message)
    cfg = ConfigParser.ConfigParser()
    cfg.read(ini_path)
    fetch_klass = cfg.get('main', 'item-class')
    klass = db.getclass(fetch_klass)
    klass.audit('set', undo_title)

#
# 2005-05-16 - 1.2
# 
#   - Status wasn't being set by ID in local mode
#   - Wasn't catching errors in local changes, hence not cleaning up db
#     correctly
#   - svnauditor.py wasn't handling the fifth argument from notify-roundup.py
#   - viewcvs_url formatting wasn't quite right
#
# 2005-05-04 - 1.1
#   - Several fixes from  Ron Alford
#   - Don't change issue titles to "SVN commit message..."
# 
# 2005-04-26 - 1.0
#   - Initial version released
#

commit refs/heads/gsoc-2009
mark :653
author Pygi <pygi@users.sourceforge.net> 1246535343 +0000
committer Pygi <pygi@users.sourceforge.net> 1246535343 +0000
data 27
I think Ive finally got it
from :651
property svn 4 4254
M 100644 :652 scripts/notify-roundup/detectors/svnauditor.py

blob
mark :654
data 836
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title">
 SVN Revision <span tal:replace="context/revision" />
</title>
<tal:block metal:fill-slot="body_title">
 SVN Revision <span tal:replace="context/revision" />
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="not:context/is_view_ok" i18n:translate="">You are not
    allowed to view this page.</p>

<div tal:condition="context/is_view_ok">

<table class="messages">
<tal:block repeat="file python:utils.getRevisionInfo(context)">
 <tr>
  <th tal:content="string: ${file/action} ${file/path}" />
 </tr>
 <tr tal:condition="file/info"><td><pre tal:content="file/info" /></td></tr>
</tal:block>
</table>

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</div>

</td>

</tal:block>

commit refs/heads/gsoc-2009
mark :655
author Pygi <pygi@users.sourceforge.net> 1246537172 +0000
committer Pygi <pygi@users.sourceforge.net> 1246537172 +0000
data 31
Fix svn_rev.item html template
from :653
property svn 4 4255
M 100644 :654 scripts/notify-roundup/html/svn_rev.item.html

blob
mark :656
data 10961
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title">
<tal:block condition="context/id" i18n:translate=""
 >Bug <span tal:replace="context/id" i18n:name="id"
 />: <span tal:replace="context/title" i18n:name="title"
 /> - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
<tal:block condition="not:context/id" i18n:translate=""
 >New Bug report - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
</title>
<tal:block metal:fill-slot="body_title">
 <span tal:condition="python: not (context.id or context.is_edit_ok())"
  tal:omit-tag="python:1" i18n:translate="">New Bug</span>
 <span tal:condition="python: not context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">New Bug Editing</span>
 <span tal:condition="python: context.id and not context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Bug <tal:x
  replace="context/id" i18n:name="id" /></span>
 <span tal:condition="python: context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Bug<tal:x
  replace="context/id" i18n:name="id" /> Editing</span>
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<div tal:condition="context/is_view_ok">

<form method="POST" name="itemSynopsis"
      onSubmit="return submit_once()" enctype="multipart/form-data"
      tal:attributes="action context/designator">

<fieldset><legend>classification</legend>
<table class="form">
<tr>
 <th class="required" i18n:translate="">Title:</th>
 <td colspan="3" tal:condition="context/title/is_edit_ok"
     tal:content="structure python:context.title.field(size=40)">title</td>
 <td colspan="3" tal:condition="not:context/title/is_edit_ok">
  <span tal:content="structure context/title/plain"/>
  <input type="hidden" name="title" tal:attributes="value context/title">
 </td>
</tr>

<tr>
 <th class="required" i18n:translate="">
   <span tal:condition="context/type/is_edit_ok" 
         tal:replace="structure python:db.bug_type.classhelp('id,name,description',property='type',label='Type')" />
   <span tal:condition="not:context/type/is_edit_ok">Type</span>:
 </th>
 <td tal:content="structure context/type/menu">type</td>
 <th i18n:translate="">
   <span tal:condition="context/severity/is_edit_ok"
         tal:replace="structure python:db.severity.classhelp('id,name,description',property='severity',label='Severity')" />
   <span tal:condition="not:context/severity/is_edit_ok">Severity</span>:
 </th>
 <td tal:content="structure context/severity/menu">severity</td>
</tr>

<tr>
 <th i18n:translate="">
   <span tal:condition="context/components/is_edit_ok" 
         tal:replace="structure python:db.component.classhelp('id,name,description',property='components',label='Components')" />
   <span tal:condition="not:context/components/is_edit_ok">Components</span>:
 </th>
 <td tal:content="structure context/components/menu">components</td>
 <th i18n:translate="">
   <span tal:condition="context/versions/is_edit_ok" 
         tal:replace="structure python:db.version.classhelp('id,name,description',property='versions',label='Versions')" />
   <span tal:condition="not:context/versions/is_edit_ok">Versions</span>:
 </th>
 <td tal:content="structure context/versions/menu">versions</td>
</tr>
</table>
</fieldset>

<fieldset><legend>process</legend>
<table class="form">
<tr tal:condition="context/id">
 <th i18n:translate="">
   <span tal:condition="context/status/is_edit_ok" 
         tal:replace="structure python:db.status.classhelp('id,name,description',property='status', label='Status')" />
   <span tal:condition="not:context/status/is_edit_ok">Status</span>:
 </th>
 <td tal:content="structure context/status/menu">status</td>
 <th i18n:translate="">
   <span tal:condition="context/resolution/is_edit_ok" 
         tal:replace="structure python:db.resolution.classhelp('id,name,description',property='resolution', label='Resolution')" />
   <span tal:condition="not:context/resolution/is_edit_ok">Resolution</span>:
 </th>
 <td tal:content="structure context/resolution/menu">resolution</td>
</tr>

<tr tal:condition="context/id">
 <th>
  <tal:block i18n:translate="">Dependencies</tal:block>:
  <span tal:condition="context/dependencies/is_edit_ok"
        tal:replace="structure python:db.bug.classhelp('id,title', filter='status=0,1', property='dependencies')" />
 </th>
 <td>
  <span tal:replace="structure python:context.dependencies.field(showid=1,size=20)" />
  <span tal:condition="context/dependencies" tal:repeat="d python:context.dependencies.sorted('creation')">
   <br/>View: <a tal:attributes="href string:bug${d/id}" tal:content="d/id"></a>
  </span>
 </td>
 <th i18n:translate="">
  <tal:block i18n:translate="">Superseder</tal:block>:
  <span tal:condition="context/superseder/is_edit_ok"
        tal:replace="structure python:db.bug.classhelp('id,title', filter='status=0,1', property='superseder')" />
 </th>
 <td>
  <span tal:replace="structure python:context.superseder.field(showid=1, size=20)" />
 <span tal:condition="context/superseder">
<!--   <br><span i18n:translate="">View</span>:
     <a tal:repeat="sup context/superseder"
        tal:content="python:sup['id'] + ', '*(not repeat['sup'].end)"
        tal:attributes="href string:bug${sup/id}; title sup/title;"></a> -->
   <br><span i18n:translate="">View</span>:
     <a tal:content="context/superseder/id"
        tal:attributes="href string:bug${context/superseder/id}; title context/superseder/title;"></a> 
  </span> 
 </td>
 </tr>
 <tr>
 <th><tal:block i18n:translate="">Assigned To</tal:block>:</th>
 <td tal:content="structure context/assignee/menu">assignedto menu</td>
 <th><tal:block i18n:translate="">Nosy List</tal:block>:
  <span tal:condition="context/nosy/is_edit_ok"
        tal:replace="structure python:db.user.classhelp('username,realname,address', property='nosy')" />
 </th>
 <td>
  <span tal:replace="structure context/nosy/field" />
 </td>
</tr>
<tr>
 <th>
   <span tal:condition="context/priority/is_edit_ok"
         tal:replace="structure python:db.priority.classhelp('id,name,description',property='priority',label='Priority')" />
   <span tal:condition="not:context/priority/is_edit_ok">Priority</span>:
 </th>
 <td tal:content="structure context/priority/menu">priority</td>
 <th i18n:translate="">Keywords:</th>
 <td tal:content="structure python:context['keywords'].menu(height=5)">keywords</td>


</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">Comment</tal:block>:</th>
 <td colspan="3">
  <textarea tal:content="request/form/@note/value | default"
            name="@note" wrap="hard" rows="10" cols="60"></textarea>
 </td>
</tr>

<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">File</tal:block>:</th>
 <td colspan="3">
   <input type="hidden" name="@link@files" value="file-1">
   <input type="file" name="file-1@content" size="35">
 </td>
</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">File Description</tal:block>:</th>
 <td colspan=3><input type="edit" name="file-1@description" size="40"></td>
</tr>
</table>
</fieldset>
<table class="form">
<tr tal:condition="context/is_edit_ok">
 <td>
  &nbsp;
  <input type="hidden" name="@template" value="item">
  <input type="hidden" name="@required" value="title">
 </td>
 <td colspan=3>
  <span tal:replace="structure context/submit">submit button</span>
  <a tal:condition="context/id" tal:attributes="href context/copy_url"
   i18n:translate="">Make a copy</a>
 </td>
</tr>
</table>
</form>

<p tal:condition="context/id" i18n:translate="">
 Created on <b><tal:x replace="python:context.creation.pretty('%Y-%m-%d %H:%M')" i18n:name="creation" /></b>
 by <b><tal:x replace="context/creator" i18n:name="creator" /></b>,
 last changed <b><tal:x replace="python:context.activity.pretty('%Y-%m-%d %H:%M')" i18n:name="activity" /></b>
 by <b><tal:x replace="context/actor" i18n:name="actor" /></b>.
</p>

<table class="files" tal:condition="context/files">
 <tr><th colspan="5" class="header" i18n:translate="">Files</th></tr>
 <tr>
  <th i18n:translate="">File name</th>
  <th i18n:translate="">Uploaded</th>
  <th i18n:translate="">Description</th>
  <th i18n:translate="">Edit</th>
  <th i18n:translate="">Remove</th>
 </tr>
 <tr tal:repeat="file python:context.files.sorted('creation')">
  <td>
   <a tal:attributes="href file/download_url"
      tal:content="file/name">dld link</a>
  </td>
  <td>
   <span tal:content="file/creator">creator's name</span>,
   <span tal:content="python:file.creation.pretty('%Y-%m-%d %H:%M')">creation date</span>
  </td>
  <td tal:content="file/description" />
  <td><a tal:condition="file/is_edit_ok"
          tal:attributes="href string:file${file/id}">edit</a>
  </td>
  <td>
   <form style="padding:0" tal:condition="file/is_edit_ok"
         tal:attributes="action string:bug${context/id}">
    <input type="hidden" name="@remove@files" tal:attributes="value file/id">
    <input type="hidden" name="@action" value="edit">
    <input type="submit" value="remove" i18n:attributes="value">
   </form>
  </td>
 </tr>
</table>

<table class="messages" tal:condition="context/messages">
 <tr><th colspan="4" class="header" i18n:translate="">Messages</th></tr>
 <tal:block tal:repeat="msg context/messages">
  <tr>
   <th><a tal:attributes="href string:msg${msg/id}"
    i18n:translate="">msg<tal:x replace="msg/id" i18n:name="id" /></a></th>
   <th i18n:translate="">Author: <tal:x replace="python:msg.author.realname.plain()"
       i18n:name="author" /> (<tal:x replace="msg/author"/>)</th>
   <th i18n:translate="">Date: <tal:x replace="python:msg.date.pretty('%Y-%m-%d %H:%M')"
       i18n:name="date" /></th>
   <th>
    <form style="padding:0" tal:condition="msg/is_edit_ok"
          tal:attributes="action string:bug${context/id}">
     <input type="hidden" name="@remove@messages" tal:attributes="value msg/id">
     <input type="hidden" name="@action" value="edit">
     <input type="submit" value="remove" i18n:attributes="value">
    </form>
   </th>
  </tr>
  <tr>
  <tr tal:condition="msg/revision">
 <th tal:define="r msg/revision" colspan="4">
  <a tal:attributes="href string:svn_rev${r/id}"
     tal:content="python:'Subversion revision %d'%r['revision']" />
 </th>
 </tr>

   <td colspan="4" class="content">
    <pre tal:condition="python:msg.content.is_view_ok()"
         tal:content="structure python:utils.localReplace(msg.content.hyperlinked())">content</pre>
   </td>
  </tr>
 </tal:block>
</table>

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</div>

</td>

</tal:block>

blob
mark :657
data 6331
<tal:doc metal:use-macro="templates/page/macros/frame"
define="edit_ok context/is_edit_ok"
>
<title metal:fill-slot="head_title">
<tal:if condition="context/id" i18n:translate=""
 >User <span tal:replace="context/id" i18n:name="id"
 />: <span tal:replace="context/username" i18n:name="title"
 /> - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:if>
<tal:if condition="not:context/id" i18n:translate=""
 >New User - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:if>
</title>
<metal:slot fill-slot="more-javascript">
<script metal:use-macro="templates/page/macros/user_utils"></script>
<script type="text/javascript" src="@@file/help_controls.js"></script>
</metal:slot>
<tal:block metal:fill-slot="body_title"
  define="edit_ok context/is_edit_ok">
 <span tal:condition="python: not (context.id or edit_ok)"
  tal:omit-tag="python:1" i18n:translate="">New User</span>
 <span tal:condition="python: not context.id and edit_ok"
  tal:omit-tag="python:1" i18n:translate="">New User Editing</span>
 <span tal:condition="python: context.id and not edit_ok"
  tal:omit-tag="python:1" i18n:translate="">User<tal:x
  replace="context/id" i18n:name="id" /></span>
 <span tal:condition="python: context.id and edit_ok"
  tal:omit-tag="python:1" i18n:translate="">User<tal:x
  replace="context/id" i18n:name="id" /> Editing</span>
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<div tal:condition="context/is_view_ok">

<form method="POST"
      tal:define="required python:'username address'.split()"
      enctype="multipart/form-data"
      tal:attributes="action context/designator;
      onSubmit python:'return checkRequiredFields(\'%s\')'%'\', \''.join(required);
      ">
<table class="form" tal:define="
  th_label templates/page/macros/th_label;
  src_input templates/page/macros/user_src_input;
  normal_input templates/page/macros/user_normal_input;
  pw_input templates/page/macros/user_pw_input;
  confirm_input templates/page/macros/user_confirm_input;
  edit_ok context/is_edit_ok;
  ">
 <tr tal:define="name string:realname; label string:Name; value context/realname; edit_ok edit_ok">
  <th metal:use-macro="th_label">Name</th>
  <td><input name="realname" metal:use-macro="src_input"></td>
 </tr>
 <tr tal:define="name string:username; label string:Login Name; value context/username">
   <th metal:use-macro="th_label">Login Name</th>
   <td><input metal:use-macro="src_input"></td>
 </tr>
  <tal:if condition="edit_ok">
 <tr tal:define="name string:password; label string:Login Password">
  <th metal:use-macro="th_label">Login Password</th>
  <td><input metal:use-macro="pw_input" type="password"></td>
 </tr>
 <tr tal:define="name string:password; label string:Confirm Password">
  <th metal:use-macro="th_label">Confirm Password</th>
  <td><input metal:use-macro="confirm_input" type="password"></td>
 </tr>
  </tal:if>
 <tr>
 <th i18n:translate="">Subversion login</th>
 <td tal:content="structure context/svn_name/field">svn_name</td>
 </tr>
  <tal:if condition="python:request.user.hasPermission('Web Roles')">
 <tr tal:define="name string:roles; label string:Roles;">
  <th><label for="roles" i18n:translate="">Roles</label></th>
  <td tal:define="gips context/id">
    <tal:subif condition=gips define="value context/roles">
      <input metal:use-macro="normal_input">
    </tal:subif>
    <tal:subif condition="not:gips" define="value db/config/NEW_WEB_USER_ROLES">
      <input metal:use-macro="normal_input">
    </tal:subif>
   <tal:block i18n:translate="">(to give the user more than one role,
    enter a comma,separated,list)</tal:block>
  </td>
 </tr>
 </tal:if>

 <tr tal:define="name string:phone; label string:Phone; value context/phone">
  <th metal:use-macro="th_label">Phone</th>
  <td><input name="phone" metal:use-macro="normal_input"></td>
 </tr>

 <tr tal:define="name string:organisation; label string:Organisation; value context/organisation">
  <th metal:use-macro="th_label">Organisation</th>
  <td><input name="organisation" metal:use-macro="normal_input"></td>
 </tr>

 <tr tal:condition="python:edit_ok or context.timezone"
     tal:define="name string:timezone; label string:Timezone; value context/timezone">
  <th metal:use-macro="th_label">Timezone</th>
  <td><input tal:replace="structure python:
       utils.tzfield(context.timezone, 'timezone', db.config.DEFAULT_TIMEZONE)"/>
  </td>
 </tr>

 <tr tal:define="name string:address; label string:E-mail address; value context/address">
  <th metal:use-macro="th_label">E-mail address</th>
  <td tal:define="mailto python:context.address.field(id='address');
	  mklink python:mailto and not edit_ok">
      <a href="mailto:calvin@the-z.org"
		  tal:attributes="href string:mailto:$value"
		  tal:content="value"
          tal:condition="python:mklink">calvin@the-z.org</a>
      <tal:if condition=edit_ok>
      <input metal:use-macro="src_input" value="calvin@the-z.org">
      </tal:if>
      &nbsp;
  </td>
 </tr>

 <tr>
  <th><label for="alternate_addresses" i18n:translate="">Alternate E-mail addresses<br>One address per line</label></th>
  <td>
    <textarea rows=5 cols=40 tal:replace="structure context/alternate_addresses/multiline">nobody@nowhere.org
anybody@everywhere.net
(alternate_addresses)
    </textarea>
  </td>
 </tr>

 <tr tal:condition="edit_ok">
  <td>
   &nbsp;
   <input type="hidden" name="@template" value="item">
   <input type="hidden" name="@required" value="username,address"
          tal:attributes="value python:','.join(required)">
  </td>
  <td><input type="submit" value="save" tal:replace="structure context/submit"><!--submit button here-->
    <input type="reset">
  </td>
 </tr>
</table>
</form>

<tal:block tal:condition="not:context/id" i18n:translate="">
<table class="form">
<tr>
 <td>Note:&nbsp;</td>
 <th class="required">highlighted</th>
 <td>&nbsp;fields are required.</td>
</tr>
</table>
</tal:block>

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</div>

</td>

</tal:doc>

commit refs/heads/gsoc-2009
mark :658
author Pygi <pygi@users.sourceforge.net> 1246538668 +0000
committer Pygi <pygi@users.sourceforge.net> 1246538668 +0000
data 76
Modified user.item to allow Subversion login, and still working on bug.item
from :655
property svn 4 4256
M 100644 :656 scripts/notify-roundup/html/bug.item.html
M 100644 :657 scripts/notify-roundup/html/user.item.html

blob
mark :659
data 10955
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title">
<tal:block condition="context/id" i18n:translate=""
 >Bug <span tal:replace="context/id" i18n:name="id"
 />: <span tal:replace="context/title" i18n:name="title"
 /> - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
<tal:block condition="not:context/id" i18n:translate=""
 >New Bug report - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
</title>
<tal:block metal:fill-slot="body_title">
 <span tal:condition="python: not (context.id or context.is_edit_ok())"
  tal:omit-tag="python:1" i18n:translate="">New Bug</span>
 <span tal:condition="python: not context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">New Bug Editing</span>
 <span tal:condition="python: context.id and not context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Bug <tal:x
  replace="context/id" i18n:name="id" /></span>
 <span tal:condition="python: context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Bug<tal:x
  replace="context/id" i18n:name="id" /> Editing</span>
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<div tal:condition="context/is_view_ok">

<form method="POST" name="itemSynopsis"
      onSubmit="return submit_once()" enctype="multipart/form-data"
      tal:attributes="action context/designator">

<fieldset><legend>classification</legend>
<table class="form">
<tr>
 <th class="required" i18n:translate="">Title:</th>
 <td colspan="3" tal:condition="context/title/is_edit_ok"
     tal:content="structure python:context.title.field(size=40)">title</td>
 <td colspan="3" tal:condition="not:context/title/is_edit_ok">
  <span tal:content="structure context/title/plain"/>
  <input type="hidden" name="title" tal:attributes="value context/title">
 </td>
</tr>

<tr>
 <th class="required" i18n:translate="">
   <span tal:condition="context/type/is_edit_ok" 
         tal:replace="structure python:db.bug_type.classhelp('id,name,description',property='type',label='Type')" />
   <span tal:condition="not:context/type/is_edit_ok">Type</span>:
 </th>
 <td tal:content="structure context/type/menu">type</td>
 <th i18n:translate="">
   <span tal:condition="context/severity/is_edit_ok"
         tal:replace="structure python:db.severity.classhelp('id,name,description',property='severity',label='Severity')" />
   <span tal:condition="not:context/severity/is_edit_ok">Severity</span>:
 </th>
 <td tal:content="structure context/severity/menu">severity</td>
</tr>

<tr>
 <th i18n:translate="">
   <span tal:condition="context/components/is_edit_ok" 
         tal:replace="structure python:db.component.classhelp('id,name,description',property='components',label='Components')" />
   <span tal:condition="not:context/components/is_edit_ok">Components</span>:
 </th>
 <td tal:content="structure context/components/menu">components</td>
 <th i18n:translate="">
   <span tal:condition="context/versions/is_edit_ok" 
         tal:replace="structure python:db.version.classhelp('id,name,description',property='versions',label='Versions')" />
   <span tal:condition="not:context/versions/is_edit_ok">Versions</span>:
 </th>
 <td tal:content="structure context/versions/menu">versions</td>
</tr>
</table>
</fieldset>

<fieldset><legend>process</legend>
<table class="form">
<tr tal:condition="context/id">
 <th i18n:translate="">
   <span tal:condition="context/status/is_edit_ok" 
         tal:replace="structure python:db.status.classhelp('id,name,description',property='status', label='Status')" />
   <span tal:condition="not:context/status/is_edit_ok">Status</span>:
 </th>
 <td tal:content="structure context/status/menu">status</td>
 <th i18n:translate="">
   <span tal:condition="context/resolution/is_edit_ok" 
         tal:replace="structure python:db.resolution.classhelp('id,name,description',property='resolution', label='Resolution')" />
   <span tal:condition="not:context/resolution/is_edit_ok">Resolution</span>:
 </th>
 <td tal:content="structure context/resolution/menu">resolution</td>
</tr>

<tr tal:condition="context/id">
 <th>
  <tal:block i18n:translate="">Dependencies</tal:block>:
  <span tal:condition="context/dependencies/is_edit_ok"
        tal:replace="structure python:db.bug.classhelp('id,title', filter='status=0,1', property='dependencies')" />
 </th>
 <td>
  <span tal:replace="structure python:context.dependencies.field(showid=1,size=20)" />
  <span tal:condition="context/dependencies" tal:repeat="d python:context.dependencies.sorted('creation')">
   <br/>View: <a tal:attributes="href string:bug${d/id}" tal:content="d/id"></a>
  </span>
 </td>
 <th i18n:translate="">
  <tal:block i18n:translate="">Superseder</tal:block>:
  <span tal:condition="context/superseder/is_edit_ok"
        tal:replace="structure python:db.bug.classhelp('id,title', filter='status=0,1', property='superseder')" />
 </th>
 <td>
  <span tal:replace="structure python:context.superseder.field(showid=1, size=20)" />
 <span tal:condition="context/superseder">
<!--   <br><span i18n:translate="">View</span>:
     <a tal:repeat="sup context/superseder"
        tal:content="python:sup['id'] + ', '*(not repeat['sup'].end)"
        tal:attributes="href string:bug${sup/id}; title sup/title;"></a> -->
   <br><span i18n:translate="">View</span>:
     <a tal:content="context/superseder/id"
        tal:attributes="href string:bug${context/superseder/id}; title context/superseder/title;"></a> 
  </span> 
 </td>
 </tr>
 <tr>
 <th><tal:block i18n:translate="">Assigned To</tal:block>:</th>
 <td tal:content="structure context/assignee/menu">assignedto menu</td>
 <th><tal:block i18n:translate="">Nosy List</tal:block>:
  <span tal:condition="context/nosy/is_edit_ok"
        tal:replace="structure python:db.user.classhelp('username,realname,address', property='nosy')" />
 </th>
 <td>
  <span tal:replace="structure context/nosy/field" />
 </td>
</tr>
<tr>
 <th>
   <span tal:condition="context/priority/is_edit_ok"
         tal:replace="structure python:db.priority.classhelp('id,name,description',property='priority',label='Priority')" />
   <span tal:condition="not:context/priority/is_edit_ok">Priority</span>:
 </th>
 <td tal:content="structure context/priority/menu">priority</td>
 <th i18n:translate="">Keywords:</th>
 <td tal:content="structure python:context['keywords'].menu(height=5)">keywords</td>


</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">Comment</tal:block>:</th>
 <td colspan="3">
  <textarea tal:content="request/form/@note/value | default"
            name="@note" wrap="hard" rows="10" cols="60"></textarea>
 </td>
</tr>

<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">File</tal:block>:</th>
 <td colspan="3">
   <input type="hidden" name="@link@files" value="file-1">
   <input type="file" name="file-1@content" size="35">
 </td>
</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">File Description</tal:block>:</th>
 <td colspan=3><input type="edit" name="file-1@description" size="40"></td>
</tr>
</table>
</fieldset>
<table class="form">
<tr tal:condition="context/is_edit_ok">
 <td>
  &nbsp;
  <input type="hidden" name="@template" value="item">
  <input type="hidden" name="@required" value="title">
 </td>
 <td colspan=3>
  <span tal:replace="structure context/submit">submit button</span>
  <a tal:condition="context/id" tal:attributes="href context/copy_url"
   i18n:translate="">Make a copy</a>
 </td>
</tr>
</table>
</form>

<p tal:condition="context/id" i18n:translate="">
 Created on <b><tal:x replace="python:context.creation.pretty('%Y-%m-%d %H:%M')" i18n:name="creation" /></b>
 by <b><tal:x replace="context/creator" i18n:name="creator" /></b>,
 last changed <b><tal:x replace="python:context.activity.pretty('%Y-%m-%d %H:%M')" i18n:name="activity" /></b>
 by <b><tal:x replace="context/actor" i18n:name="actor" /></b>.
</p>

<table class="files" tal:condition="context/files">
 <tr><th colspan="5" class="header" i18n:translate="">Files</th></tr>
 <tr>
  <th i18n:translate="">File name</th>
  <th i18n:translate="">Uploaded</th>
  <th i18n:translate="">Description</th>
  <th i18n:translate="">Edit</th>
  <th i18n:translate="">Remove</th>
 </tr>
 <tr tal:repeat="file python:context.files.sorted('creation')">
  <td>
   <a tal:attributes="href file/download_url"
      tal:content="file/name">dld link</a>
  </td>
  <td>
   <span tal:content="file/creator">creator's name</span>,
   <span tal:content="python:file.creation.pretty('%Y-%m-%d %H:%M')">creation date</span>
  </td>
  <td tal:content="file/description" />
  <td><a tal:condition="file/is_edit_ok"
          tal:attributes="href string:file${file/id}">edit</a>
  </td>
  <td>
   <form style="padding:0" tal:condition="file/is_edit_ok"
         tal:attributes="action string:bug${context/id}">
    <input type="hidden" name="@remove@files" tal:attributes="value file/id">
    <input type="hidden" name="@action" value="edit">
    <input type="submit" value="remove" i18n:attributes="value">
   </form>
  </td>
 </tr>
</table>

<table class="messages" tal:condition="context/messages">
 <tr><th colspan="4" class="header" i18n:translate="">Messages</th></tr>
 <tal:block tal:repeat="msg context/messages">

  <tr>
   <th><a tal:attributes="href string:msg${msg/id}"
    i18n:translate="">msg<tal:x replace="msg/id" i18n:name="id" /></a></th>
   <th i18n:translate="">Author: <tal:x replace="python:msg.author.realname.plain()"
       i18n:name="author" /> (<tal:x replace="msg/author"/>)</th>
   <th i18n:translate="">Date: <tal:x replace="python:msg.date.pretty('%Y-%m-%d %H:%M')"
       i18n:name="date" /></th>
    <form style="padding:0" tal:condition="msg/is_edit_ok"
          tal:attributes="action string:bug${context/id}">
     <input type="hidden" name="@remove@messages" tal:attributes="value msg/id">
     <input type="hidden" name="@action" value="edit">
     <input type="submit" value="remove" i18n:attributes="value">
    </form>
  </tr>


   <tr tal:condition="msg/revision">
   <th tal:define="r msg/revision" colspan="4">
    <a tal:attributes="href string:svn_rev${r/id}"
       tal:content="string:Subversion revision ${r/revision}" />
   </th>
  </tr>
  
  <tr>

   <td colspan="4" class="content">
    <pre tal:condition="python:msg.content.is_view_ok()"
         tal:content="structure python:utils.localReplace(msg.content.hyperlinked())">content</pre>
   </td>
  </tr>
 </tal:block>
</table>

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</div>

</td>

</tal:block>

commit refs/heads/gsoc-2009
mark :660
author Pygi <pygi@users.sourceforge.net> 1246541310 +0000
committer Pygi <pygi@users.sourceforge.net> 1246541310 +0000
data 59
Fixed bug.item html template to work with subversion links
from :658
property svn 4 4257
M 100644 :659 scripts/notify-roundup/html/bug.item.html

commit refs/heads/gsoc-2009
mark :661
author Pygi <pygi@users.sourceforge.net> 1246544192 +0000
committer Pygi <pygi@users.sourceforge.net> 1246544192 +0000
data 39
Added doc directory for notify-roundup
from :660
property svn 4 4258

blob
mark :662
data 1637
Roundup devel tracker in love with subversion
=============================================

This document serves a tutorial on setting up a Roundup instance
with devel template featuring subversion integration. Several assumptions
are made in this tutorial:

1) You've checked out gsoc-2009 Roundup branch
2) You know how to setup subversion repository
3) You want to work with a local subversion repository

Let's follow the steps:

1) Setup subversion post-commit hook

a) Rename post-commit.tmpl to post-commit
b) Make sure its executable (chmod +x)
c) Add the following to it:

PYTHON=/usr/bin/python
NOTIFY=/path/to/notify-roundup.py[1]
CONFIG=/path/to/notify-roundup.ini[1]
PYTHONPATH=/path/to/roundup/instance "$PYTHON" "$NOTIFY" "$CONFIG" "$REPOS" "$REV"

[1] notify-roundup.py and notify-roundup.ini can be found in scripts/notify-roundup

2) Modify notify-roundup.ini

a) Set tracker home: tracker-home = /path/to/tracker-home
b) Set address mappings

3) Copy html templates from scripts/notify-roundup/html to share/roundup/templates/devel/html

4) Copy revision_info.py extension from scripts/notify-roundup/extensions to share/roundup/templates/devel/extensions

5) Now, now, this wasn't so hard :)

How-to format subversion commit message
=======================================

By default, notify-roundup handles bugs.
To change status of bug1, format your commit
message like this:

bug1 pending

Current limitations
===================

1) Notify-roundup can work only with one item-class
2) Notify-roundup can only modify Status

We are aware of the those limitations, and have plans to alleviate them in the future.

commit refs/heads/gsoc-2009
mark :663
author Pygi <pygi@users.sourceforge.net> 1246545609 +0000
committer Pygi <pygi@users.sourceforge.net> 1246545609 +0000
data 43
Check-in first revision of how-to document
from :661
property svn 4 4259
M 100644 :662 scripts/notify-roundup/doc/README

commit refs/heads/gsoc-2009
mark :664
author Pygi <pygi@users.sourceforge.net> 1246556736 +0000
committer Pygi <pygi@users.sourceforge.net> 1246556736 +0000
data 34
Added beta notify development dir
from :663
property svn 4 4260
M 100644 :652 scripts/beta-notify/detectors/svnauditor.py
M 100644 :662 scripts/beta-notify/doc/README
M 100644 :643 scripts/beta-notify/extensions/revision_info.py
M 100644 :659 scripts/beta-notify/html/bug.item.html
M 100644 :654 scripts/beta-notify/html/svn_rev.item.html
M 100644 :657 scripts/beta-notify/html/user.item.html
M 100644 :637 scripts/beta-notify/notify-roundup.ini
M 100755 :629 scripts/beta-notify/notify-roundup.py

blob
mark :665
data 1367
; notify-roundup.py configuration file

[main]
; notify a local or emailed tracker -- 'email' or 'local'
;mode = email
mode = local

; change this to detect other issue types
; multiple issue classes are possible (use regular expression "either" syntax)
item-class = bug
; item-class = system
; item-class = dev|system|network

; only set this if socket.gethostname() doesn't return the host's name as
; registered with your tracker
; host = host.name.example



[local]
; if notifying a local tracker, configure this variable
tracker-home = /path/to/your/tracker-home

[email]
; if notifying a tracker by email, configure these variables
smtp-host = smtp-host.example
tracker-address = issues@host.example
; email-domain is used in conjuntion with the address mappings below
default-domain = @host.example

[vcs]
; choose a VCS type -- 'svn' or 'hg'
;mode = hg
mode = svn

[address mappings]
; map Subversion author names to email addresses that the tracker will
; recognise. The "email :: default-domain" var will be appended if the
; address doesn't specify a domain.
richard = rjones
; richard = ni@spam.example

; If no mapping is defined for a particular author, we either:
; 1. use the <Subversion author name>@<default-domain> address or,
; 2. if a "*" entry is defined under address mappings, then we use
;    that address as the from address.
;* = unknown


commit refs/heads/gsoc-2009
mark :666
author Pygi <pygi@users.sourceforge.net> 1246556873 +0000
committer Pygi <pygi@users.sourceforge.net> 1246556873 +0000
data 42
Add vcs-abstraction in notify-roundup.ini
from :664
property svn 4 4261
M 100644 :665 scripts/beta-notify/notify-roundup.ini

blob
mark :667
data 1367
; notify-roundup.py configuration file

[main]
; notify a local or emailed tracker -- 'email' or 'local'
;mode = email
mode = local

; change this to detect other issue types
; multiple issue classes are possible (use regular expression "either" syntax)
item-class = bug
; item-class = system
; item-class = dev|system|network

; only set this if socket.gethostname() doesn't return the host's name as
; registered with your tracker
; host = host.name.example



[local]
; if notifying a local tracker, configure this variable
tracker-home = /path/to/your/tracker-home

[email]
; if notifying a tracker by email, configure these variables
smtp-host = smtp-host.example
tracker-address = issues@host.example
; email-domain is used in conjuntion with the address mappings below
default-domain = @host.example

[vcs]
; choose a VCS type -- 'svn' or 'hg'
;type = hg
type = svn

[address mappings]
; map Subversion author names to email addresses that the tracker will
; recognise. The "email :: default-domain" var will be appended if the
; address doesn't specify a domain.
richard = rjones
; richard = ni@spam.example

; If no mapping is defined for a particular author, we either:
; 1. use the <Subversion author name>@<default-domain> address or,
; 2. if a "*" entry is defined under address mappings, then we use
;    that address as the from address.
;* = unknown


blob
mark :668
data 12567
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket


# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
except:
    logger.exception('Exception while importing Roundup and SVN')
    sys.exit(1)

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]
    revision = int(sys.argv[3])
    
    vcs_type = cfg.get('vcs', 'type')
    
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        svn_repo_id = db.svn_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        pass
        
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)

        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)

#
# 2005-05-16 - 1.2
# 
#   - Status wasn't being set by ID in local mode
#   - Wasn't catching errors in local changes, hence not cleaning up db
#     correctly
#   - svnauditor.py wasn't handling the fifth argument from notify-roundup.py
#   - viewcvs_url formatting wasn't quite right
#
# 2005-05-04 - 1.1
#   - Several fixes from  Ron Alford
#   - Don't change issue titles to "SVN commit message..."
# 
# 2005-04-26 - 1.0
#   - Initial version released
#

commit refs/heads/gsoc-2009
mark :669
author Pygi <pygi@users.sourceforge.net> 1246557447 +0000
committer Pygi <pygi@users.sourceforge.net> 1246557447 +0000
data 28
Did some work on hg support
from :666
property svn 4 4262
M 100644 :667 scripts/beta-notify/notify-roundup.ini
M 100755 :668 scripts/beta-notify/notify-roundup.py

commit refs/heads/gsoc-2009b
mark :670
author Pygi <pygi@users.sourceforge.net> 1246557683 +0000
committer Pygi <pygi@users.sourceforge.net> 1246557683 +0000
data 43
Branched gsoc-2009 for some major rewrites
from :669
property svn 4 4263

commit refs/heads/gsoc-2009b
mark :671
author Pygi <pygi@users.sourceforge.net> 1246557732 +0000
committer Pygi <pygi@users.sourceforge.net> 1246557732 +0000
data 44
Removed old notify-roundup from beta branch
from :670
property svn 4 4264
D scripts/notify-roundup/detectors/svnauditor.py
D scripts/notify-roundup/doc/README
D scripts/notify-roundup/extensions/revision_info.py
D scripts/notify-roundup/html/bug.item.html
D scripts/notify-roundup/html/svn_rev.item.html
D scripts/notify-roundup/html/user.item.html
D scripts/notify-roundup/notify-roundup.ini
D scripts/notify-roundup/notify-roundup.py

commit refs/heads/gsoc-2009b
mark :672
author Pygi <pygi@users.sourceforge.net> 1246557766 +0000
committer Pygi <pygi@users.sourceforge.net> 1246557766 +0000
data 36
Moved beta-notify to notify-roundup
from :671
property svn 4 4265
R "scripts/beta-notify/detectors/svnauditor.py" "scripts/notify-roundup/detectors/svnauditor.py"
R "scripts/beta-notify/doc/README" "scripts/notify-roundup/doc/README"
R "scripts/beta-notify/extensions/revision_info.py" "scripts/notify-roundup/extensions/revision_info.py"
R "scripts/beta-notify/html/bug.item.html" "scripts/notify-roundup/html/bug.item.html"
R "scripts/beta-notify/html/svn_rev.item.html" "scripts/notify-roundup/html/svn_rev.item.html"
R "scripts/beta-notify/html/user.item.html" "scripts/notify-roundup/html/user.item.html"
R "scripts/beta-notify/notify-roundup.ini" "scripts/notify-roundup/notify-roundup.ini"
R "scripts/beta-notify/notify-roundup.py" "scripts/notify-roundup/notify-roundup.py"

blob
mark :673
data 13613

#
# TRACKER SCHEMA
#

# Class automatically gets these properties:
#   creation = Date()
#   activity = Date()
#   creator = Link('user')
#   actor = Link('user')


# This is the repository class, then you can see/edit repositories in pages like
# "http://tracker/url/vcs_repo1"
vcs_repo = Class(db, "vcs_repo",
name=String(),
host=String(),
path=String(),
webview_url=String())
vcs_repo.setkey('name')

# Stores revision data, lets you see/edit revisions in pages like
# "http://tracker/url/vcs_rev1". The vcs_rev.item.html template is currently
# broken, but this works fine without it.
vcs_rev = Class(db, "vcs_rev",
repository=Link('vcs_repo'),
revision=Number())



# Component
component = Class(db, 'component',
                  name=String(),
                  description=String(),
                  order=Number(),
                  assign_to=Link('user'))
component.setkey('name')

# Version
version = Class(db, 'version',
                name=String(),
                description=String(),
                order=Number())
version.setkey('name')

# Severity
severity = Class(db, 'severity',
                 name=String(),
                 description=String(),
                 order=Number())
severity.setkey('name')

# Priority
priority = Class(db, 'priority',
                 name=String(),
                 description=String(),
                 order=Number())
priority.setkey('name')

# Status
status = Class(db, "status",
               name=String(),
               description=String(),
               order=Number())
status.setkey("name")

# Resolution
resolution = Class(db, "resolution",
                   name=String(),
                   description=String(),
                   order=Number())
resolution.setkey('name')

# Keyword
keyword = Class(db, "keyword",
                name=String(),
                description=String())
keyword.setkey("name")
                

# User-defined saved searches
query = Class(db, "query",
              klass=String(),
              name=String(),
              url=String(),
              private_for=Link('user'))

# add any additional database schema configuration here

user = Class(db, "user",
             username=String(),
             password=Password(),
             address=String(),
             realname=String(),
             phone=String(),
             organisation=String(),
             alternate_addresses=String(),
             queries=Multilink('query'),
             roles=String(),     # comma-separated string of Role names
             timezone=String(),
             vcs_name=String())

user.setkey("username")

# Permissions for revision creation and repository viewing.
for role in ('User',):
    db.security.addPermissionToRole(role, 'Create', 'vcs_rev')
    db.security.addPermissionToRole(role, 'View', 'vcs_repo')

# FileClass automatically gets this property in addition to the Class ones:
#   content = String()    [saved to disk in <tracker home>/db/files/]
#   type = String()       [MIME type of the content, default 'text/plain']
msg = FileClass(db, "msg",
                author=Link("user", do_journal='no'),
                recipients=Multilink("user", do_journal='no'),
                date=Date(),
                summary=String(),
                files=Multilink("file"),
                messageid=String(),
                inreplyto=String(),
                revision=Link("vcs_rev"))

file = FileClass(db, "file",
                name=String(),
                description=String(indexme='yes'))

# Bug Type
bug_type = Class(db, 'bug_type',
                 name=String(),
                 description=String(),
                 order=Number())
bug_type.setkey('name')

# IssueClass automatically gets these properties in addition to the Class ones:
#   title = String()
#   messages = Multilink("msg")
#   files = Multilink("file")
#   nosy = Multilink("user")
#   superseder = Multilink("issue")
bug = IssueClass(db, "bug",
                 type=Link('bug_type'),
                 components=Multilink('component'),
                 versions=Multilink('version'),
                 severity=Link('severity'),
                 priority=Link('priority'),
                 dependencies=Multilink('bug'),
                 assignee=Link('user'),
                 status=Link('status'),
                 resolution=Link('resolution'),
                 superseder=Link('bug'),
                 keywords=Multilink('keyword'))

# Task Type
task_type = Class(db, 'task_type',
                 name=String(),
                 description=String(),
                 order=Number())
task_type.setkey('name')

# IssueClass automatically gets these properties in addition to the Class ones:
#   title = String()
#   messages = Multilink("msg")
#   files = Multilink("file")
#   nosy = Multilink("user")
#   superseder = Multilink("issue")
task = IssueClass(db, "task",
                  type=Link('task_type'),
                  components=Multilink('component'),
                  priority=Link('priority'),
                  dependencies=Multilink('task'),
                  assignee=Multilink('user'),
                  status=Link('status'),
                  resolution=Link('resolution'),
                  solves=Link('bug'))

milestone = IssueClass(db, "milestone",
                       bugs=Multilink("bug"),
                       tasks=Multilink("task"),
                       status=Link("status"),
                       release_date=String())

#
# TRACKER SECURITY SETTINGS
#
# See the configuration and customisation document for information
# about security setup.

db.security.addRole(name='Developer', description='A developer')
db.security.addRole(name='Coordinator', description='A coordinator')

#
# REGULAR USERS
#
# Give the regular users access to the web and email interface
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, 'Web Access')
    db.security.addPermissionToRole(r, 'Email Access')

##########################
# User permissions
##########################

for cl in ('severity', 'component',
           'version', 'priority', 'status', 'resolution',
           'bug_type', 'bug', 'task_type', 'task', 'milestone',
           'keyword', 'file', 'msg'):
    db.security.addPermissionToRole('User', 'View', cl)
    db.security.addPermissionToRole('Anonymous', 'View', cl)
    db.security.addPermissionToRole('User', 'Create', cl)
    

def may_edit_file(db, userid, itemid):
    return userid == db.file.get(itemid, "creator")

p = db.security.addPermission(name='Edit', klass='file', check=may_edit_file,
    description="User is allowed to remove their own files")
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Create', klass='bug',
                              properties=('title', 'bug_type',
                                          'components', 'versions',
                                          'severity',
                                          'messages', 'files', 'nosy'),
                              description='User can report and discuss bugs')
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Edit', klass='bug',
                              properties=('title', 'bug_type',
                                          'components', 'versions',
                                          'severity',
                                          'messages', 'files', 'nosy'),
                              description='User can report and discuss bugs')
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Create', klass='task',
                              properties=('title', 'task_type',
                                          'components',
                                          'messages', 'files', 'nosy'),
                              description='Developer can create and discuss tasks')
db.security.addPermissionToRole('Developer', p)

p = db.security.addPermission(name='Edit', klass='task',
                              properties=('title', 'task_type',
                                          'components',
                                          'messages', 'files', 'nosy'),
                              description='Developer can create and discuss tasks')
db.security.addPermissionToRole('Developer', p)

p = db.security.addPermission(name='Create', klass='milestone',
                              description='Coordinator can create and discuss milestones')
db.security.addPermissionToRole('Coordinator', p)

p = db.security.addPermission(name='Edit', klass='milestone',
                              description='Coordinator can create and discuss milestones')
db.security.addPermissionToRole('Coordinator', p)


##########################
# Developer permissions
##########################
for cl in ('bug_type', 'severity', 'component',
           'version', 'priority', 'status', 'resolution',
           'bug', 'file', 'msg', 'keyword'):
    db.security.addPermissionToRole('Developer', 'View', cl)

for cl in ('bug', 'file', 'msg', 'keyword'):
    db.security.addPermissionToRole('Developer', 'Edit', cl)
    db.security.addPermissionToRole('Developer', 'Create', cl)


##########################
# Coordinator permissions
##########################
for cl in ('bug_type', 'task_type', 'severity', 'component',
           'version', 'priority', 'status', 'resolution', 'bug', 'task', 'file', 'msg'):
    db.security.addPermissionToRole('Coordinator', 'View', cl)
    db.security.addPermissionToRole('Coordinator', 'Edit', cl)
    db.security.addPermissionToRole('Coordinator', 'Create', cl)

# May users view other user information? Comment these lines out
# if you don't want them to
db.security.addPermissionToRole('User', 'View', 'user')
db.security.addPermissionToRole('Developer', 'View', 'user')
db.security.addPermissionToRole('Coordinator', 'View', 'user')

# Allow Coordinator to edit any user, including their roles.
db.security.addPermissionToRole('Coordinator', 'Edit', 'user')
db.security.addPermissionToRole('Coordinator', 'Web Roles')

# Users should be able to edit their own details -- this permission is
# limited to only the situation where the Viewed or Edited item is their own.
def own_record(db, userid, itemid):
    '''Determine whether the userid matches the item being accessed.'''
    return userid == itemid
p = db.security.addPermission(name='View', klass='user', check=own_record,
    description="User is allowed to view their own user details")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Edit', klass='user', check=own_record,
    description="User is allowed to edit their own user details",
    properties=('username', 'password',
                'address', 'realname',
                'phone', 'organization',
                'alternate_addresses',
                'queries',
                'timezone')) # Note: 'roles' excluded - users should not be able to edit their own roles. 
for r in 'User', 'Developer':
    db.security.addPermissionToRole(r, p)

# Users should be able to edit and view their own queries. They should also
# be able to view any marked as not private. They should not be able to
# edit others' queries, even if they're not private
def view_query(db, userid, itemid):
    private_for = db.query.get(itemid, 'private_for')
    if not private_for: return True
    return userid == private_for
def edit_query(db, userid, itemid):
    return userid == db.query.get(itemid, 'creator')
p = db.security.addPermission(name='View', klass='query', check=view_query,
    description="User is allowed to view their own and public queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Edit', klass='query', check=edit_query,
    description="User is allowed to edit their queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Create', klass='query',
    description="User is allowed to create queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)


#
# ANONYMOUS USER PERMISSIONS
#
# Let anonymous users access the web interface. Note that almost all
# trackers will need this Permission. The only situation where it's not
# required is in a tracker that uses an HTTP Basic Authenticated front-end.
db.security.addPermissionToRole('Anonymous', 'Web Access')

# Let anonymous users access the email interface (note that this implies
# that they will be registered automatically, hence they will need the
# "Create" user Permission below)
# This is disabled by default to stop spam from auto-registering users on
# public trackers.
#db.security.addPermissionToRole('Anonymous', 'Email Access')

# Assign the appropriate permissions to the anonymous user's Anonymous
# Role. Choices here are:
# - Allow anonymous users to register
db.security.addPermissionToRole('Anonymous', 'Create', 'user')

# Allow anonymous users access to view issues (and the related, linked
# information).

for cl in 'bug', 'task', 'milestone', 'severity', 'status', 'resolution', 'msg', 'file':
    db.security.addPermissionToRole('Anonymous', 'View', cl)

# [OPTIONAL]
# Allow anonymous users access to create or edit "issue" items (and the
# related file and message items)
#for cl in 'issue', 'file', 'msg':
#   db.security.addPermissionToRole('Anonymous', 'Create', cl)
#   db.security.addPermissionToRole('Anonymous', 'Edit', cl)


# vim: set filetype=python sts=4 sw=4 et si :


commit refs/heads/gsoc-2009b
mark :674
author Pygi <pygi@users.sourceforge.net> 1246558072 +0000
committer Pygi <pygi@users.sourceforge.net> 1246558072 +0000
data 34
Changed schema to be vcs agnostic
from :672
property svn 4 4266
M 100644 :673 share/roundup/templates/devel/schema.py

commit refs/heads/gsoc-2009b
mark :675
author Pygi <pygi@users.sourceforge.net> 1246558198 +0000
committer Pygi <pygi@users.sourceforge.net> 1246558198 +0000
data 22
Renamed html template
from :674
property svn 4 4267
R "scripts/notify-roundup/html/svn_rev.item.html" "scripts/notify-roundup/html/vcs_rev.item.html"

blob
mark :676
data 2200
# Subversion integration auditor
# 
# Watches for messages formatted by the notify-roundup.py Subversion hook
# script, and parses the meta-data out of them, removing it from the
# message body in the process.
#
# Place this file in your tracker's "detectors" directory.
#
# See end of file for change history

import re, sets

import roundup.date

import ConfigParser

svn_msg = re.compile('^(revision|repos|host|date|summary)=(.*)$')
ini_path = '/path/to/notify-roundup.ini'

def parse_message(db, cl, nodeid, newvalues):
    '''Parse an incoming message for Subversion information.
    '''

    # collect up our meta-data from the message
    info = {}
    content = []
    for line in newvalues.get('content', '').splitlines():
        m = svn_msg.match(line)
        if not m:
            content.append(line)
            continue
        info[m.group(1)] = m.group(2).strip()

    # only continue if all five pieces of information are present
    if len(info) != 5:
        return

    # look up the repository id
    try:
        svn_repo_id = db.svn_repo.stringFind(path=info['repos'],
            host=info['host'])[0]
    except IndexError:
        #logger.error('no repository %s in tracker'%repos.repos_dir)
        return

    # create the subversion revision item
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id,
        revision=int(info['revision']))

    # minor bit of content cleaning - remove the single leading blank line
    if content and not content[0].strip():
        del content[0]

    # set the info on the message
    newvalues['content'] = '\n'.join(content)
    newvalues['date'] = roundup.date.Date(info['date'])
    newvalues['summary'] = info['summary']
    newvalues['revision'] = svn_rev_id

def undo_title(db, cl, nodeid, newvalues):
    '''Don't change the title of issues to "SVN commit message..."'''
    if newvalues.get('title', '').lower().startswith('svn commit message'):
        del newvalues['title']


def init(db):
    db.msg.audit('create', parse_message)
    cfg = ConfigParser.ConfigParser()
    cfg.read(ini_path)
    fetch_klass = cfg.get('main', 'item-class')
    klass = db.getclass(fetch_klass)
    klass.audit('set', undo_title)



commit refs/heads/gsoc-2009b
mark :677
author Pygi <pygi@users.sourceforge.net> 1246558325 +0000
committer Pygi <pygi@users.sourceforge.net> 1246558325 +0000
data 46
Removed for-me useless comments in svnauditor
from :675
property svn 4 4268
M 100644 :676 scripts/notify-roundup/detectors/svnauditor.py

blob
mark :678
data 2216
# Subversion integration auditor
# 
# Watches for messages formatted by the notify-roundup.py Subversion hook
# script, and parses the meta-data out of them, removing it from the
# message body in the process.
#
# Place this file in your tracker's "detectors" directory.
#
# See end of file for change history

import re, sets

import roundup.date

import ConfigParser

vcs_msg = re.compile('^(revision|repos|host|date|summary)=(.*)$')
ini_path = '/path/to/notify-roundup.ini'

def parse_message(db, cl, nodeid, newvalues):
    '''Parse an incoming message for VCS (Subversion right now) information.
    '''

    # collect up our meta-data from the message
    info = {}
    content = []
    for line in newvalues.get('content', '').splitlines():
        m = vcs_msg.match(line)
        if not m:
            content.append(line)
            continue
        info[m.group(1)] = m.group(2).strip()

    # only continue if all five pieces of information are present
    if len(info) != 5:
        return

    # look up the repository id
    try:
        vcs_repo_id = db.vcs_repo.stringFind(path=info['repos'],
            host=info['host'])[0]
    except IndexError:
        #logger.error('no repository %s in tracker'%repos.repos_dir)
        return

    # create the subversion revision item
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id,
        revision=int(info['revision']))

    # minor bit of content cleaning - remove the single leading blank line
    if content and not content[0].strip():
        del content[0]

    # set the info on the message
    newvalues['content'] = '\n'.join(content)
    newvalues['date'] = roundup.date.Date(info['date'])
    newvalues['summary'] = info['summary']
    newvalues['revision'] = vcs_rev_id

def undo_title(db, cl, nodeid, newvalues):
    '''Don't change the title of issues to "vcs commit message..."'''
    if newvalues.get('title', '').lower().startswith('vcs commit message'):
        del newvalues['title']


def init(db):
    db.msg.audit('create', parse_message)
    cfg = ConfigParser.ConfigParser()
    cfg.read(ini_path)
    fetch_klass = cfg.get('main', 'item-class')
    klass = db.getclass(fetch_klass)
    klass.audit('set', undo_title)



commit refs/heads/gsoc-2009b
mark :679
author Pygi <pygi@users.sourceforge.net> 1246558439 +0000
committer Pygi <pygi@users.sourceforge.net> 1246558439 +0000
data 35
Port svnauditor to be vcs-agnostic
from :677
property svn 4 4269
M 100644 :678 scripts/notify-roundup/detectors/svnauditor.py

commit refs/heads/gsoc-2009b
mark :680
author Pygi <pygi@users.sourceforge.net> 1246558546 +0000
committer Pygi <pygi@users.sourceforge.net> 1246558546 +0000
data 18
Rename svnauditor
from :679
property svn 4 4270
R "scripts/notify-roundup/detectors/svnauditor.py" "scripts/notify-roundup/detectors/vcsauditor.py"

blob
mark :681
data 10948
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title">
<tal:block condition="context/id" i18n:translate=""
 >Bug <span tal:replace="context/id" i18n:name="id"
 />: <span tal:replace="context/title" i18n:name="title"
 /> - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
<tal:block condition="not:context/id" i18n:translate=""
 >New Bug report - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
</title>
<tal:block metal:fill-slot="body_title">
 <span tal:condition="python: not (context.id or context.is_edit_ok())"
  tal:omit-tag="python:1" i18n:translate="">New Bug</span>
 <span tal:condition="python: not context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">New Bug Editing</span>
 <span tal:condition="python: context.id and not context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Bug <tal:x
  replace="context/id" i18n:name="id" /></span>
 <span tal:condition="python: context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Bug<tal:x
  replace="context/id" i18n:name="id" /> Editing</span>
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<div tal:condition="context/is_view_ok">

<form method="POST" name="itemSynopsis"
      onSubmit="return submit_once()" enctype="multipart/form-data"
      tal:attributes="action context/designator">

<fieldset><legend>classification</legend>
<table class="form">
<tr>
 <th class="required" i18n:translate="">Title:</th>
 <td colspan="3" tal:condition="context/title/is_edit_ok"
     tal:content="structure python:context.title.field(size=40)">title</td>
 <td colspan="3" tal:condition="not:context/title/is_edit_ok">
  <span tal:content="structure context/title/plain"/>
  <input type="hidden" name="title" tal:attributes="value context/title">
 </td>
</tr>

<tr>
 <th class="required" i18n:translate="">
   <span tal:condition="context/type/is_edit_ok" 
         tal:replace="structure python:db.bug_type.classhelp('id,name,description',property='type',label='Type')" />
   <span tal:condition="not:context/type/is_edit_ok">Type</span>:
 </th>
 <td tal:content="structure context/type/menu">type</td>
 <th i18n:translate="">
   <span tal:condition="context/severity/is_edit_ok"
         tal:replace="structure python:db.severity.classhelp('id,name,description',property='severity',label='Severity')" />
   <span tal:condition="not:context/severity/is_edit_ok">Severity</span>:
 </th>
 <td tal:content="structure context/severity/menu">severity</td>
</tr>

<tr>
 <th i18n:translate="">
   <span tal:condition="context/components/is_edit_ok" 
         tal:replace="structure python:db.component.classhelp('id,name,description',property='components',label='Components')" />
   <span tal:condition="not:context/components/is_edit_ok">Components</span>:
 </th>
 <td tal:content="structure context/components/menu">components</td>
 <th i18n:translate="">
   <span tal:condition="context/versions/is_edit_ok" 
         tal:replace="structure python:db.version.classhelp('id,name,description',property='versions',label='Versions')" />
   <span tal:condition="not:context/versions/is_edit_ok">Versions</span>:
 </th>
 <td tal:content="structure context/versions/menu">versions</td>
</tr>
</table>
</fieldset>

<fieldset><legend>process</legend>
<table class="form">
<tr tal:condition="context/id">
 <th i18n:translate="">
   <span tal:condition="context/status/is_edit_ok" 
         tal:replace="structure python:db.status.classhelp('id,name,description',property='status', label='Status')" />
   <span tal:condition="not:context/status/is_edit_ok">Status</span>:
 </th>
 <td tal:content="structure context/status/menu">status</td>
 <th i18n:translate="">
   <span tal:condition="context/resolution/is_edit_ok" 
         tal:replace="structure python:db.resolution.classhelp('id,name,description',property='resolution', label='Resolution')" />
   <span tal:condition="not:context/resolution/is_edit_ok">Resolution</span>:
 </th>
 <td tal:content="structure context/resolution/menu">resolution</td>
</tr>

<tr tal:condition="context/id">
 <th>
  <tal:block i18n:translate="">Dependencies</tal:block>:
  <span tal:condition="context/dependencies/is_edit_ok"
        tal:replace="structure python:db.bug.classhelp('id,title', filter='status=0,1', property='dependencies')" />
 </th>
 <td>
  <span tal:replace="structure python:context.dependencies.field(showid=1,size=20)" />
  <span tal:condition="context/dependencies" tal:repeat="d python:context.dependencies.sorted('creation')">
   <br/>View: <a tal:attributes="href string:bug${d/id}" tal:content="d/id"></a>
  </span>
 </td>
 <th i18n:translate="">
  <tal:block i18n:translate="">Superseder</tal:block>:
  <span tal:condition="context/superseder/is_edit_ok"
        tal:replace="structure python:db.bug.classhelp('id,title', filter='status=0,1', property='superseder')" />
 </th>
 <td>
  <span tal:replace="structure python:context.superseder.field(showid=1, size=20)" />
 <span tal:condition="context/superseder">
<!--   <br><span i18n:translate="">View</span>:
     <a tal:repeat="sup context/superseder"
        tal:content="python:sup['id'] + ', '*(not repeat['sup'].end)"
        tal:attributes="href string:bug${sup/id}; title sup/title;"></a> -->
   <br><span i18n:translate="">View</span>:
     <a tal:content="context/superseder/id"
        tal:attributes="href string:bug${context/superseder/id}; title context/superseder/title;"></a> 
  </span> 
 </td>
 </tr>
 <tr>
 <th><tal:block i18n:translate="">Assigned To</tal:block>:</th>
 <td tal:content="structure context/assignee/menu">assignedto menu</td>
 <th><tal:block i18n:translate="">Nosy List</tal:block>:
  <span tal:condition="context/nosy/is_edit_ok"
        tal:replace="structure python:db.user.classhelp('username,realname,address', property='nosy')" />
 </th>
 <td>
  <span tal:replace="structure context/nosy/field" />
 </td>
</tr>
<tr>
 <th>
   <span tal:condition="context/priority/is_edit_ok"
         tal:replace="structure python:db.priority.classhelp('id,name,description',property='priority',label='Priority')" />
   <span tal:condition="not:context/priority/is_edit_ok">Priority</span>:
 </th>
 <td tal:content="structure context/priority/menu">priority</td>
 <th i18n:translate="">Keywords:</th>
 <td tal:content="structure python:context['keywords'].menu(height=5)">keywords</td>


</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">Comment</tal:block>:</th>
 <td colspan="3">
  <textarea tal:content="request/form/@note/value | default"
            name="@note" wrap="hard" rows="10" cols="60"></textarea>
 </td>
</tr>

<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">File</tal:block>:</th>
 <td colspan="3">
   <input type="hidden" name="@link@files" value="file-1">
   <input type="file" name="file-1@content" size="35">
 </td>
</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">File Description</tal:block>:</th>
 <td colspan=3><input type="edit" name="file-1@description" size="40"></td>
</tr>
</table>
</fieldset>
<table class="form">
<tr tal:condition="context/is_edit_ok">
 <td>
  &nbsp;
  <input type="hidden" name="@template" value="item">
  <input type="hidden" name="@required" value="title">
 </td>
 <td colspan=3>
  <span tal:replace="structure context/submit">submit button</span>
  <a tal:condition="context/id" tal:attributes="href context/copy_url"
   i18n:translate="">Make a copy</a>
 </td>
</tr>
</table>
</form>

<p tal:condition="context/id" i18n:translate="">
 Created on <b><tal:x replace="python:context.creation.pretty('%Y-%m-%d %H:%M')" i18n:name="creation" /></b>
 by <b><tal:x replace="context/creator" i18n:name="creator" /></b>,
 last changed <b><tal:x replace="python:context.activity.pretty('%Y-%m-%d %H:%M')" i18n:name="activity" /></b>
 by <b><tal:x replace="context/actor" i18n:name="actor" /></b>.
</p>

<table class="files" tal:condition="context/files">
 <tr><th colspan="5" class="header" i18n:translate="">Files</th></tr>
 <tr>
  <th i18n:translate="">File name</th>
  <th i18n:translate="">Uploaded</th>
  <th i18n:translate="">Description</th>
  <th i18n:translate="">Edit</th>
  <th i18n:translate="">Remove</th>
 </tr>
 <tr tal:repeat="file python:context.files.sorted('creation')">
  <td>
   <a tal:attributes="href file/download_url"
      tal:content="file/name">dld link</a>
  </td>
  <td>
   <span tal:content="file/creator">creator's name</span>,
   <span tal:content="python:file.creation.pretty('%Y-%m-%d %H:%M')">creation date</span>
  </td>
  <td tal:content="file/description" />
  <td><a tal:condition="file/is_edit_ok"
          tal:attributes="href string:file${file/id}">edit</a>
  </td>
  <td>
   <form style="padding:0" tal:condition="file/is_edit_ok"
         tal:attributes="action string:bug${context/id}">
    <input type="hidden" name="@remove@files" tal:attributes="value file/id">
    <input type="hidden" name="@action" value="edit">
    <input type="submit" value="remove" i18n:attributes="value">
   </form>
  </td>
 </tr>
</table>

<table class="messages" tal:condition="context/messages">
 <tr><th colspan="4" class="header" i18n:translate="">Messages</th></tr>
 <tal:block tal:repeat="msg context/messages">

  <tr>
   <th><a tal:attributes="href string:msg${msg/id}"
    i18n:translate="">msg<tal:x replace="msg/id" i18n:name="id" /></a></th>
   <th i18n:translate="">Author: <tal:x replace="python:msg.author.realname.plain()"
       i18n:name="author" /> (<tal:x replace="msg/author"/>)</th>
   <th i18n:translate="">Date: <tal:x replace="python:msg.date.pretty('%Y-%m-%d %H:%M')"
       i18n:name="date" /></th>
    <form style="padding:0" tal:condition="msg/is_edit_ok"
          tal:attributes="action string:bug${context/id}">
     <input type="hidden" name="@remove@messages" tal:attributes="value msg/id">
     <input type="hidden" name="@action" value="edit">
     <input type="submit" value="remove" i18n:attributes="value">
    </form>
  </tr>


   <tr tal:condition="msg/revision">
   <th tal:define="r msg/revision" colspan="4">
    <a tal:attributes="href string:vcs_rev${r/id}"
       tal:content="string:VCS revision ${r/revision}" />
   </th>
  </tr>
  
  <tr>

   <td colspan="4" class="content">
    <pre tal:condition="python:msg.content.is_view_ok()"
         tal:content="structure python:utils.localReplace(msg.content.hyperlinked())">content</pre>
   </td>
  </tr>
 </tal:block>
</table>

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</div>

</td>

</tal:block>

commit refs/heads/gsoc-2009b
mark :682
author Pygi <pygi@users.sourceforge.net> 1246558723 +0000
committer Pygi <pygi@users.sourceforge.net> 1246558723 +0000
data 40
Ported bug.item.html to be VCS agnostic
from :680
property svn 4 4271
M 100644 :681 scripts/notify-roundup/html/bug.item.html

blob
mark :683
data 13290
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import subprocess

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]
    revision = int(sys.argv[3])
    
    vcs_type = cfg.get('vcs', 'type')
    
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        svn_repo_id = db.svn_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = subprocess.call('hg log ' + self.repos_dir + ' --rev ' + self.rev + ' | grep user' , shell=True)
        authors_split = authors.calls.split(':')
        logger.debug('Author is:', authors_split(1))
    

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = subprocess.call("/usr/bin/hg log " + self.repos_dir + " --rev=tip" + " | grep summary") or ''
        logger.debug('Log parsed:', log)
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :684
author Pygi <pygi@users.sourceforge.net> 1246978581 +0000
committer Pygi <pygi@users.sourceforge.net> 1246978581 +0000
data 17
Did some hg work
from :682
property svn 4 4273
M 100755 :683 scripts/notify-roundup/notify-roundup.py

blob
mark :685
data 13519
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import subprocess

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        rev_type = sys.argv[3].split(':')
        revision = rev_type(1)
        logger.debug(revision)
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        svn_repo_id = db.svn_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = subprocess.call('hg log ' + self.repos_dir + ' --rev ' + self.rev + ' | grep user' , shell=True)
        authors_split = authors.calls.split(':')
        logger.debug('Author is:', authors_split(1))
    

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = subprocess.call("/usr/bin/hg log " + self.repos_dir + " --rev=tip" + " | grep summary") or ''
        logger.debug('Log parsed:', log)
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :686
author Pygi <pygi@users.sourceforge.net> 1246978888 +0000
committer Pygi <pygi@users.sourceforge.net> 1246978888 +0000
data 18
Trying some fixes
from :684
property svn 4 4274
M 100755 :685 scripts/notify-roundup/notify-roundup.py

blob
mark :687
data 13519
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import subprocess

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        rev_type = sys.argv[3].split(':')
        revision = rev_type[1]
        logger.debug(revision)
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        svn_repo_id = db.svn_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = subprocess.call('hg log ' + self.repos_dir + ' --rev ' + self.rev + ' | grep user' , shell=True)
        authors_split = authors.calls.split(':')
        logger.debug('Author is:', authors_split[1])
    

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = subprocess.call("/usr/bin/hg log " + self.repos_dir + " --rev=tip" + " | grep summary") or ''
        logger.debug('Log parsed:', log)
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :688
author Pygi <pygi@users.sourceforge.net> 1246978981 +0000
committer Pygi <pygi@users.sourceforge.net> 1246978981 +0000
data 30
Trying some fixes - and again
from :686
property svn 4 4275
M 100755 :687 scripts/notify-roundup/notify-roundup.py

blob
mark :689
data 13519
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import subprocess

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        rev_type = sys.argv[3].split(':')
        revision = rev_type[1]
        logger.debug(revision)
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        svn_repo_id = db.svn_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = subprocess.call('hg log ' + self.repos_dir + ' --rev ' + self.rev + ' | grep user' , shell=True)
        authors_split = authors_calls.split(':')
        logger.debug('Author is:', authors_split[1])
    

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = subprocess.call("/usr/bin/hg log " + self.repos_dir + " --rev=tip" + " | grep summary") or ''
        logger.debug('Log parsed:', log)
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :690
author Pygi <pygi@users.sourceforge.net> 1246979050 +0000
committer Pygi <pygi@users.sourceforge.net> 1246979050 +0000
data 13
Fixed a typo
from :688
property svn 4 4276
M 100755 :689 scripts/notify-roundup/notify-roundup.py

blob
mark :691
data 13517
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import subprocess

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        rev_type = sys.argv[3].split(':')
        revision = rev_type[1]
        logger.debug(revision)
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        svn_repo_id = db.svn_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    svn_rev_id = db.svn_rev.create(repository=svn_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = subprocess.call('hg log ' + self.repos_dir + ' --rev ' + self.rev + ' | grep user' , shell=True)
        #authors_split = authors_calls.split(':')
        logger.debug('Author is:', authors_calls)
    

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = subprocess.call("/usr/bin/hg log " + self.repos_dir + " --rev=tip" + " | grep summary") or ''
        logger.debug('Log parsed:', log)
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :692
author Pygi <pygi@users.sourceforge.net> 1246979128 +0000
committer Pygi <pygi@users.sourceforge.net> 1246979128 +0000
data 22
Fixed a typo again...
from :690
property svn 4 4277
M 100755 :691 scripts/notify-roundup/notify-roundup.py

blob
mark :693
data 13471
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import subprocess

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        rev_type = sys.argv[3].split(':')
        revision = rev_type[1]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        svn_repo_id = db.svn_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = subprocess.call('hg log ' + self.repos_dir + ' --rev=tip | grep user' , shell=True)
        #authors_split = authors_calls.split(':')
        logger.debug('Author is:', authors_calls)
    

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = subprocess.call('hg log ' + self.repos_dir + ' --rev=tip | grep summary', shell=True) or ''
        logger.debug('Log parsed:', log)
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :694
author Pygi <pygi@users.sourceforge.net> 1246979796 +0000
committer Pygi <pygi@users.sourceforge.net> 1246979796 +0000
data 40
some more porting to vcs agnostic stuff
from :692
property svn 4 4278
M 100755 :693 scripts/notify-roundup/notify-roundup.py

blob
mark :695
data 13469
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import subprocess

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    logger.debug('VCS TYPE:', vcs_type)
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revision = sys.argv[3]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        svn_repo_id = db.svn_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = subprocess.call('hg log ' + self.repos_dir + ' --rev=tip | grep user' , shell=True)
        #authors_split = authors_calls.split(':')
        logger.debug('Author is:', authors_calls)
    

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = subprocess.call('hg log ' + self.repos_dir + ' --rev=tip | grep summary', shell=True) or ''
        logger.debug('Log parsed:', log)
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :696
author Pygi <pygi@users.sourceforge.net> 1246980311 +0000
committer Pygi <pygi@users.sourceforge.net> 1246980311 +0000
data 17
Does it work now
from :694
property svn 4 4279
M 100755 :695 scripts/notify-roundup/notify-roundup.py

blob
mark :697
data 13458
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revision = sys.argv[3]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        svn_repo_id = db.svn_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        self.author = authors_split[1].lstrip()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :698
author Pygi <pygi@users.sourceforge.net> 1246982979 +0000
committer Pygi <pygi@users.sourceforge.net> 1246982979 +0000
data 20
More work more work
from :696
property svn 4 4280
M 100755 :697 scripts/notify-roundup/notify-roundup.py

blob
mark :699
data 13458
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revision = sys.argv[3]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(svn_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        self.author = authors_split[1].lstrip()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :700
author Pygi <pygi@users.sourceforge.net> 1246983236 +0000
committer Pygi <pygi@users.sourceforge.net> 1246983236 +0000
data 20
More work more work
from :698
property svn 4 4281
M 100755 :699 scripts/notify-roundup/notify-roundup.py

blob
mark :701
data 13458
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revision = sys.argv[3]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        self.author = authors_split[1].lstrip()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :702
author Pygi <pygi@users.sourceforge.net> 1246983416 +0000
committer Pygi <pygi@users.sourceforge.net> 1246983416 +0000
data 20
More work more work
from :700
property svn 4 4282
M 100755 :701 scripts/notify-roundup/notify-roundup.py

blob
mark :703
data 13483
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revision = sys.argv[3]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            #raise Failed, 'no Roundup user matching %s'%repos.author
    #username = db.user.get(userid, 'username')
    username = "admin"
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        self.author = authors_split[1].lstrip()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :704
author Pygi <pygi@users.sourceforge.net> 1246983524 +0000
committer Pygi <pygi@users.sourceforge.net> 1246983524 +0000
data 15
temporary hack
from :702
property svn 4 4283
M 100755 :703 scripts/notify-roundup/notify-roundup.py

blob
mark :705
data 13484
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revision = sys.argv[3]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        #except KeyError:
            #raise Failed, 'no Roundup user matching %s'%repos.author
    #username = db.user.get(userid, 'username')
    username = "admin"
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        self.author = authors_split[1].lstrip()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :706
author Pygi <pygi@users.sourceforge.net> 1246983572 +0000
committer Pygi <pygi@users.sourceforge.net> 1246983572 +0000
data 15
temporary hack
from :704
property svn 4 4284
M 100755 :705 scripts/notify-roundup/notify-roundup.py

blob
mark :707
data 13494
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revision = sys.argv[3]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    '''
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
        userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    '''
    username = "admin"
    #db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=svn_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        self.author = authors_split[1].lstrip()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :708
author Pygi <pygi@users.sourceforge.net> 1246983711 +0000
committer Pygi <pygi@users.sourceforge.net> 1246983711 +0000
data 15
temporary hack
from :706
property svn 4 4285
M 100755 :707 scripts/notify-roundup/notify-roundup.py

blob
mark :709
data 13494
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revision = sys.argv[3]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    '''
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
        userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    '''
    username = "admin"
    #db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=vcs_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        self.author = authors_split[1].lstrip()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :710
author Pygi <pygi@users.sourceforge.net> 1246983998 +0000
committer Pygi <pygi@users.sourceforge.net> 1246983998 +0000
data 15
forgot to port
from :708
property svn 4 4286
M 100755 :709 scripts/notify-roundup/notify-roundup.py

blob
mark :711
data 13590
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revision = sys.argv[3]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    '''
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
        userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    '''
    username = "admin"
    #db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=vcs_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        self.author = authors_split[1].lstrip()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :712
author Pygi <pygi@users.sourceforge.net> 1246984088 +0000
committer Pygi <pygi@users.sourceforge.net> 1246984088 +0000
data 15
forgot to port
from :710
property svn 4 4287
M 100755 :711 scripts/notify-roundup/notify-roundup.py

blob
mark :713
data 13695
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revision = sys.argv[3]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    '''
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
        userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    '''
    username = "admin"
    #db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'svn_rev'):
        raise Unauthorised, "Can't create items of class 'svn_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=vcs_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        self.author = authors_split[1].lstrip()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :714
author Pygi <pygi@users.sourceforge.net> 1246984120 +0000
committer Pygi <pygi@users.sourceforge.net> 1246984120 +0000
data 4
heh
from :712
property svn 4 4288
M 100755 :713 scripts/notify-roundup/notify-roundup.py

blob
mark :715
data 13707
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revision = sys.argv[3]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'vcs_rev'):
        raise Unauthorised, "Can't create items of class 'vcs_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    #date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=vcs_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        self.author = "mario"

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :716
author Pygi <pygi@users.sourceforge.net> 1246984784 +0000
committer Pygi <pygi@users.sourceforge.net> 1246984784 +0000
data 23
more porting and hacks
from :714
property svn 4 4289
M 100755 :715 scripts/notify-roundup/notify-roundup.py

blob
mark :717
data 13751
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revisions = sys.argv[3].split(':')
        revision = revisions[0]
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'vcs_rev'):
        raise Unauthorised, "Can't create items of class 'vcs_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    #date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=vcs_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        self.author = "mario"

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :718
author Pygi <pygi@users.sourceforge.net> 1246984864 +0000
committer Pygi <pygi@users.sourceforge.net> 1246984864 +0000
data 7
bugfix
from :716
property svn 4 4290
M 100755 :717 scripts/notify-roundup/notify-roundup.py

blob
mark :719
data 13795
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revisions = sys.argv[3].split(':')
        revisionz = revisions[1].lstrip()
        revision = int(revisionz)
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'vcs_rev'):
        raise Unauthorised, "Can't create items of class 'vcs_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    #date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=vcs_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        self.author = "mario"

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :720
author Pygi <pygi@users.sourceforge.net> 1246984999 +0000
committer Pygi <pygi@users.sourceforge.net> 1246984999 +0000
data 7
bugfix
from :718
property svn 4 4291
M 100755 :719 scripts/notify-roundup/notify-roundup.py

blob
mark :721
data 13875
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands, datetime

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revisions = sys.argv[3].split(':')
        revisionz = revisions[1].lstrip()
        revision = int(revisionz)
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'vcs_rev'):
        raise Unauthorised, "Can't create items of class 'vcs_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=vcs_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class HGRepository:
    '''Holds roots and other information about the hg repository.'
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        self.author = "mario"

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log /home/mario/Projects/roundup-hg --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        self.summary = "This is hg change"
        self.date = time.localtime()
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009b
mark :722
author Pygi <pygi@users.sourceforge.net> 1246985492 +0000
committer Pygi <pygi@users.sourceforge.net> 1246985492 +0000
data 9
it works
from :720
property svn 4 4292
M 100755 :721 scripts/notify-roundup/notify-roundup.py

commit refs/heads/gsoc-2009
mark :723
author Pygi <pygi@users.sourceforge.net> 1246997990 +0000
committer Pygi <pygi@users.sourceforge.net> 1246997990 +0000
data 11
merge done
from :669
merge :722
property svn 4 4294
R "scripts/beta-notify/detectors/svnauditor.py" "scripts/notify-roundup/detectors/vcsauditor.py"
M 100644 :678 scripts/notify-roundup/detectors/vcsauditor.py
D scripts/beta-notify/doc/README
D scripts/beta-notify/extensions/revision_info.py
D scripts/beta-notify/html/bug.item.html
R "scripts/beta-notify/html/svn_rev.item.html" "scripts/notify-roundup/html/vcs_rev.item.html"
D scripts/beta-notify/html/user.item.html
D scripts/beta-notify/notify-roundup.ini
D scripts/beta-notify/notify-roundup.py
D scripts/notify-roundup/detectors/svnauditor.py
M 100644 :681 scripts/notify-roundup/html/bug.item.html
D scripts/notify-roundup/html/svn_rev.item.html
M 100644 :667 scripts/notify-roundup/notify-roundup.ini
M 100755 :721 scripts/notify-roundup/notify-roundup.py
M 100644 :673 share/roundup/templates/devel/schema.py

commit refs/heads/gsoc-2009
mark :724
author Pygi <pygi@users.sourceforge.net> 1246998087 +0000
committer Pygi <pygi@users.sourceforge.net> 1246998087 +0000
data 13
Added hg dir
from :723
property svn 4 4295

blob
mark :725
data 290
#!/bin/bash
PYTHON=/usr/bin/python
NOTIFY=/path/to/your/notify-roundup.py
CONFIG=/path/to/your/notify-roundup.ini
REPOS=`/bin/pwd`
CMD="/usr/bin/hg log `/bin/pwd` --rev=tip"
REV=`$CMD | grep changeset`
PYTHONPATH=/path/to/your/roundup/instance "$PYTHON" "$NOTIFY" "$CONFIG" "$REPOS" "$REV"

commit refs/heads/gsoc-2009
mark :726
author Pygi <pygi@users.sourceforge.net> 1246998473 +0000
committer Pygi <pygi@users.sourceforge.net> 1246998473 +0000
data 36
Added initial hg post-commit script
from :724
property svn 4 4296
M 100755 :725 scripts/notify-roundup/hg/notify-roundup.sh

blob
mark :727
data 1629
Roundup devel tracker in love with Mercurial
=============================================

This document serves a tutorial on setting up a Roundup instance
with devel template featuring Mercurial integration. Several assumptions
are made in this tutorial:

1) You've checked out gsoc-2009 Roundup branch
2) You know how to setup mercurial repository
3) You want to work with a local mercurial repository

Let's follow the steps:

1) Setup Mercurial post-commit hook

a) Copy notify-roundup.sh from scripts/notify-roundup/hg/notify-roundup.sh to somewhere
b) Make sure its executable (chmod +x)
c) Add the following to /path/to/hg/repo/.hg/hgrc

[hooks]
commit = /path/to/notify-roundup.sh

[1] notify-roundup.py and notify-roundup.ini can be found in scripts/notify-roundup

2) Modify notify-roundup.ini

a) Set tracker home: tracker-home = /path/to/tracker-home
b) Set address mappings
c) Set VCS type to hg

3) Replace "/home/mario/Projects/roundup-hg" in notify-roundup.py with path to your repository

How-to format mercurial commit message
=======================================

By default, notify-roundup handles bugs.
To change status of bug1, format your commit
message like this:

bug1 pending

Current limitations and bugs
============================

1) Notify-roundup can work only with one item-class
2) Notify-roundup can only modify Status
3) Commit date isn't parsed 
4) Summary isn't composed
5) HG repository path is hard-coded
6) Changed files should be generated and posted
7) Diff should be created for vcs_rev page

We are aware of the those limitations, and have plans to alleviate them in the future.

commit refs/heads/gsoc-2009
mark :728
author Pygi <pygi@users.sourceforge.net> 1246999816 +0000
committer Pygi <pygi@users.sourceforge.net> 1246999816 +0000
data 18
Initial hg readme
from :726
property svn 4 4297
M 100644 :727 scripts/notify-roundup/doc/README.hg

blob
mark :729
data 1671
Roundup devel tracker in love with Mercurial
=============================================

This document serves a tutorial on setting up a Roundup instance
with devel template featuring Mercurial integration. Several assumptions
are made in this tutorial:

1) You've checked out gsoc-2009 Roundup branch
2) You know how to setup mercurial repository
3) You want to work with a local mercurial repository

Let's follow the steps:

1) Setup Mercurial post-commit hook

a) Copy notify-roundup.sh from scripts/notify-roundup/hg/notify-roundup.sh to somewhere
b) Make sure its executable (chmod +x)
c) Add the following to /path/to/hg/repo/.hg/hgrc

[hooks]
commit = /path/to/notify-roundup.sh

[1] notify-roundup.py and notify-roundup.ini can be found in scripts/notify-roundup

2) Modify notify-roundup.ini

a) Set tracker home: tracker-home = /path/to/tracker-home
b) Set address mappings
c) Set VCS type to hg

3) Replace "/home/mario/Projects/roundup-hg" in notify-roundup.py with path to your repository

How-to format mercurial commit message
=======================================

By default, notify-roundup handles bugs.
To change status of bug1, format your commit
message like this:

bug1 pending

Current limitations and bugs
============================

1) Notify-roundup can work only with one item-class
2) Notify-roundup can only modify Status
3) Commit date isn't parsed 
4) Summary isn't composed
5) HG repository path is hard-coded
6) Changed files should be generated and posted
7) Diff should be created for vcs_rev page
8) Parse multiple lines of commit message

We are aware of the those limitations, and have plans to alleviate them in the future.

commit refs/heads/gsoc-2009
mark :730
author Pygi <pygi@users.sourceforge.net> 1247000517 +0000
committer Pygi <pygi@users.sourceforge.net> 1247000517 +0000
data 43
some more limitations of hg implementation
from :728
property svn 4 4298
M 100644 :729 scripts/notify-roundup/doc/README.hg

blob
mark :731
data 2244
Roundup devel tracker in love with Mercurial
=============================================

This document serves a tutorial on setting up a Roundup instance
with devel template featuring Mercurial integration. Several assumptions
are made in this tutorial:

1) You've checked out gsoc-2009 Roundup branch
2) You know how to setup mercurial repository
3) You want to work with a local mercurial repository

Let's follow the steps:

1) Setup Mercurial post-commit hook

a) Copy notify-roundup.sh from scripts/notify-roundup/hg/notify-roundup.sh to somewhere
b) Change paths to notify-roundup.{py,ini} and your roundup instance inside notify-roundup.sh [1]
b) Make sure its executable (chmod +x)
c) Add the following to /path/to/hg/repo/.hg/hgrc

[hooks]
commit = /path/to/notify-roundup.sh

Note: Commit should probably be changed by "incoming". This is subject to further investigation.

[1] notify-roundup.py and notify-roundup.ini can be found in scripts/notify-roundup

2) Modify notify-roundup.ini

a) Set tracker home: tracker-home = /path/to/tracker-home
b) Set address mappings
Please be aware that we are playing tricks with Mercurial here. Your Roundup user should be the same
as your first name for Mercurial. Lets explore that further with an example:

HG author is set as: Mario Danic <mario@nospam.com>
Notify-roundup would look for address mapping like this:
mario = whatever_email_you_registered_with_to_Roundup

So it takes your first name, lowers all chars and uses mappings
to find appropriate Roundup user. 
c) Set VCS type to hg

3) Now, now, this wasn't so hard :)

How-to format mercurial commit message
=======================================

By default, notify-roundup handles bugs.
To change status of bug1, format your commit
message like this:

bug1 pending

Current limitations and bugs
============================

1) Notify-roundup can work only with one item-class
2) Notify-roundup can only modify Status
3) Commit date isn't parsed 
4) Summary isn't composed
5) Changed files should be generated and posted
6) Diff should be created for vcs_rev page
7) Parse multiple lines of commit message
    * This might already work

We are aware of the those limitations, and have plans to alleviate them in the future.

blob
mark :732
data 1369
; notify-roundup.py configuration file

[main]
; notify a local or emailed tracker -- 'email' or 'local'
;mode = email
mode = local

; change this to detect other issue types
; multiple issue classes are possible (use regular expression "either" syntax)
item-class = bug
; item-class = system
; item-class = dev|system|network

; only set this if socket.gethostname() doesn't return the host's name as
; registered with your tracker
; host = host.name.example



[local]
; if notifying a local tracker, configure this variable
tracker-home = /path/to/your/tracker-home

[email]
; if notifying a tracker by email, configure these variables
smtp-host = smtp-host.example
tracker-address = issues@host.example
; email-domain is used in conjuntion with the address mappings below
default-domain = @host.example

[vcs]
; choose a VCS type -- 'svn' or 'hg'
;type = hg
type = svn

[address mappings]
; map Subversion author names to email addresses that the tracker will
; recognise. The "email :: default-domain" var will be appended if the
; address doesn't specify a domain.
; 
;richard = rjones
richard = ni@spam.example

; If no mapping is defined for a particular author, we either:
; 1. use the <Subversion author name>@<default-domain> address or,
; 2. if a "*" entry is defined under address mappings, then we use
;    that address as the from address.
;* = unknown


blob
mark :733
data 14238
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revisions = sys.argv[3].split(':')
        revisionz = revisions[1].lstrip()
        revision = int(revisionz)
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'vcs_rev'):
        raise Unauthorised, "Can't create items of class 'vcs_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=vcs_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class BZRRepository:
    '''Holds roots and other information about the bzr repository.
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('bzr log -r-1 --line ' + self.repos_dir)
class HGRepository:
    '''Holds roots and other information about the hg repository.
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log ' + self.repos_dir + ' --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        author_split2 = authoro[0].rstrip('>').split()
        self.author = author_split2[0].lower()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log ' + self.repos_dir + ' --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        self.summary = "This is hg change"
        self.date = time.localtime()
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009
mark :734
author Pygi <pygi@users.sourceforge.net> 1247086451 +0000
committer Pygi <pygi@users.sourceforge.net> 1247086451 +0000
data 54
Fixed a lot of problems with hg notify implementation
from :730
property svn 4 4299
M 100644 :731 scripts/notify-roundup/doc/README.hg
M 100644 :732 scripts/notify-roundup/notify-roundup.ini
M 100755 :733 scripts/notify-roundup/notify-roundup.py

blob
mark :735
data 2549
# Subversion integration information fetcher
# 
# Extracts information about a specific revision from a local repository.
#
# Place this file in your tracker's "extensions" directory.

import sys, os, time
from svn import core, fs, delta, repos
from libsvn.fs import svn_fs_file_contents as file_contents
import tempfile

def _dump_file(root, path):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    output = open(file, 'w+')
    if path is not None:
        stream = file_contents(root, path)
        try:
            while 1:
                chunk = core.svn_stream_read(stream, core.SVN_STREAM_CHUNK_SIZE)
                if not chunk:
                    break
                output.write(chunk)
        finally:
            core.svn_stream_close(stream)
    output.close()
    return file

class ChangeSetItem:
    def __init__(self, new_root, old_root, path, change):

        self.new_root = new_root
        self.old_root = old_root
        self.path = path
        if change.path:
            self.action = change.added and 'new' or 'modified'
        else:
            self.action = 'delete'
        self.change = change

    def diff(self):
        from difflib import HtmlDiff

        from_file = _dump_file(self.old_root, self.change.path)
        to_file = _dump_file(self.new_root, self.path)
        html = HtmlDiff()
        return html.make_file(open(from_file, 'r').readlines(),
                              open(to_file, 'r').readlines(),
                              'original', 'new')

        return html_diff(file1, file2)


def _info(pool, path, rev):
    repos_ptr = repos.svn_repos_open(path, pool)
    fs_ptr = repos.svn_repos_fs(repos_ptr)

    new_root = fs.revision_root(fs_ptr, rev, pool)
    old_root = fs.revision_root(fs_ptr, rev - 1, pool)

    # get all changes
    editor = repos.RevisionChangeCollector(fs_ptr, rev, pool)
    e_ptr, e_baton = delta.make_editor(editor, pool)
    repos.svn_repos_replay(new_root, e_ptr, e_baton, pool)

    changeset = editor.changes.items()
    changeset.sort()
    return [ChangeSetItem(new_root, old_root, path, change)
            for path, change in changeset]

def info(path, revision):
    return core.run_app(_info, path, int(revision))

def init(instance):
    instance.registerUtil('revision_info', info)

if __name__ == '__main__':

    path = '/home/stefan/projects/svn-roundup/repo'
    revision = 1
    if len(sys.argv) == 2:
        revision = int(sys.argv[1])
    print revision_info(path, revision)


blob
mark :736
data 774
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title">
 SVN Revision <span tal:replace="context/revision" />
</title>
<tal:block metal:fill-slot="body_title">
 SVN Revision <span tal:replace="context/revision" />
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="not:context/is_view_ok" i18n:translate="">You are not
    allowed to view this page.</p>

<div tal:condition="context/is_view_ok">
<table class="messages">
<tal:block repeat="file python:utils.revision_info(context.repository.path.plain(),
		   context.revision.plain())">
 <tr><th tal:content="string: ${file/action} ${file/path}" /></tr>
 <tr><td tal:content="structure file/diff" /></tr>
</tal:block>
</table>
</div>

</td>

</tal:block>

blob
mark :737
data 791
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title">
 SVN Revision <span tal:replace="context/revision" />
</title>
<tal:block metal:fill-slot="body_title">
 SVN Revision <span tal:replace="context/revision" />
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="not:context/is_view_ok" i18n:translate="">You are not
    allowed to view this page.</p>

<div tal:condition="context/is_view_ok">
  <a tal:attributes="href string:vcs_rev${context/id}?@template=diff">diff</a>
  <ul tal:repeat="file python:utils.revision_info(context.repository.path.plain(),
	    	                                  context.revision.plain())">
    <li tal:content="string: ${file/action} ${file/path}" />
  </ul>
</div>

</td>

</tal:block>

commit refs/heads/gsoc-2009
mark :738
author Stefan Seefeld <stefan@users.sourceforge.net> 1247347241 +0000
committer Stefan Seefeld <stefan@users.sourceforge.net> 1247347241 +0000
data 31
Enhance revision diff display.
from :734
property svn 4 4301
M 100644 :735 scripts/notify-roundup/extensions/revision_info.py
C "scripts/notify-roundup/html/vcs_rev.item.html" "scripts/notify-roundup/html/vcs_rev.diff.html"
M 100644 :736 scripts/notify-roundup/html/vcs_rev.diff.html
M 100644 :737 scripts/notify-roundup/html/vcs_rev.item.html

blob
mark :739
data 14758
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revisions = sys.argv[3].split(':')
        revisionz = revisions[1].lstrip()
        revision = int(revisionz)
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'vcs_rev'):
        raise Unauthorised, "Can't create items of class 'vcs_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=vcs_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class BZRRepository:
    '''Holds roots and other information about the bzr repository.
       THIS IS WIP AND HASN'T BEEN TESTED AT ALL!
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('bzr log -r-1 --line ' + self.repos_dir + ' | grep committer')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        author_split2 = authoro[0].rstrip('>').split()
        self.author = author_split[0].lower()
        


class GitRepository:
    '''Holds roots and other information about the git repository.
       THIS IS WIP AND HASN'T BEEN TESTED AT ALL!
    '''
    
    self.repos_dir = repos_dir
    self.rev = rev
    self.pool = pool
    
    
class HGRepository:
    '''Holds roots and other information about the hg repository.
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log ' + self.repos_dir + ' --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        author_split2 = authoro[0].rstrip('>').split()
        self.author = author_split2[0].lower()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
        re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log ' + self.repos_dir + ' --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        self.summary = "This is hg change"
        self.date = time.localtime()
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009
mark :740
author Pygi <pygi@users.sourceforge.net> 1247489514 +0000
committer Pygi <pygi@users.sourceforge.net> 1247489514 +0000
data 45
Implemented WIP bzr revision author fetching
from :738
property svn 4 4302
M 100755 :739 scripts/notify-roundup/notify-roundup.py

blob
mark :741
data 6324
<tal:doc metal:use-macro="templates/page/macros/frame"
define="edit_ok context/is_edit_ok"
>
<title metal:fill-slot="head_title">
<tal:if condition="context/id" i18n:translate=""
 >User <span tal:replace="context/id" i18n:name="id"
 />: <span tal:replace="context/username" i18n:name="title"
 /> - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:if>
<tal:if condition="not:context/id" i18n:translate=""
 >New User - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:if>
</title>
<metal:slot fill-slot="more-javascript">
<script metal:use-macro="templates/page/macros/user_utils"></script>
<script type="text/javascript" src="@@file/help_controls.js"></script>
</metal:slot>
<tal:block metal:fill-slot="body_title"
  define="edit_ok context/is_edit_ok">
 <span tal:condition="python: not (context.id or edit_ok)"
  tal:omit-tag="python:1" i18n:translate="">New User</span>
 <span tal:condition="python: not context.id and edit_ok"
  tal:omit-tag="python:1" i18n:translate="">New User Editing</span>
 <span tal:condition="python: context.id and not edit_ok"
  tal:omit-tag="python:1" i18n:translate="">User<tal:x
  replace="context/id" i18n:name="id" /></span>
 <span tal:condition="python: context.id and edit_ok"
  tal:omit-tag="python:1" i18n:translate="">User<tal:x
  replace="context/id" i18n:name="id" /> Editing</span>
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<div tal:condition="context/is_view_ok">

<form method="POST"
      tal:define="required python:'username address'.split()"
      enctype="multipart/form-data"
      tal:attributes="action context/designator;
      onSubmit python:'return checkRequiredFields(\'%s\')'%'\', \''.join(required);
      ">
<table class="form" tal:define="
  th_label templates/page/macros/th_label;
  src_input templates/page/macros/user_src_input;
  normal_input templates/page/macros/user_normal_input;
  pw_input templates/page/macros/user_pw_input;
  confirm_input templates/page/macros/user_confirm_input;
  edit_ok context/is_edit_ok;
  ">
 <tr tal:define="name string:realname; label string:Name; value context/realname; edit_ok edit_ok">
  <th metal:use-macro="th_label">Name</th>
  <td><input name="realname" metal:use-macro="src_input"></td>
 </tr>
 <tr tal:define="name string:username; label string:Login Name; value context/username">
   <th metal:use-macro="th_label">Login Name</th>
   <td><input metal:use-macro="src_input"></td>
 </tr>
  <tal:if condition="edit_ok">
 <tr tal:define="name string:password; label string:Login Password">
  <th metal:use-macro="th_label">Login Password</th>
  <td><input metal:use-macro="pw_input" type="password"></td>
 </tr>
 <tr tal:define="name string:password; label string:Confirm Password">
  <th metal:use-macro="th_label">Confirm Password</th>
  <td><input metal:use-macro="confirm_input" type="password"></td>
 </tr>
  </tal:if>
 <tr>
 <th i18n:translate="">VCS login</th>
 <td tal:content="structure context/vcs_name/field">vcs_name</td>
 </tr>
  <tal:if condition="python:request.user.hasPermission('Web Roles')">
 <tr tal:define="name string:roles; label string:Roles;">
  <th><label for="roles" i18n:translate="">Roles</label></th>
  <td tal:define="gips context/id">
    <tal:subif condition=gips define="value context/roles">
      <input metal:use-macro="normal_input">
    </tal:subif>
    <tal:subif condition="not:gips" define="value db/config/NEW_WEB_USER_ROLES">
      <input metal:use-macro="normal_input">
    </tal:subif>
   <tal:block i18n:translate="">(to give the user more than one role,
    enter a comma,separated,list)</tal:block>
  </td>
 </tr>
 </tal:if>

 <tr tal:define="name string:phone; label string:Phone; value context/phone">
  <th metal:use-macro="th_label">Phone</th>
  <td><input name="phone" metal:use-macro="normal_input"></td>
 </tr>

 <tr tal:define="name string:organisation; label string:Organisation; value context/organisation">
  <th metal:use-macro="th_label">Organisation</th>
  <td><input name="organisation" metal:use-macro="normal_input"></td>
 </tr>

 <tr tal:condition="python:edit_ok or context.timezone"
     tal:define="name string:timezone; label string:Timezone; value context/timezone">
  <th metal:use-macro="th_label">Timezone</th>
  <td><input tal:replace="structure python:
       utils.tzfield(context.timezone, 'timezone', db.config.DEFAULT_TIMEZONE)"/>
  </td>
 </tr>

 <tr tal:define="name string:address; label string:E-mail address; value context/address">
  <th metal:use-macro="th_label">E-mail address</th>
  <td tal:define="mailto python:context.address.field(id='address');
	  mklink python:mailto and not edit_ok">
      <a href="mailto:calvin@the-z.org"
		  tal:attributes="href string:mailto:$value"
		  tal:content="value"
          tal:condition="python:mklink">calvin@the-z.org</a>
      <tal:if condition=edit_ok>
      <input metal:use-macro="src_input" value="calvin@the-z.org">
      </tal:if>
      &nbsp;
  </td>
 </tr>

 <tr>
  <th><label for="alternate_addresses" i18n:translate="">Alternate E-mail addresses<br>One address per line</label></th>
  <td>
    <textarea rows=5 cols=40 tal:replace="structure context/alternate_addresses/multiline">nobody@nowhere.org
anybody@everywhere.net
(alternate_addresses)
    </textarea>
  </td>
 </tr>

 <tr tal:condition="edit_ok">
  <td>
   &nbsp;
   <input type="hidden" name="@template" value="item">
   <input type="hidden" name="@required" value="username,address"
          tal:attributes="value python:','.join(required)">
  </td>
  <td><input type="submit" value="save" tal:replace="structure context/submit"><!--submit button here-->
    <input type="reset">
  </td>
 </tr>
</table>
</form>

<tal:block tal:condition="not:context/id" i18n:translate="">
<table class="form">
<tr>
 <td>Note:&nbsp;</td>
 <th class="required">highlighted</th>
 <td>&nbsp;fields are required.</td>
</tr>
</table>
</tal:block>

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</div>

</td>

</tal:doc>

commit refs/heads/gsoc-2009
mark :742
author Pygi <pygi@users.sourceforge.net> 1247496982 +0000
committer Pygi <pygi@users.sourceforge.net> 1247496982 +0000
data 21
Fixed user html page
from :740
property svn 4 4303
M 100644 :741 scripts/notify-roundup/html/user.item.html

blob
mark :743
data 17149
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn':
        revision = int(sys.argv[3])
    elif vcs_type == 'hg':
        revisions = sys.argv[3].split(':')
        revisionz = revisions[1].lstrip()
        revision = int(revisionz)
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'vcs_rev'):
        raise Unauthorised, "Can't create items of class 'vcs_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=vcs_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class BZRRepository:
    '''Holds roots and other information about the bzr repository.
       THIS IS WIP AND HASN'T BEEN TESTED AT ALL!
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('bzr log -r-1 ' + self.repos_dir + ' | grep committer')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        author_split2 = authoro[0].rstrip('>').split()
        self.author = author_split[0].lower()
    
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = commands.getoutput('bzr log -r-1 ' + self.repos_dir) or ''
        log_mine = log.split('message:')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        self.summary = "This is bzr change"
        self.date = time.localtime()
        
        return True
                


class GitRepository:
    '''Holds roots and other information about the git repository.
       THIS IS WIP AND HASN'T BEEN TESTED AT ALL!
    '''
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
    
        authors_calls = commands.getoutput('cd ' + self.repos_dir + '; git log --pretty=format:%an | head -n1')
        authors_split = authors_calls.split()
        self.author = authors_split[0].lower()
    
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = commands.getoutput('cd ' + self.repos_dir + '; git log --pretty=format:%s | head -n1') or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        self.summary = "This is git change"
        self.date = time.localtime()
        
        return True
           
    
    
class HGRepository:
    '''Holds roots and other information about the hg repository.
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log ' + self.repos_dir + ' --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        author_split2 = authoro[0].rstrip('>').split()
        self.author = author_split2[0].lower()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log ' + self.repos_dir + ' --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        self.summary = "This is hg change"
        self.date = time.localtime()
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009
mark :744
author Pygi <pygi@users.sourceforge.net> 1247506681 +0000
committer Pygi <pygi@users.sourceforge.net> 1247506681 +0000
data 40
Implemented partial git and bzr support
from :742
property svn 4 4305
M 100755 :743 scripts/notify-roundup/notify-roundup.py

commit refs/heads/gsoc-2009
mark :745
author Pygi <pygi@users.sourceforge.net> 1247506739 +0000
committer Pygi <pygi@users.sourceforge.net> 1247506739 +0000
data 22
Created bzr directory
from :744
property svn 4 4306

commit refs/heads/gsoc-2009
mark :746
author Pygi <pygi@users.sourceforge.net> 1247506794 +0000
committer Pygi <pygi@users.sourceforge.net> 1247506794 +0000
data 16
Created git dir
from :745
property svn 4 4307

commit refs/heads/gsoc-2009
mark :747
author Pygi <pygi@users.sourceforge.net> 1247507552 +0000
committer Pygi <pygi@users.sourceforge.net> 1247507552 +0000
data 21
removed sh extension
from :746
property svn 4 4308
R "scripts/notify-roundup/hg/notify-roundup.sh" "scripts/notify-roundup/hg/notify-roundup"

blob
mark :748
data 434
#!/bin/sh
#
# An example hook script that is called after a successful
# commit is made.
#
# It is used for Roundup notification after a commit.

PYTHON=/usr/bin/python
NOTIFY=/path/to/your/notify-roundup.py
CONFIG=/path/to/your/notify-roundup.ini
REPOS=`/bin/pwd`
REV="cd `/bin/pwd` ; /usr/bin/git log --pretty=format:%h | head -n1 "
PYTHONPATH=/path/to/your/roundup/instance "$PYTHON" "$NOTIFY" "$CONFIG" "$REPOS" "$REV"

: Nothing

commit refs/heads/gsoc-2009
mark :749
author Pygi <pygi@users.sourceforge.net> 1247507638 +0000
committer Pygi <pygi@users.sourceforge.net> 1247507638 +0000
data 29
Added git post-commit script
from :747
property svn 4 4309
M 100755 :748 scripts/notify-roundup/git/post-commit

blob
mark :750
data 702
from bzrlib import branch
import commands
import os


# Installation:
# Copy this file to ~/.bazaar/plugins

notify_path = /path/to/your/notify-roundup.py
config_path = /path/to/your/notify-roundup.ini
roundup_instance_path = /path/to/your/roundup/instance

def post_commit_hook(branch='.'):
    my_branch = Branch.open(branch)
    revision = my_branch.last_revision()
    repo_dir = commands.getoutput('pwd')
    os.system("PYTHONPATH=" + roundup_instance_path + " " + "/usr/bin/python" + notify_path + config_path + " " + repo_dir + " " +  revision)
    

branch.Branch.hooks.install_named_hook('post_commit', post_commit_hook,
                                 'Bazaar -> Roundup integration hook')


commit refs/heads/gsoc-2009
mark :751
author Pygi <pygi@users.sourceforge.net> 1247509467 +0000
committer Pygi <pygi@users.sourceforge.net> 1247509467 +0000
data 44
Implemented provisional bzr postcommit hook
from :749
property svn 4 4310
M 100755 :750 scripts/notify-roundup/bzr/roundup_bzr.py

blob
mark :752
data 13613

#
# TRACKER SCHEMA
#

# Class automatically gets these properties:
#   creation = Date()
#   activity = Date()
#   creator = Link('user')
#   actor = Link('user')


# This is the repository class, then you can see/edit repositories in pages like
# "http://tracker/url/vcs_repo1"
vcs_repo = Class(db, "vcs_repo",
name=String(),
host=String(),
path=String(),
webview_url=String())
vcs_repo.setkey('name')

# Stores revision data, lets you see/edit revisions in pages like
# "http://tracker/url/vcs_rev1". The vcs_rev.item.html template is currently
# broken, but this works fine without it.
vcs_rev = Class(db, "vcs_rev",
repository=Link('vcs_repo'),
revision=String())



# Component
component = Class(db, 'component',
                  name=String(),
                  description=String(),
                  order=Number(),
                  assign_to=Link('user'))
component.setkey('name')

# Version
version = Class(db, 'version',
                name=String(),
                description=String(),
                order=Number())
version.setkey('name')

# Severity
severity = Class(db, 'severity',
                 name=String(),
                 description=String(),
                 order=Number())
severity.setkey('name')

# Priority
priority = Class(db, 'priority',
                 name=String(),
                 description=String(),
                 order=Number())
priority.setkey('name')

# Status
status = Class(db, "status",
               name=String(),
               description=String(),
               order=Number())
status.setkey("name")

# Resolution
resolution = Class(db, "resolution",
                   name=String(),
                   description=String(),
                   order=Number())
resolution.setkey('name')

# Keyword
keyword = Class(db, "keyword",
                name=String(),
                description=String())
keyword.setkey("name")
                

# User-defined saved searches
query = Class(db, "query",
              klass=String(),
              name=String(),
              url=String(),
              private_for=Link('user'))

# add any additional database schema configuration here

user = Class(db, "user",
             username=String(),
             password=Password(),
             address=String(),
             realname=String(),
             phone=String(),
             organisation=String(),
             alternate_addresses=String(),
             queries=Multilink('query'),
             roles=String(),     # comma-separated string of Role names
             timezone=String(),
             vcs_name=String())

user.setkey("username")

# Permissions for revision creation and repository viewing.
for role in ('User',):
    db.security.addPermissionToRole(role, 'Create', 'vcs_rev')
    db.security.addPermissionToRole(role, 'View', 'vcs_repo')

# FileClass automatically gets this property in addition to the Class ones:
#   content = String()    [saved to disk in <tracker home>/db/files/]
#   type = String()       [MIME type of the content, default 'text/plain']
msg = FileClass(db, "msg",
                author=Link("user", do_journal='no'),
                recipients=Multilink("user", do_journal='no'),
                date=Date(),
                summary=String(),
                files=Multilink("file"),
                messageid=String(),
                inreplyto=String(),
                revision=Link("vcs_rev"))

file = FileClass(db, "file",
                name=String(),
                description=String(indexme='yes'))

# Bug Type
bug_type = Class(db, 'bug_type',
                 name=String(),
                 description=String(),
                 order=Number())
bug_type.setkey('name')

# IssueClass automatically gets these properties in addition to the Class ones:
#   title = String()
#   messages = Multilink("msg")
#   files = Multilink("file")
#   nosy = Multilink("user")
#   superseder = Multilink("issue")
bug = IssueClass(db, "bug",
                 type=Link('bug_type'),
                 components=Multilink('component'),
                 versions=Multilink('version'),
                 severity=Link('severity'),
                 priority=Link('priority'),
                 dependencies=Multilink('bug'),
                 assignee=Link('user'),
                 status=Link('status'),
                 resolution=Link('resolution'),
                 superseder=Link('bug'),
                 keywords=Multilink('keyword'))

# Task Type
task_type = Class(db, 'task_type',
                 name=String(),
                 description=String(),
                 order=Number())
task_type.setkey('name')

# IssueClass automatically gets these properties in addition to the Class ones:
#   title = String()
#   messages = Multilink("msg")
#   files = Multilink("file")
#   nosy = Multilink("user")
#   superseder = Multilink("issue")
task = IssueClass(db, "task",
                  type=Link('task_type'),
                  components=Multilink('component'),
                  priority=Link('priority'),
                  dependencies=Multilink('task'),
                  assignee=Multilink('user'),
                  status=Link('status'),
                  resolution=Link('resolution'),
                  solves=Link('bug'))

milestone = IssueClass(db, "milestone",
                       bugs=Multilink("bug"),
                       tasks=Multilink("task"),
                       status=Link("status"),
                       release_date=String())

#
# TRACKER SECURITY SETTINGS
#
# See the configuration and customisation document for information
# about security setup.

db.security.addRole(name='Developer', description='A developer')
db.security.addRole(name='Coordinator', description='A coordinator')

#
# REGULAR USERS
#
# Give the regular users access to the web and email interface
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, 'Web Access')
    db.security.addPermissionToRole(r, 'Email Access')

##########################
# User permissions
##########################

for cl in ('severity', 'component',
           'version', 'priority', 'status', 'resolution',
           'bug_type', 'bug', 'task_type', 'task', 'milestone',
           'keyword', 'file', 'msg'):
    db.security.addPermissionToRole('User', 'View', cl)
    db.security.addPermissionToRole('Anonymous', 'View', cl)
    db.security.addPermissionToRole('User', 'Create', cl)
    

def may_edit_file(db, userid, itemid):
    return userid == db.file.get(itemid, "creator")

p = db.security.addPermission(name='Edit', klass='file', check=may_edit_file,
    description="User is allowed to remove their own files")
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Create', klass='bug',
                              properties=('title', 'bug_type',
                                          'components', 'versions',
                                          'severity',
                                          'messages', 'files', 'nosy'),
                              description='User can report and discuss bugs')
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Edit', klass='bug',
                              properties=('title', 'bug_type',
                                          'components', 'versions',
                                          'severity',
                                          'messages', 'files', 'nosy'),
                              description='User can report and discuss bugs')
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Create', klass='task',
                              properties=('title', 'task_type',
                                          'components',
                                          'messages', 'files', 'nosy'),
                              description='Developer can create and discuss tasks')
db.security.addPermissionToRole('Developer', p)

p = db.security.addPermission(name='Edit', klass='task',
                              properties=('title', 'task_type',
                                          'components',
                                          'messages', 'files', 'nosy'),
                              description='Developer can create and discuss tasks')
db.security.addPermissionToRole('Developer', p)

p = db.security.addPermission(name='Create', klass='milestone',
                              description='Coordinator can create and discuss milestones')
db.security.addPermissionToRole('Coordinator', p)

p = db.security.addPermission(name='Edit', klass='milestone',
                              description='Coordinator can create and discuss milestones')
db.security.addPermissionToRole('Coordinator', p)


##########################
# Developer permissions
##########################
for cl in ('bug_type', 'severity', 'component',
           'version', 'priority', 'status', 'resolution',
           'bug', 'file', 'msg', 'keyword'):
    db.security.addPermissionToRole('Developer', 'View', cl)

for cl in ('bug', 'file', 'msg', 'keyword'):
    db.security.addPermissionToRole('Developer', 'Edit', cl)
    db.security.addPermissionToRole('Developer', 'Create', cl)


##########################
# Coordinator permissions
##########################
for cl in ('bug_type', 'task_type', 'severity', 'component',
           'version', 'priority', 'status', 'resolution', 'bug', 'task', 'file', 'msg'):
    db.security.addPermissionToRole('Coordinator', 'View', cl)
    db.security.addPermissionToRole('Coordinator', 'Edit', cl)
    db.security.addPermissionToRole('Coordinator', 'Create', cl)

# May users view other user information? Comment these lines out
# if you don't want them to
db.security.addPermissionToRole('User', 'View', 'user')
db.security.addPermissionToRole('Developer', 'View', 'user')
db.security.addPermissionToRole('Coordinator', 'View', 'user')

# Allow Coordinator to edit any user, including their roles.
db.security.addPermissionToRole('Coordinator', 'Edit', 'user')
db.security.addPermissionToRole('Coordinator', 'Web Roles')

# Users should be able to edit their own details -- this permission is
# limited to only the situation where the Viewed or Edited item is their own.
def own_record(db, userid, itemid):
    '''Determine whether the userid matches the item being accessed.'''
    return userid == itemid
p = db.security.addPermission(name='View', klass='user', check=own_record,
    description="User is allowed to view their own user details")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Edit', klass='user', check=own_record,
    description="User is allowed to edit their own user details",
    properties=('username', 'password',
                'address', 'realname',
                'phone', 'organization',
                'alternate_addresses',
                'queries',
                'timezone')) # Note: 'roles' excluded - users should not be able to edit their own roles. 
for r in 'User', 'Developer':
    db.security.addPermissionToRole(r, p)

# Users should be able to edit and view their own queries. They should also
# be able to view any marked as not private. They should not be able to
# edit others' queries, even if they're not private
def view_query(db, userid, itemid):
    private_for = db.query.get(itemid, 'private_for')
    if not private_for: return True
    return userid == private_for
def edit_query(db, userid, itemid):
    return userid == db.query.get(itemid, 'creator')
p = db.security.addPermission(name='View', klass='query', check=view_query,
    description="User is allowed to view their own and public queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Edit', klass='query', check=edit_query,
    description="User is allowed to edit their queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Create', klass='query',
    description="User is allowed to create queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)


#
# ANONYMOUS USER PERMISSIONS
#
# Let anonymous users access the web interface. Note that almost all
# trackers will need this Permission. The only situation where it's not
# required is in a tracker that uses an HTTP Basic Authenticated front-end.
db.security.addPermissionToRole('Anonymous', 'Web Access')

# Let anonymous users access the email interface (note that this implies
# that they will be registered automatically, hence they will need the
# "Create" user Permission below)
# This is disabled by default to stop spam from auto-registering users on
# public trackers.
#db.security.addPermissionToRole('Anonymous', 'Email Access')

# Assign the appropriate permissions to the anonymous user's Anonymous
# Role. Choices here are:
# - Allow anonymous users to register
db.security.addPermissionToRole('Anonymous', 'Create', 'user')

# Allow anonymous users access to view issues (and the related, linked
# information).

for cl in 'bug', 'task', 'milestone', 'severity', 'status', 'resolution', 'msg', 'file':
    db.security.addPermissionToRole('Anonymous', 'View', cl)

# [OPTIONAL]
# Allow anonymous users access to create or edit "issue" items (and the
# related file and message items)
#for cl in 'issue', 'file', 'msg':
#   db.security.addPermissionToRole('Anonymous', 'Create', cl)
#   db.security.addPermissionToRole('Anonymous', 'Edit', cl)


# vim: set filetype=python sts=4 sw=4 et si :


commit refs/heads/gsoc-2009
mark :753
author Pygi <pygi@users.sourceforge.net> 1247516317 +0000
committer Pygi <pygi@users.sourceforge.net> 1247516317 +0000
data 28
Revision should be a string
from :751
property svn 4 4311
M 100644 :752 share/roundup/templates/devel/schema.py

blob
mark :754
data 2733
# Subversion integration information fetcher
# 
# Extracts information about a specific revision from a local repository.
#
# Place this file in your tracker's "extensions" directory.

import sys, os, time
from svn import core, fs, delta, repos
from libsvn.fs import svn_fs_file_contents as file_contents
import tempfile
import logging

hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)

def _dump_file(root, path):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    output = open(file, 'w+')
    if path is not None:
        stream = file_contents(root, path)
        try:
            while 1:
                chunk = core.svn_stream_read(stream, core.SVN_STREAM_CHUNK_SIZE)
                if not chunk:
                    break
                output.write(chunk)
        finally:
            core.svn_stream_close(stream)
    output.close()
    return file

class ChangeSetItem:
    def __init__(self, new_root, old_root, path, change):

        self.new_root = new_root
        self.old_root = old_root
        self.path = path
        if change.path:
            self.action = change.added and 'new' or 'modified'
        else:
            self.action = 'delete'
        self.change = change

    def diff(self):
        from difflib import HtmlDiff

        from_file = _dump_file(self.old_root, self.change.path)
        to_file = _dump_file(self.new_root, self.path)
        html = HtmlDiff()
        return html.make_file(open(from_file, 'r').readlines(),
                              open(to_file, 'r').readlines(),
                              'original', 'new')

        return html_diff(file1, file2)


def _info(pool, path, rev):
    repos_ptr = repos.svn_repos_open(path, pool)
    fs_ptr = repos.svn_repos_fs(repos_ptr)

    new_root = fs.revision_root(fs_ptr, rev, pool)
    old_root = fs.revision_root(fs_ptr, rev - 1, pool)

    # get all changes
    editor = repos.RevisionChangeCollector(fs_ptr, rev, pool)
    e_ptr, e_baton = delta.make_editor(editor, pool)
    repos.svn_repos_replay(new_root, e_ptr, e_baton, pool)

    changeset = editor.changes.items()
    logging.error(changeset)
    changeset.sort()
    return [ChangeSetItem(new_root, old_root, path, change)
            for path, change in changeset]

def info(path, revision):
    return core.run_app(_info, path, int(revision))

def init(instance):
    instance.registerUtil('revision_info', info)

if __name__ == '__main__':

    path = '/home/stefan/projects/svn-roundup/repo'
    revision = 1
    if len(sys.argv) == 2:
        revision = int(sys.argv[1])
    print revision_info(path, revision)


blob
mark :755
data 17151
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn' or vcs_type == 'bzr' or vcs_type == 'git':
        revision = sys.argv[3]
    elif vcs_type == 'hg':
        revisions = sys.argv[3].split(':')
        revision = revisions[1].lstrip()
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'vcs_rev'):
        raise Unauthorised, "Can't create items of class 'vcs_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=vcs_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))

class BZRRepository:
    '''Holds roots and other information about the bzr repository.
       THIS IS WIP AND HASN'T BEEN TESTED AT ALL!
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('bzr log -r-1 ' + self.repos_dir + ' | grep committer')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        author_split2 = authoro[0].rstrip('>').split()
        self.author = author_split[0].lower()
    
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = commands.getoutput('bzr log -r-1 ' + self.repos_dir) or ''
        log_mine = log.split('message:')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        self.summary = "This is bzr change"
        self.date = time.localtime()
        
        return True
                


class GitRepository:
    '''Holds roots and other information about the git repository.
       THIS IS WIP AND HASN'T BEEN TESTED AT ALL!
    '''
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
    
        authors_calls = commands.getoutput('cd ' + self.repos_dir + '; git log --pretty=format:%an | head -n1')
        authors_split = authors_calls.split()
        self.author = authors_split[0].lower()
    
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = commands.getoutput('cd ' + self.repos_dir + '; git log --pretty=format:%s | head -n1') or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        self.summary = "This is git change"
        self.date = time.localtime()
        
        return True
           
    
    
class HGRepository:
    '''Holds roots and other information about the hg repository.
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log ' + self.repos_dir + ' --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        author_split2 = authoro[0].rstrip('>').split()
        self.author = author_split2[0].lower()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log ' + self.repos_dir + ' --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        self.summary = "This is hg change"
        self.date = time.localtime()
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009
mark :756
author Pygi <pygi@users.sourceforge.net> 1247516494 +0000
committer Pygi <pygi@users.sourceforge.net> 1247516494 +0000
data 51
Now that we have string as a revision, its al cool
from :753
property svn 4 4312
M 100644 :754 scripts/notify-roundup/extensions/revision_info.py
M 100755 :755 scripts/notify-roundup/notify-roundup.py

blob
mark :757
data 2550
# Subversion integration information fetcher
# 
# Extracts information about a specific revision from a local repository.
#
# Place this file in your tracker's "extensions" directory.

import sys, os, time
from svn import core, fs, delta, repos
from libsvn.fs import svn_fs_file_contents as file_contents
import tempfile


def _dump_file(root, path):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    output = open(file, 'w+')
    if path is not None:
        stream = file_contents(root, path)
        try:
            while 1:
                chunk = core.svn_stream_read(stream, core.SVN_STREAM_CHUNK_SIZE)
                if not chunk:
                    break
                output.write(chunk)
        finally:
            core.svn_stream_close(stream)
    output.close()
    return file

class ChangeSetItem:
    def __init__(self, new_root, old_root, path, change):

        self.new_root = new_root
        self.old_root = old_root
        self.path = path
        if change.path:
            self.action = change.added and 'new' or 'modified'
        else:
            self.action = 'delete'
        self.change = change

    def diff(self):
        from difflib import HtmlDiff

        from_file = _dump_file(self.old_root, self.change.path)
        to_file = _dump_file(self.new_root, self.path)
        html = HtmlDiff()
        return html.make_file(open(from_file, 'r').readlines(),
                              open(to_file, 'r').readlines(),
                              'original', 'new')

        return html_diff(file1, file2)


def _info(pool, path, rev):
    repos_ptr = repos.svn_repos_open(path, pool)
    fs_ptr = repos.svn_repos_fs(repos_ptr)

    new_root = fs.revision_root(fs_ptr, rev, pool)
    old_root = fs.revision_root(fs_ptr, rev - 1, pool)

    # get all changes
    editor = repos.RevisionChangeCollector(fs_ptr, rev, pool)
    e_ptr, e_baton = delta.make_editor(editor, pool)
    repos.svn_repos_replay(new_root, e_ptr, e_baton, pool)

    changeset = editor.changes.items()
    changeset.sort()
    return [ChangeSetItem(new_root, old_root, path, change)
            for path, change in changeset]

def info(path, revision):
    return core.run_app(_info, path, int(revision))

def init(instance):
    instance.registerUtil('revision_info', info)

if __name__ == '__main__':

    path = '/home/stefan/projects/svn-roundup/repo'
    revision = 1
    if len(sys.argv) == 2:
        revision = int(sys.argv[1])
    print revision_info(path, revision)


commit refs/heads/gsoc-2009
mark :758
author Pygi <pygi@users.sourceforge.net> 1247517156 +0000
committer Pygi <pygi@users.sourceforge.net> 1247517156 +0000
data 43
Renamed revision info to svn_revision_info
from :756
property svn 4 4313
R "scripts/notify-roundup/extensions/revision_info.py" "scripts/notify-roundup/extensions/svn_revision_info.py"
M 100644 :757 scripts/notify-roundup/extensions/svn_revision_info.py

commit refs/heads/gsoc-2009
mark :759
author Pygi <pygi@users.sourceforge.net> 1247517230 +0000
committer Pygi <pygi@users.sourceforge.net> 1247517230 +0000
data 30
Created hg revision info file
from :758
property svn 4 4314
M 100644 :287 scripts/notify-roundup/extensions/hg_revision_info.py

blob
mark :760
data 1482
import commands
from difflib import HtmlDiff    

def _dump_files(path, revision):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    file2 = tempfile.mktemp()
    output = open(file, 'w+')
    output2 = open(file2, 'w+')
    if path is not None:
        output.write(commands.getoutput('hg cat '  + " --rev " + revision + " " + path))
        output2.write(commands.getoutput('hg cat ' + " --rev " + revision-1 + " " + path))
    output.close()
    output2.close()
    return file, file2

def diff (path, revision):
    """ Diff between two revisions."""
    
    
def info(path, revision)
    dict = {}

    changes = commands.getoutput("hg log -p -r " + revision + " " + path + " | lsdiff -s --strip=1")
    return changes
    line_changes = changes.splitlines()
    for line in line_changes:
        check = line.str('+')
        if check != -1:
            split_check = line.split()
            dict['Added:'] = split_check[1]
            diff(split_check[1], revision)
            continue
        check = line.str('-')
        if check != -1:
            split_check = line.split()
            dict['Removed:'] = split_check[1]
            continue
        check = line.str('!')
            if check != -1:
                split_check = line.split()
                dict['Modified:'] = split_check[1]    
                continue    
        
    

def init(instance):
    instance.registerUtil('revision_info', info)

commit refs/heads/gsoc-2009
mark :761
author Pygi <pygi@users.sourceforge.net> 1247838545 +0000
committer Pygi <pygi@users.sourceforge.net> 1247838545 +0000
data 35
Done some work on hg revision info
from :759
property svn 4 4320
M 100644 :760 scripts/notify-roundup/extensions/hg_revision_info.py

blob
mark :762
data 1483
import commands
from difflib import HtmlDiff    

def _dump_files(path, revision):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    file2 = tempfile.mktemp()
    output = open(file, 'w+')
    output2 = open(file2, 'w+')
    if path is not None:
        output.write(commands.getoutput('hg cat '  + " --rev " + revision + " " + path))
        output2.write(commands.getoutput('hg cat ' + " --rev " + revision-1 + " " + path))
    output.close()
    output2.close()
    return file, file2

def diff (path, revision):
    """ Diff between two revisions."""
    
    
def info(path, revision):
    dict = {}

    changes = commands.getoutput("hg log -p -r " + revision + " " + path + " | lsdiff -s --strip=1")
    return changes
    line_changes = changes.splitlines()
    for line in line_changes:
        check = line.str('+')
        if check != -1:
            split_check = line.split()
            dict['Added:'] = split_check[1]
            diff(split_check[1], revision)
            continue
        check = line.str('-')
        if check != -1:
            split_check = line.split()
            dict['Removed:'] = split_check[1]
            continue
        check = line.str('!')
            if check != -1:
                split_check = line.split()
                dict['Modified:'] = split_check[1]    
                continue    
        
    

def init(instance):
    instance.registerUtil('revision_info', info)

commit refs/heads/gsoc-2009
mark :763
author Pygi <pygi@users.sourceforge.net> 1247838637 +0000
committer Pygi <pygi@users.sourceforge.net> 1247838637 +0000
data 16
Fixed silly bug
from :761
property svn 4 4321
M 100644 :762 scripts/notify-roundup/extensions/hg_revision_info.py

blob
mark :764
data 1467
import commands
from difflib import HtmlDiff    

def _dump_files(path, revision):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    file2 = tempfile.mktemp()
    output = open(file, 'w+')
    output2 = open(file2, 'w+')
    if path is not None:
        output.write(commands.getoutput('hg cat '  + " --rev " + revision + " " + path))
        output2.write(commands.getoutput('hg cat ' + " --rev " + revision-1 + " " + path))
    output.close()
    output2.close()
    return file, file2

def diff (path, revision):
    """ Diff between two revisions."""
    
    
def info(path, revision):
    dict = {}

    changes = commands.getoutput("hg log -p -r " + revision + " " + path + " | lsdiff -s --strip=1")
    return changes
    line_changes = changes.splitlines()
    for line in line_changes:
        check = line.str('+')
        if check != -1:
            split_check = line.split()
            dict['Added:'] = split_check[1]
            diff(split_check[1], revision)
            continue
        check = line.str('-')
        if check != -1:
            split_check = line.split()
            dict['Removed:'] = split_check[1]
            continue
        check = line.str('!')
        if check != -1:
            split_check = line.split()
            dict['Modified:'] = split_check[1]    
            continue    
        
    

def init(instance):
    instance.registerUtil('revision_info', info)

commit refs/heads/gsoc-2009
mark :765
author Pygi <pygi@users.sourceforge.net> 1247838753 +0000
committer Pygi <pygi@users.sourceforge.net> 1247838753 +0000
data 15
fixed identing
from :763
property svn 4 4322
M 100644 :764 scripts/notify-roundup/extensions/hg_revision_info.py

blob
mark :766
data 791
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title">
 VCS Revision <span tal:replace="context/revision" />
</title>
<tal:block metal:fill-slot="body_title">
 VCS Revision <span tal:replace="context/revision" />
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="not:context/is_view_ok" i18n:translate="">You are not
    allowed to view this page.</p>

<div tal:condition="context/is_view_ok">
  <a tal:attributes="href string:vcs_rev${context/id}?@template=diff">diff</a>
  <ul tal:repeat="file python:utils.revision_info(context.repository.path.plain(),
	    	                                  context.revision.plain())">
    <li tal:content="string: ${file/action} ${file/path}" />
  </ul>
</div>

</td>

</tal:block>

commit refs/heads/gsoc-2009
mark :767
author Pygi <pygi@users.sourceforge.net> 1247839731 +0000
committer Pygi <pygi@users.sourceforge.net> 1247839731 +0000
data 33
Ported vcs_rev.item to vcs stuff
from :765
property svn 4 4323
M 100644 :766 scripts/notify-roundup/html/vcs_rev.item.html

blob
mark :768
data 2088
import commands
from difflib import HtmlDiff    

path = '/home/mario/TestInstances/hgrepo'

def _dump_files(path, revision):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    file2 = tempfile.mktemp()
    output = open(file, 'w+')
    output2 = open(file2, 'w+')
    if path is not None:
        output.write(commands.getoutput('hg cat '  + " --rev " + revision + " " + path))
        output2.write(commands.getoutput('hg cat ' + " --rev " + int(revision-1) + " " + path))
    output.close()
    output2.close()
    return file, file2

class ChangeSetItem:
    def __init__(self, path, change):

        self.path = path
        #if change.path:
            self.action = change.added and 'new' or 'modified'
        #else:
        #    self.action = 'delete'
        self.change = change

    def diff(self):
        from difflib import HtmlDiff

        from_file, to_file = _dump_file(path, -1)
        html = HtmlDiff()
        return html.make_file(open(from_file, 'r').readlines(),
                              open(to_file, 'r').readlines(),
                              'original', 'new')

        return html_diff(file1, file2)
    
    
def info(path, revision):
    dict = {}

    changes = commands.getoutput("hg log -p -r " + revision + " " + path + " | lsdiff -s --strip=1")
    line_changes = changes.splitlines()
    for line in line_changes:
        check = line.str('+')
        if check != -1:
            split_check = line.split()
            dict['Added:'] = split_check[1]
            diff(split_check[1], revision)
            continue
        check = line.str('-')
        if check != -1:
            split_check = line.split()
            dict['Removed:'] = split_check[1]
            continue
        check = line.str('!')
        if check != -1:
            split_check = line.split()
            dict['Modified:'] = split_check[1]    
            continue    
def info(path, revision):
    return _info(path, int(revision))
    

def init(instance):
    instance.registerUtil('revision_info', info)

blob
mark :769
data 2595
# Subversion integration information fetcher
# 
# Extracts information about a specific revision from a local repository.
#
# Place this file in your tracker's "extensions" directory.

import sys, os, time
from svn import core, fs, delta, repos
from libsvn.fs import svn_fs_file_contents as file_contents
import tempfile
import logging



def _dump_file(root, path):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    output = open(file, 'w+')
    if path is not None:
        stream = file_contents(root, path)
        try:
            while 1:
                chunk = core.svn_stream_read(stream, core.SVN_STREAM_CHUNK_SIZE)
                if not chunk:
                    break
                output.write(chunk)
        finally:
            core.svn_stream_close(stream)
    output.close()
    return file

class ChangeSetItem:
    def __init__(self, new_root, old_root, path, change):

        self.new_root = new_root
        self.old_root = old_root
        self.path = path
        if change.path:
            self.action = change.added and 'new' or 'modified'
        else:
            self.action = 'delete'
        self.change = change

    def diff(self):
        from difflib import HtmlDiff

        from_file = _dump_file(self.old_root, self.change.path)
        to_file = _dump_file(self.new_root, self.path)
        html = HtmlDiff()
        return html.make_file(open(from_file, 'r').readlines(),
                              open(to_file, 'r').readlines(),
                              'original', 'new')

        return html_diff(file1, file2)


def _info(pool, path, rev):
    repos_ptr = repos.svn_repos_open(path, pool)
    fs_ptr = repos.svn_repos_fs(repos_ptr)

    new_root = fs.revision_root(fs_ptr, rev, pool)
    old_root = fs.revision_root(fs_ptr, rev - 1, pool)

    # get all changes
    editor = repos.RevisionChangeCollector(fs_ptr, rev, pool)
    e_ptr, e_baton = delta.make_editor(editor, pool)
    repos.svn_repos_replay(new_root, e_ptr, e_baton, pool)

    changeset = editor.changes.items()
    changeset.sort()
    logging.debug(changeset)
    return [ChangeSetItem(new_root, old_root, path, change)
            for path, change in changeset]

def info(path, revision):
    return core.run_app(_info, path, int(revision))

def init(instance):
    instance.registerUtil('revision_info', info)

if __name__ == '__main__':

    path = '/home/stefan/projects/svn-roundup/repo'
    revision = 1
    if len(sys.argv) == 2:
        revision = int(sys.argv[1])
    print revision_info(path, revision)


commit refs/heads/gsoc-2009
mark :770
author Pygi <pygi@users.sourceforge.net> 1247841486 +0000
committer Pygi <pygi@users.sourceforge.net> 1247841486 +0000
data 39
some more attempts at making this work
from :767
property svn 4 4324
M 100644 :768 scripts/notify-roundup/extensions/hg_revision_info.py
M 100644 :769 scripts/notify-roundup/extensions/svn_revision_info.py

blob
mark :771
data 2551
# Subversion integration information fetcher
# 
# Extracts information about a specific revision from a local repository.
#
# Place this file in your tracker's "extensions" directory.

import sys, os, time
from svn import core, fs, delta, repos
from libsvn.fs import svn_fs_file_contents as file_contents
import tempfile



def _dump_file(root, path):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    output = open(file, 'w+')
    if path is not None:
        stream = file_contents(root, path)
        try:
            while 1:
                chunk = core.svn_stream_read(stream, core.SVN_STREAM_CHUNK_SIZE)
                if not chunk:
                    break
                output.write(chunk)
        finally:
            core.svn_stream_close(stream)
    output.close()
    return file

class ChangeSetItem:
    def __init__(self, new_root, old_root, path, change):

        self.new_root = new_root
        self.old_root = old_root
        self.path = path
        if change.path:
            self.action = change.added and 'new' or 'modified'
        else:
            self.action = 'delete'
        self.change = change

    def diff(self):
        from difflib import HtmlDiff

        from_file = _dump_file(self.old_root, self.change.path)
        to_file = _dump_file(self.new_root, self.path)
        html = HtmlDiff()
        return html.make_file(open(from_file, 'r').readlines(),
                              open(to_file, 'r').readlines(),
                              'original', 'new')

        return html_diff(file1, file2)


def _info(pool, path, rev):
    repos_ptr = repos.svn_repos_open(path, pool)
    fs_ptr = repos.svn_repos_fs(repos_ptr)

    new_root = fs.revision_root(fs_ptr, rev, pool)
    old_root = fs.revision_root(fs_ptr, rev - 1, pool)

    # get all changes
    editor = repos.RevisionChangeCollector(fs_ptr, rev, pool)
    e_ptr, e_baton = delta.make_editor(editor, pool)
    repos.svn_repos_replay(new_root, e_ptr, e_baton, pool)

    changeset = editor.changes.items()
    changeset.sort()
    return [ChangeSetItem(new_root, old_root, path, change)
            for path, change in changeset]

def info(path, revision):
    return core.run_app(_info, path, int(revision))

def init(instance):
    instance.registerUtil('revision_info', info)

if __name__ == '__main__':

    path = '/home/stefan/projects/svn-roundup/repo'
    revision = 1
    if len(sys.argv) == 2:
        revision = int(sys.argv[1])
    print revision_info(path, revision)


commit refs/heads/gsoc-2009
mark :772
author Pygi <pygi@users.sourceforge.net> 1247841539 +0000
committer Pygi <pygi@users.sourceforge.net> 1247841539 +0000
data 27
logging doesnt belong here
from :770
property svn 4 4325
M 100644 :771 scripts/notify-roundup/extensions/svn_revision_info.py

blob
mark :773
data 1878
import commands
from difflib import HtmlDiff    
import tempfile

path_global = '/home/mario/TestInstances/hgrepo'

def _dump_file(path, revision):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    file2 = tempfile.mktemp()
    output = open(file, 'w+')
    output2 = open(file2, 'w+')
    if path is not None:
        output.write(commands.getoutput('hg cat '  + " --rev " + str(revision) + " " + path))
        output2.write(commands.getoutput('hg cat ' + " --rev " + str(int(revision-1)) + " " + path))
    output.close()
    output2.close()
    return file, file2

class ChangeSetItem:
    def __init__(self,line):

        pathos = line.split()
        self.path = pathos[1]

        self.line = line
        
        check = line.find('+')
        if check != -1:
            self.action = 'added'
        check = line.find('!')
        if check != -1:
            self.action = 'modified'
        check = line.find('!')
        if check != -1:
            self.action = 'modified'    

        self.change = 'test'
        
    def diff(self):
        from difflib import HtmlDiff

        from_file, to_file = _dump_file(path_global, -1)
        html = HtmlDiff()
        return html.make_file(open(from_file, 'r').readlines(),
                              open(to_file, 'r').readlines(),
                              'original', 'new')

        return html_diff(file1, file2)
    
    
def _info(path, revision):

    changes = commands.getoutput("hg log -p -r " + revision + " " + path + " | lsdiff -s --strip=1")
    line_changes = changes.splitlines()
    return [ChangeSetItem(line) for 
        line in line_changes]
    


def info(path, revision):
    global path_global
    path_global = path
    return _info(path, revision)
    

def init(instance):
    instance.registerUtil('revision_info', info)


commit refs/heads/gsoc-2009
mark :774
author Pygi <pygi@users.sourceforge.net> 1247843818 +0000
committer Pygi <pygi@users.sourceforge.net> 1247843818 +0000
data 19
it works, it works
from :772
property svn 4 4326
M 100644 :773 scripts/notify-roundup/extensions/hg_revision_info.py

blob
mark :775
data 1872
import commands
from difflib import HtmlDiff    
import tempfile

path_global = '/home/mario/TestInstances/hgrepo'

def _dump_file(path, revision):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    file2 = tempfile.mktemp()
    output = open(file, 'w+')
    output2 = open(file2, 'w+')
    if path is not None:
        output.write(commands.getoutput('hg cat '  + " --rev " + str(revision) + " " + path))
        output2.write(commands.getoutput('hg cat ' + " --rev " + str(revision-1) + " " + path))
    output.close()
    output2.close()
    return file, file2

class ChangeSetItem:
    def __init__(self,line):

        pathos = line.split()
        self.path = pathos[1]

        self.line = line
        
        check = line.find('+')
        if check != -1:
            self.action = 'added'
        check = line.find('!')
        if check != -1:
            self.action = 'modified'
        check = line.find('-')
        if check != -1:
            self.action = 'removed'    

        self.change = 'test'
        
    def diff(self):
        from difflib import HtmlDiff

        from_file, to_file = _dump_file(path_global, -1)
        html = HtmlDiff()
        return html.make_file(open(from_file, 'r').readlines(),
                              open(to_file, 'r').readlines(),
                              'original', 'new')

        return html_diff(file1, file2)
    
    
def _info(path, revision):

    changes = commands.getoutput("hg log -p -r " + revision + " " + path + " | lsdiff -s --strip=1")
    line_changes = changes.splitlines()
    return [ChangeSetItem(line) for 
        line in line_changes]
    


def info(path, revision):
    global path_global
    path_global = path
    return _info(path, revision)
    

def init(instance):
    instance.registerUtil('revision_info', info)


commit refs/heads/gsoc-2009
mark :776
author Pygi <pygi@users.sourceforge.net> 1247856684 +0000
committer Pygi <pygi@users.sourceforge.net> 1247856684 +0000
data 48
fixed a bug where we had double modified action
from :774
property svn 4 4327
M 100644 :775 scripts/notify-roundup/extensions/hg_revision_info.py

blob
mark :777
data 57532
#! /usr/bin/env python
#
# Copyright (c) 2001 Bizar Software Pty Ltd (http://www.bizarsoftware.com.au/)
# This module is free software, and you may redistribute it and/or modify
# under the same terms as Python, so long as this copyright message and
# disclaimer are retained in their original form.
#
# IN NO EVENT SHALL BIZAR SOFTWARE PTY LTD BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# BIZAR SOFTWARE PTY LTD SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
# BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS"
# BASIS, AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
# SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#

"""Administration commands for maintaining Roundup trackers.
"""
__docformat__ = 'restructuredtext'

import csv, getopt, getpass, os, re, shutil, sys, UserDict

from roundup import date, hyperdb, roundupdb, init, password, token
from roundup import __version__ as roundup_version
import roundup.instance
from roundup.configuration import CoreConfig
from roundup.i18n import _
from roundup.exceptions import UsageError

class CommandDict(UserDict.UserDict):
    """Simple dictionary that lets us do lookups using partial keys.

    Original code submitted by Engelbert Gruber.
    """
    _marker = []
    def get(self, key, default=_marker):
        if self.data.has_key(key):
            return [(key, self.data[key])]
        keylist = self.data.keys()
        keylist.sort()
        l = []
        for ki in keylist:
            if ki.startswith(key):
                l.append((ki, self.data[ki]))
        if not l and default is self._marker:
            raise KeyError, key
        return l

class AdminTool:
    """ A collection of methods used in maintaining Roundup trackers.

        Typically these methods are accessed through the roundup-admin
        script. The main() method provided on this class gives the main
        loop for the roundup-admin script.

        Actions are defined by do_*() methods, with help for the action
        given in the method docstring.

        Additional help may be supplied by help_*() methods.
    """
    def __init__(self):
        self.commands = CommandDict()
        for k in AdminTool.__dict__.keys():
            if k[:3] == 'do_':
                self.commands[k[3:]] = getattr(self, k)
        self.help = {}
        for k in AdminTool.__dict__.keys():
            if k[:5] == 'help_':
                self.help[k[5:]] = getattr(self, k)
        self.tracker_home = ''
        self.db = None
        self.db_uncommitted = False

    def get_class(self, classname):
        """Get the class - raise an exception if it doesn't exist.
        """
        try:
            return self.db.getclass(classname)
        except KeyError:
            raise UsageError, _('no such class "%(classname)s"')%locals()

    def props_from_args(self, args):
        """ Produce a dictionary of prop: value from the args list.

            The args list is specified as ``prop=value prop=value ...``.
        """
        props = {}
        for arg in args:
            if arg.find('=') == -1:
                raise UsageError, _('argument "%(arg)s" not propname=value'
                    )%locals()
            l = arg.split('=')
            if len(l) < 2:
                raise UsageError, _('argument "%(arg)s" not propname=value'
                    )%locals()
            key, value = l[0], '='.join(l[1:])
            if value:
                props[key] = value
            else:
                props[key] = None
        return props

    def usage(self, message=''):
        """ Display a simple usage message.
        """
        if message:
            message = _('Problem: %(message)s\n\n')%locals()
        print _("""%(message)sUsage: roundup-admin [options] [<command> <arguments>]

Options:
 -i instance home  -- specify the issue tracker "home directory" to administer
 -u                -- the user[:password] to use for commands
 -d                -- print full designators not just class id numbers
 -c                -- when outputting lists of data, comma-separate them.
                      Same as '-S ","'.
 -S <string>       -- when outputting lists of data, string-separate them
 -s                -- when outputting lists of data, space-separate them.
                      Same as '-S " "'.
 -V                -- be verbose when importing
 -v                -- report Roundup and Python versions (and quit)

 Only one of -s, -c or -S can be specified.

Help:
 roundup-admin -h
 roundup-admin help                       -- this help
 roundup-admin help <command>             -- command-specific help
 roundup-admin help all                   -- all available help
""")%locals()
        self.help_commands()

    def help_commands(self):
        """List the commands available with their help summary.
        """
        print _('Commands:'),
        commands = ['']
        for command in self.commands.values():
            h = _(command.__doc__).split('\n')[0]
            commands.append(' '+h[7:])
        commands.sort()
        commands.append(_(
"""Commands may be abbreviated as long as the abbreviation
matches only one command, e.g. l == li == lis == list."""))
        print '\n'.join(commands)
        print

    def help_commands_html(self, indent_re=re.compile(r'^(\s+)\S+')):
        """ Produce an HTML command list.
        """
        commands = self.commands.values()
        def sortfun(a, b):
            return cmp(a.__name__, b.__name__)
        commands.sort(sortfun)
        for command in commands:
            h = _(command.__doc__).split('\n')
            name = command.__name__[3:]
            usage = h[0]
            print """
<tr><td valign=top><strong>%(name)s</strong></td>
    <td><tt>%(usage)s</tt><p>
<pre>""" % locals()
            indent = indent_re.match(h[3])
            if indent: indent = len(indent.group(1))
            for line in h[3:]:
                if indent:
                    print line[indent:]
                else:
                    print line
            print '</pre></td></tr>\n'

    def help_all(self):
        print _("""
All commands (except help) require a tracker specifier. This is just
the path to the roundup tracker you're working with. A roundup tracker
is where roundup keeps the database and configuration file that defines
an issue tracker. It may be thought of as the issue tracker's "home
directory". It may be specified in the environment variable TRACKER_HOME
or on the command line as "-i tracker".

A designator is a classname and a nodeid concatenated, eg. bug1, user10, ...

Property values are represented as strings in command arguments and in the
printed results:
 . Strings are, well, strings.
 . Date values are printed in the full date format in the local time zone,
   and accepted in the full format or any of the partial formats explained
   below.
 . Link values are printed as node designators. When given as an argument,
   node designators and key strings are both accepted.
 . Multilink values are printed as lists of node designators joined
   by commas.  When given as an argument, node designators and key
   strings are both accepted; an empty string, a single node, or a list
   of nodes joined by commas is accepted.

When property values must contain spaces, just surround the value with
quotes, either ' or ". A single space may also be backslash-quoted. If a
value must contain a quote character, it must be backslash-quoted or inside
quotes. Examples:
           hello world      (2 tokens: hello, world)
           "hello world"    (1 token: hello world)
           "Roch'e" Compaan (2 tokens: Roch'e Compaan)
           Roch\\'e Compaan  (2 tokens: Roch'e Compaan)
           address="1 2 3"  (1 token: address=1 2 3)
           \\\\               (1 token: \\)
           \\n\\r\\t           (1 token: a newline, carriage-return and tab)

When multiple nodes are specified to the roundup get or roundup set
commands, the specified properties are retrieved or set on all the listed
nodes.

When multiple results are returned by the roundup get or roundup find
commands, they are printed one per line (default) or joined by commas (with
the -c) option.

Where the command changes data, a login name/password is required. The
login may be specified as either "name" or "name:password".
 . ROUNDUP_LOGIN environment variable
 . the -u command-line option
If either the name or password is not supplied, they are obtained from the
command-line.

Date format examples:
  "2000-04-17.03:45" means <Date 2000-04-17.08:45:00>
  "2000-04-17" means <Date 2000-04-17.00:00:00>
  "01-25" means <Date yyyy-01-25.00:00:00>
  "08-13.22:13" means <Date yyyy-08-14.03:13:00>
  "11-07.09:32:43" means <Date yyyy-11-07.14:32:43>
  "14:25" means <Date yyyy-mm-dd.19:25:00>
  "8:47:11" means <Date yyyy-mm-dd.13:47:11>
  "." means "right now"

Command help:
""")
        for name, command in self.commands.items():
            print _('%s:')%name
            print '   ', _(command.__doc__)

    def do_help(self, args, nl_re=re.compile('[\r\n]'),
            indent_re=re.compile(r'^(\s+)\S+')):
        ''"""Usage: help topic
        Give help about topic.

        commands  -- list commands
        <command> -- help specific to a command
        initopts  -- init command options
        all       -- all available help
        """
        if len(args)>0:
            topic = args[0]
        else:
            topic = 'help'


        # try help_ methods
        if self.help.has_key(topic):
            self.help[topic]()
            return 0

        # try command docstrings
        try:
            l = self.commands.get(topic)
        except KeyError:
            print _('Sorry, no help for "%(topic)s"')%locals()
            return 1

        # display the help for each match, removing the docsring indent
        for name, help in l:
            lines = nl_re.split(_(help.__doc__))
            print lines[0]
            indent = indent_re.match(lines[1])
            if indent: indent = len(indent.group(1))
            for line in lines[1:]:
                if indent:
                    print line[indent:]
                else:
                    print line
        return 0

    def listTemplates(self):
        """ List all the available templates.

        Look in the following places, where the later rules take precedence:

         1. <roundup.admin.__file__>/../../share/roundup/templates/*
            this is where they will be if we installed an egg via easy_install
         2. <prefix>/share/roundup/templates/*
            this should be the standard place to find them when Roundup is
            installed
         3. <roundup.admin.__file__>/../templates/*
            this will be used if Roundup's run in the distro (aka. source)
            directory
         4. <current working dir>/*
            this is for when someone unpacks a 3rd-party template
         5. <current working dir>
            this is for someone who "cd"s to the 3rd-party template dir
        """
        # OK, try <prefix>/share/roundup/templates
        #     and <egg-directory>/share/roundup/templates
        # -- this module (roundup.admin) will be installed in something
        # like:
        #    /usr/lib/python2.5/site-packages/roundup/admin.py  (5 dirs up)
        #    c:\python25\lib\site-packages\roundup\admin.py     (4 dirs up)
        #    /usr/lib/python2.5/site-packages/roundup-1.3.3-py2.5-egg/roundup/admin.py
        #    (2 dirs up)
        #
        # we're interested in where the directory containing "share" is
        templates = {}
        for N in 2, 4, 5:
            path = __file__
            # move up N elements in the path
            for i in range(N):
                path = os.path.dirname(path)
            tdir = os.path.join(path, 'share', 'roundup', 'templates')
            if os.path.isdir(tdir):
                templates = init.listTemplates(tdir)
                break

        # OK, now try as if we're in the roundup source distribution
        # directory, so this module will be in .../roundup-*/roundup/admin.py
        # and we're interested in the .../roundup-*/ part.
        path = __file__
        for i in range(2):
            path = os.path.dirname(path)
        tdir = os.path.join(path, 'templates')
        if os.path.isdir(tdir):
            templates.update(init.listTemplates(tdir))

        # Try subdirs of the current dir
        templates.update(init.listTemplates(os.getcwd()))

        # Finally, try the current directory as a template
        template = init.loadTemplateInfo(os.getcwd())
        if template:
            templates[template['name']] = template

        return templates

    def help_initopts(self):
        templates = self.listTemplates()
        print _('Templates:'), ', '.join(templates.keys())
        import roundup.backends
        backends = roundup.backends.list_backends()
        print _('Back ends:'), ', '.join(backends)

    def do_install(self, tracker_home, args):
        ''"""Usage: install [template [backend [key=val[,key=val]]]]
        Install a new Roundup tracker.

        The command will prompt for the tracker home directory
        (if not supplied through TRACKER_HOME or the -i option).
        The template and backend may be specified on the command-line
        as arguments, in that order.

        Command line arguments following the backend allows you to
        pass initial values for config options.  For example, passing
        "web_http_auth=no,rdbms_user=dinsdale" will override defaults
        for options http_auth in section [web] and user in section [rdbms].
        Please be careful to not use spaces in this argument! (Enclose
        whole argument in quotes if you need spaces in option value).

        The initialise command must be called after this command in order
        to initialise the tracker's database. You may edit the tracker's
        initial database contents before running that command by editing
        the tracker's dbinit.py module init() function.

        See also initopts help.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')

        # make sure the tracker home can be created
        tracker_home = os.path.abspath(tracker_home)
        parent = os.path.split(tracker_home)[0]
        if not os.path.exists(parent):
            raise UsageError, _('Instance home parent directory "%(parent)s"'
                ' does not exist')%locals()

        config_ini_file = os.path.join(tracker_home, CoreConfig.INI_FILE)
        # check for both old- and new-style configs
        if filter(os.path.exists, [config_ini_file,
                os.path.join(tracker_home, 'config.py')]):
            ok = raw_input(_(
"""WARNING: There appears to be a tracker in "%(tracker_home)s"!
If you re-install it, you will lose all the data!
Erase it? Y/N: """) % locals())
            if ok.strip().lower() != 'y':
                return 0

            # clear it out so the install isn't confused
            shutil.rmtree(tracker_home)

        # select template
        templates = self.listTemplates()
        template = len(args) > 1 and args[1] or ''
        if not templates.has_key(template):
            print _('Templates:'), ', '.join(templates.keys())
        while not templates.has_key(template):
            template = raw_input(_('Select template [classic]: ')).strip()
            if not template:
                template = 'classic'

        # select hyperdb backend
        import roundup.backends
        backends = roundup.backends.list_backends()
        backend = len(args) > 2 and args[2] or ''
        if backend not in backends:
            print _('Back ends:'), ', '.join(backends)
        while backend not in backends:
            backend = raw_input(_('Select backend [anydbm]: ')).strip()
            if not backend:
                backend = 'anydbm'
        # XXX perform a unit test based on the user's selections

        # Process configuration file definitions
        if len(args) > 3:
            try:
                defns = dict([item.split("=") for item in args[3].split(",")])
            except:
                print _('Error in configuration settings: "%s"') % args[3]
                raise
        else:
            defns = {}

        # install!
        init.install(tracker_home, templates[template]['path'], settings=defns)
        init.write_select_db(tracker_home, backend)

        print _("""
---------------------------------------------------------------------------
 You should now edit the tracker configuration file:
   %(config_file)s""") % {"config_file": config_ini_file}

        # find list of options that need manual adjustments
        # XXX config._get_unset_options() is marked as private
        #   (leading underscore).  make it public or don't care?
        need_set = CoreConfig(tracker_home)._get_unset_options()
        if need_set:
            print _(" ... at a minimum, you must set following options:")
            for section, options in need_set.items():
                print "   [%s]: %s" % (section, ", ".join(options))

        # note about schema modifications
        print _("""
 If you wish to modify the database schema,
 you should also edit the schema file:
   %(database_config_file)s
 You may also change the database initialisation file:
   %(database_init_file)s
 ... see the documentation on customizing for more information.

 You MUST run the "roundup-admin initialise" command once you've performed
 the above steps.
---------------------------------------------------------------------------
""") % {
    'database_config_file': os.path.join(tracker_home, 'schema.py'),
    'database_init_file': os.path.join(tracker_home, 'initial_data.py'),
}
        return 0

    def do_genconfig(self, args):
        ''"""Usage: genconfig <filename>
        Generate a new tracker config file (ini style) with default values
        in <filename>.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        config = CoreConfig()
        config.save(args[0])

    def do_initialise(self, tracker_home, args):
        ''"""Usage: initialise [adminpw]
        Initialise a new Roundup tracker.

        The administrator details will be set at this step.

        Execute the tracker's initialisation function dbinit.init()
        """
        # password
        if len(args) > 1:
            adminpw = args[1]
        else:
            adminpw = ''
            confirm = 'x'
            while adminpw != confirm:
                adminpw = getpass.getpass(_('Admin Password: '))
                confirm = getpass.getpass(_('       Confirm: '))

        # make sure the tracker home is installed
        if not os.path.exists(tracker_home):
            raise UsageError, _('Instance home does not exist')%locals()
        try:
            tracker = roundup.instance.open(tracker_home)
        except roundup.instance.TrackerError:
            raise UsageError, _('Instance has not been installed')%locals()

        # is there already a database?
        if tracker.exists():
            ok = raw_input(_(
"""WARNING: The database is already initialised!
If you re-initialise it, you will lose all the data!
Erase it? Y/N: """))
            if ok.strip().lower() != 'y':
                return 0

            backend = tracker.get_backend_name()

            # nuke it
            tracker.nuke()

            # re-write the backend select file
            init.write_select_db(tracker_home, backend)

        # GO
        tracker.init(password.Password(adminpw))

        return 0


    def do_get(self, args):
        ''"""Usage: get property designator[,designator]*
        Get the given property of one or more designator(s).

        Retrieves the property value of the nodes specified
        by the designators.
        """
        if len(args) < 2:
            raise UsageError, _('Not enough arguments supplied')
        propname = args[0]
        designators = args[1].split(',')
        l = []
        for designator in designators:
            # decode the node designator
            try:
                classname, nodeid = hyperdb.splitDesignator(designator)
            except hyperdb.DesignatorError as message:
                raise UsageError, message

            # get the class
            cl = self.get_class(classname)
            try:
                id=[]
                if self.separator:
                    if self.print_designator:
                        # see if property is a link or multilink for
                        # which getting a desginator make sense.
                        # Algorithm: Get the properties of the
                        #     current designator's class. (cl.getprops)
                        # get the property object for the property the
                        #     user requested (properties[propname])
                        # verify its type (isinstance...)
                        # raise error if not link/multilink
                        # get class name for link/multilink property
                        # do the get on the designators
                        # append the new designators
                        # print
                        properties = cl.getprops()
                        property = properties[propname]
                        if not (isinstance(property, hyperdb.Multilink) or
                          isinstance(property, hyperdb.Link)):
                            raise UsageError, _('property %s is not of type Multilink or Link so -d flag does not apply.')%propname
                        propclassname = self.db.getclass(property.classname).classname
                        id = cl.get(nodeid, propname)
                        for i in id:
                            l.append(propclassname + i)
                    else:
                        id = cl.get(nodeid, propname)
                        for i in id:
                            l.append(i)
                else:
                    if self.print_designator:
                        properties = cl.getprops()
                        property = properties[propname]
                        if not (isinstance(property, hyperdb.Multilink) or
                          isinstance(property, hyperdb.Link)):
                            raise UsageError, _('property %s is not of type Multilink or Link so -d flag does not apply.')%propname
                        propclassname = self.db.getclass(property.classname).classname
                        id = cl.get(nodeid, propname)
                        for i in id:
                            print propclassname + i
                    else:
                        print cl.get(nodeid, propname)
            except IndexError:
                raise UsageError, _('no such %(classname)s node "%(nodeid)s"')%locals()
            except KeyError:
                raise UsageError, _('no such %(classname)s property '
                    '"%(propname)s"')%locals()
        if self.separator:
            print self.separator.join(l)

        return 0


    def do_set(self, args):
        ''"""Usage: set items property=value property=value ...
        Set the given properties of one or more items(s).

        The items are specified as a class or as a comma-separated
        list of item designators (ie "designator[,designator,...]").

        This command sets the properties to the values for all designators
        given. If the value is missing (ie. "property=") then the property
        is un-set. If the property is a multilink, you specify the linked
        ids for the multilink as comma-separated numbers (ie "1,2,3").
        """
        if len(args) < 2:
            raise UsageError, _('Not enough arguments supplied')
        from roundup import hyperdb

        designators = args[0].split(',')
        if len(designators) == 1:
            designator = designators[0]
            try:
                designator = hyperdb.splitDesignator(designator)
                designators = [designator]
            except hyperdb.DesignatorError:
                cl = self.get_class(designator)
                designators = [(designator, x) for x in cl.list()]
        else:
            try:
                designators = [hyperdb.splitDesignator(x) for x in designators]
            except hyperdb.DesignatorError as message:
                raise UsageError, message

        # get the props from the args
        props = self.props_from_args(args[1:])

        # now do the set for all the nodes
        for classname, itemid in designators:
            cl = self.get_class(classname)

            properties = cl.getprops()
            for key, value in props.items():
                try:
                    props[key] = hyperdb.rawToHyperdb(self.db, cl, itemid,
                        key, value)
                except hyperdb.HyperdbValueError as message:
                    raise UsageError, message

            # try the set
            try:
                apply(cl.set, (itemid, ), props)
            except (TypeError, IndexError, ValueError) as message:
                import traceback; traceback.print_exc()
                raise UsageError, message
        self.db_uncommitted = True
        return 0

    def do_find(self, args):
        ''"""Usage: find classname propname=value ...
        Find the nodes of the given class with a given link property value.

        Find the nodes of the given class with a given link property value.
        The value may be either the nodeid of the linked node, or its key
        value.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        classname = args[0]
        # get the class
        cl = self.get_class(classname)

        # handle the propname=value argument
        props = self.props_from_args(args[1:])

        # convert the user-input value to a value used for find()
        for propname, value in props.items():
            if ',' in value:
                values = value.split(',')
            else:
                values = [value]
            d = props[propname] = {}
            for value in values:
                value = hyperdb.rawToHyperdb(self.db, cl, None, propname, value)
                if isinstance(value, list):
                    for entry in value:
                        d[entry] = 1
                else:
                    d[value] = 1

        # now do the find
        try:
            id = []
            designator = []
            if self.separator:
                if self.print_designator:
                    id=apply(cl.find, (), props)
                    for i in id:
                        designator.append(classname + i)
                    print self.separator.join(designator)
                else:
                    print self.separator.join(apply(cl.find, (), props))

            else:
                if self.print_designator:
                    id=apply(cl.find, (), props)
                    for i in id:
                        designator.append(classname + i)
                    print designator
                else:
                    print apply(cl.find, (), props)
        except KeyError:
            raise UsageError, _('%(classname)s has no property '
                '"%(propname)s"')%locals()
        except (ValueError, TypeError) as  message:
            raise UsageError, message
        return 0

    def do_specification(self, args):
        ''"""Usage: specification classname
        Show the properties for a classname.

        This lists the properties for a given class.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        classname = args[0]
        # get the class
        cl = self.get_class(classname)

        # get the key property
        keyprop = cl.getkey()
        for key, value in cl.properties.items():
            if keyprop == key:
                print _('%(key)s: %(value)s (key property)')%locals()
            else:
                print _('%(key)s: %(value)s')%locals()

    def do_display(self, args):
        ''"""Usage: display designator[,designator]*
        Show the property values for the given node(s).

        This lists the properties and their associated values for the given
        node.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')

        # decode the node designator
        for designator in args[0].split(','):
            try:
                classname, nodeid = hyperdb.splitDesignator(designator)
            except hyperdb.DesignatorError as message:
                raise UsageError, message

            # get the class
            cl = self.get_class(classname)

            # display the values
            keys = cl.properties.keys()
            keys.sort()
            for key in keys:
                value = cl.get(nodeid, key)
                print _('%(key)s: %(value)s')%locals()

    def do_create(self, args):
        ''"""Usage: create classname property=value ...
        Create a new entry of a given class.

        This creates a new entry of the given class using the property
        name=value arguments provided on the command line after the "create"
        command.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        from roundup import hyperdb

        classname = args[0]

        # get the class
        cl = self.get_class(classname)

        # now do a create
        props = {}
        properties = cl.getprops(protected = 0)
        if len(args) == 1:
            # ask for the properties
            for key, value in properties.items():
                if key == 'id': continue
                name = value.__class__.__name__
                if isinstance(value , hyperdb.Password):
                    again = None
                    while value != again:
                        value = getpass.getpass(_('%(propname)s (Password): ')%{
                            'propname': key.capitalize()})
                        again = getpass.getpass(_('   %(propname)s (Again): ')%{
                            'propname': key.capitalize()})
                        if value != again: print _('Sorry, try again...')
                    if value:
                        props[key] = value
                else:
                    value = raw_input(_('%(propname)s (%(proptype)s): ')%{
                        'propname': key.capitalize(), 'proptype': name})
                    if value:
                        props[key] = value
        else:
            props = self.props_from_args(args[1:])

        # convert types
        for propname, value in props.items():
            try:
                props[propname] = hyperdb.rawToHyperdb(self.db, cl, None,
                    propname, value)
            except hyperdb.HyperdbValueError as message:
                raise UsageError, message

        # check for the key property
        propname = cl.getkey()
        if propname and not props.has_key(propname):
            raise UsageError, _('you must provide the "%(propname)s" '
                'property.')%locals()

        # do the actual create
        try:
            print apply(cl.create, (), props)
        except (TypeError, IndexError, ValueError) as message:
            raise UsageError, message
        self.db_uncommitted = True
        return 0

    def do_list(self, args):
        ''"""Usage: list classname [property]
        List the instances of a class.

        Lists all instances of the given class. If the property is not
        specified, the  "label" property is used. The label property is
        tried in order: the key, "name", "title" and then the first
        property, alphabetically.

        With -c, -S or -s print a list of item id's if no property
        specified.  If property specified, print list of that property
        for every class instance.
        """
        if len(args) > 2:
            raise UsageError, _('Too many arguments supplied')
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        classname = args[0]
        
        # get the class
        cl = self.get_class(classname)

        # figure the property
        if len(args) > 1:
            propname = args[1]
        else:
            propname = cl.labelprop()

        if self.separator:
            if len(args) == 2:
                # create a list of propnames since user specified propname
                proplist=[]
                for nodeid in cl.list():
                    try:
                        proplist.append(cl.get(nodeid, propname))
                    except KeyError:
                        raise UsageError, _('%(classname)s has no property '
                            '"%(propname)s"')%locals()
                print self.separator.join(proplist)
            else:
                # create a list of index id's since user didn't specify
                # otherwise
                print self.separator.join(cl.list())
        else:
            for nodeid in cl.list():
                try:
                    value = cl.get(nodeid, propname)
                except KeyError:
                    raise UsageError, _('%(classname)s has no property '
                        '"%(propname)s"')%locals()
                print _('%(nodeid)4s: %(value)s')%locals()
        return 0

    def do_table(self, args):
        ''"""Usage: table classname [property[,property]*]
        List the instances of a class in tabular form.

        Lists all instances of the given class. If the properties are not
        specified, all properties are displayed. By default, the column
        widths are the width of the largest value. The width may be
        explicitly defined by defining the property as "name:width".
        For example::

          roundup> table priority id,name:10
          Id Name
          1  fatal-bug
          2  bug
          3  usability
          4  feature

        Also to make the width of the column the width of the label,
        leave a trailing : without a width on the property. For example::

          roundup> table priority id,name:
          Id Name
          1  fata
          2  bug
          3  usab
          4  feat

        will result in a the 4 character wide "Name" column.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        classname = args[0]

        # get the class
        cl = self.get_class(classname)

        # figure the property names to display
        if len(args) > 1:
            prop_names = args[1].split(',')
            all_props = cl.getprops()
            for spec in prop_names:
                if ':' in spec:
                    try:
                        propname, width = spec.split(':')
                    except (ValueError, TypeError):
                        raise UsageError, _('"%(spec)s" not name:width')%locals()
                else:
                    propname = spec
                if not all_props.has_key(propname):
                    raise UsageError, _('%(classname)s has no property '
                        '"%(propname)s"')%locals()
        else:
            prop_names = cl.getprops().keys()

        # now figure column widths
        props = []
        for spec in prop_names:
            if ':' in spec:
                name, width = spec.split(':')
                if width == '':
                    props.append((name, len(spec)))
                else:
                    props.append((name, int(width)))
            else:
               # this is going to be slow
               maxlen = len(spec)
               for nodeid in cl.list():
                   curlen = len(str(cl.get(nodeid, spec)))
                   if curlen > maxlen:
                       maxlen = curlen
               props.append((spec, maxlen))

        # now display the heading
        print ' '.join([name.capitalize().ljust(width) for name,width in props])

        # and the table data
        for nodeid in cl.list():
            l = []
            for name, width in props:
                if name != 'id':
                    try:
                        value = str(cl.get(nodeid, name))
                    except KeyError:
                        # we already checked if the property is valid - a
                        # KeyError here means the node just doesn't have a
                        # value for it
                        value = ''
                else:
                    value = str(nodeid)
                f = '%%-%ds'%width
                l.append(f%value[:width])
            print ' '.join(l)
        return 0

    def do_history(self, args):
        ''"""Usage: history designator
        Show the history entries of a designator.

        Lists the journal entries for the node identified by the designator.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        try:
            classname, nodeid = hyperdb.splitDesignator(args[0])
        except hyperdb.DesignatorError as message:
            raise UsageError, message

        try:
            print self.db.getclass(classname).history(nodeid)
        except KeyError:
            raise UsageError, _('no such class "%(classname)s"')%locals()
        except IndexError:
            raise UsageError, _('no such %(classname)s node "%(nodeid)s"')%locals()
        return 0

    def do_commit(self, args):
        ''"""Usage: commit
        Commit changes made to the database during an interactive session.

        The changes made during an interactive session are not
        automatically written to the database - they must be committed
        using this command.

        One-off commands on the command-line are automatically committed if
        they are successful.
        """
        self.db.commit()
        self.db_uncommitted = False
        return 0

    def do_rollback(self, args):
        ''"""Usage: rollback
        Undo all changes that are pending commit to the database.

        The changes made during an interactive session are not
        automatically written to the database - they must be committed
        manually. This command undoes all those changes, so a commit
        immediately after would make no changes to the database.
        """
        self.db.rollback()
        self.db_uncommitted = False
        return 0

    def do_retire(self, args):
        ''"""Usage: retire designator[,designator]*
        Retire the node specified by designator.

        This action indicates that a particular node is not to be retrieved
        by the list or find commands, and its key value may be re-used.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        designators = args[0].split(',')
        for designator in designators:
            try:
                classname, nodeid = hyperdb.splitDesignator(designator)
            except hyperdb.DesignatorError as message:
                raise UsageError, message
            try:
                self.db.getclass(classname).retire(nodeid)
            except KeyError:
                raise UsageError as _('no such class "%(classname)s"')%locals()
            except IndexError:
                raise UsageError as _('no such %(classname)s node "%(nodeid)s"')%locals()
        self.db_uncommitted = True
        return 0

    def do_restore(self, args):
        ''"""Usage: restore designator[,designator]*
        Restore the retired node specified by designator.

        The given nodes will become available for users again.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        designators = args[0].split(',')
        for designator in designators:
            try:
                classname, nodeid = hyperdb.splitDesignator(designator)
            except hyperdb.DesignatorError as message:
                raise UsageError, message
            try:
                self.db.getclass(classname).restore(nodeid)
            except KeyError:
                raise UsageError as _('no such class "%(classname)s"')%locals()
            except IndexError:
                raise UsageError as _('no such %(classname)s node "%(nodeid)s"')%locals()
        self.db_uncommitted = True
        return 0

    def do_export(self, args, export_files=True):
        ''"""Usage: export [[-]class[,class]] export_dir
        Export the database to colon-separated-value files.
        To exclude the files (e.g. for the msg or file class),
        use the exporttables command.

        Optionally limit the export to just the named classes
        or exclude the named classes, if the 1st argument starts with '-'.

        This action exports the current data from the database into
        colon-separated-value files that are placed in the nominated
        destination directory.
        """
        # grab the directory to export to
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')

        dir = args[-1]

        # get the list of classes to export
        if len(args) == 2:
            if args[0].startswith('-'):
                classes = [ c for c in self.db.classes.keys()
                            if not c in args[0][1:].split(',') ]
            else:
                classes = args[0].split(',')
        else:
            classes = self.db.classes.keys()

        class colon_separated(csv.excel):
            delimiter = ':'

        # make sure target dir exists
        if not os.path.exists(dir):
            os.makedirs(dir)

        # do all the classes specified
        for classname in classes:
            cl = self.get_class(classname)

            if not export_files and hasattr(cl, 'export_files'):
                sys.stdout.write('Exporting %s WITHOUT the files\r\n'%
                    classname)

            f = open(os.path.join(dir, classname+'.csv'), 'wb')
            writer = csv.writer(f, colon_separated)

            properties = cl.getprops()
            propnames = cl.export_propnames()
            fields = propnames[:]
            fields.append('is retired')
            writer.writerow(fields)

            # all nodes for this class
            for nodeid in cl.getnodeids():
                if self.verbose:
                    sys.stdout.write('\rExporting %s - %s'%(classname, nodeid))
                    sys.stdout.flush()
                writer.writerow(cl.export_list(propnames, nodeid))
                if export_files and hasattr(cl, 'export_files'):
                    cl.export_files(dir, nodeid)

            # close this file
            f.close()

            # export the journals
            jf = open(os.path.join(dir, classname+'-journals.csv'), 'wb')
            if self.verbose:
                sys.stdout.write("\nExporting Journal for %s\n" % classname)
                sys.stdout.flush()
            journals = csv.writer(jf, colon_separated)
            map(journals.writerow, cl.export_journals())
            jf.close()
        return 0

    def do_exporttables(self, args):
        ''"""Usage: exporttables [[-]class[,class]] export_dir
        Export the database to colon-separated-value files, excluding the
        files below $TRACKER_HOME/db/files/ (which can be archived separately).
        To include the files, use the export command.

        Optionally limit the export to just the named classes
        or exclude the named classes, if the 1st argument starts with '-'.

        This action exports the current data from the database into
        colon-separated-value files that are placed in the nominated
        destination directory.
        """
        return self.do_export(args, export_files=False)

    def do_import(self, args):
        ''"""Usage: import import_dir
        Import a database from the directory containing CSV files,
        two per class to import.

        The files used in the import are:

        <class>.csv
          This must define the same properties as the class (including
          having a "header" line with those property names.)
        <class>-journals.csv
          This defines the journals for the items being imported.

        The imported nodes will have the same nodeid as defined in the
        import file, thus replacing any existing content.

        The new nodes are added to the existing database - if you want to
        create a new database using the imported data, then create a new
        database (or, tediously, retire all the old data.)
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        from roundup import hyperdb

        # directory to import from
        dir = args[0]

        class colon_separated(csv.excel):
            delimiter = ':'

        # import all the files
        for file in os.listdir(dir):
            classname, ext = os.path.splitext(file)
            # we only care about CSV files
            if ext != '.csv' or classname.endswith('-journals'):
                continue

            cl = self.get_class(classname)

            # ensure that the properties and the CSV file headings match
            f = open(os.path.join(dir, file), 'r')
            reader = csv.reader(f, colon_separated)
            file_props = None
            maxid = 1
            # loop through the file and create a node for each entry
            for n, r in enumerate(reader):
                if file_props is None:
                    file_props = r
                    continue

                if self.verbose:
                    sys.stdout.write('\rImporting %s - %s'%(classname, n))
                    sys.stdout.flush()

                # do the import and figure the current highest nodeid
                nodeid = cl.import_list(file_props, r)
                if hasattr(cl, 'import_files'):
                    cl.import_files(dir, nodeid)
                maxid = max(maxid, int(nodeid))
            print
            f.close()

            # import the journals
            f = open(os.path.join(args[0], classname + '-journals.csv'), 'r')
            reader = csv.reader(f, colon_separated)
            cl.import_journals(reader)
            f.close()

            # set the id counter
            print 'setting', classname, maxid+1
            self.db.setid(classname, str(maxid+1))

        self.db_uncommitted = True
        return 0

    def do_pack(self, args):
        ''"""Usage: pack period | date

        Remove journal entries older than a period of time specified or
        before a certain date.

        A period is specified using the suffixes "y", "m", and "d". The
        suffix "w" (for "week") means 7 days.

              "3y" means three years
              "2y 1m" means two years and one month
              "1m 25d" means one month and 25 days
              "2w 3d" means two weeks and three days

        Date format is "YYYY-MM-DD" eg:
            2001-01-01

        """
        if len(args) <> 1:
            raise UsageError, _('Not enough arguments supplied')

        # are we dealing with a period or a date
        value = args[0]
        date_re = re.compile(r"""
              (?P<date>\d\d\d\d-\d\d?-\d\d?)? # yyyy-mm-dd
              (?P<period>(\d+y\s*)?(\d+m\s*)?(\d+d\s*)?)?
              """, re.VERBOSE)
        m = date_re.match(value)
        if not m:
            raise ValueError, _('Invalid format')
        m = m.groupdict()
        if m['period']:
            pack_before = date.Date(". - %s"%value)
        elif m['date']:
            pack_before = date.Date(value)
        self.db.pack(pack_before)
        self.db_uncommitted = True
        return 0

    def do_reindex(self, args, desre=re.compile('([A-Za-z]+)([0-9]+)')):
        ''"""Usage: reindex [classname|designator]*
        Re-generate a tracker's search indexes.

        This will re-generate the search indexes for a tracker.
        This will typically happen automatically.
        """
        if args:
            for arg in args:
                m = desre.match(arg)
                if m:
                    cl = self.get_class(m.group(1))
                    try:
                        cl.index(m.group(2))
                    except IndexError:
                        raise UsageError, _('no such item "%(designator)s"')%{
                            'designator': arg}
                else:
                    cl = self.get_class(arg)
                    self.db.reindex(arg)
        else:
            self.db.reindex(show_progress=True)
        return 0

    def do_security(self, args):
        ''"""Usage: security [Role name]
        Display the Permissions available to one or all Roles.
        """
        if len(args) == 1:
            role = args[0]
            try:
                roles = [(args[0], self.db.security.role[args[0]])]
            except KeyError:
                print _('No such Role "%(role)s"')%locals()
                return 1
        else:
            roles = self.db.security.role.items()
            role = self.db.config.NEW_WEB_USER_ROLES
            if ',' in role:
                print _('New Web users get the Roles "%(role)s"')%locals()
            else:
                print _('New Web users get the Role "%(role)s"')%locals()
            role = self.db.config.NEW_EMAIL_USER_ROLES
            if ',' in role:
                print _('New Email users get the Roles "%(role)s"')%locals()
            else:
                print _('New Email users get the Role "%(role)s"')%locals()
        roles.sort()
        for rolename, role in roles:
            print _('Role "%(name)s":')%role.__dict__
            for permission in role.permissions:
                d = permission.__dict__
                if permission.klass:
                    if permission.properties:
                        print _(' %(description)s (%(name)s for "%(klass)s"'
                          ': %(properties)s only)')%d
                    else:
                        print _(' %(description)s (%(name)s for "%(klass)s" '
                            'only)')%d
                else:
                    print _(' %(description)s (%(name)s)')%d
        return 0


    def do_migrate(self, args):
        ''"""Usage: migrate
        Update a tracker's database to be compatible with the Roundup
        codebase.

        You should run the "migrate" command for your tracker once you've
        installed the latest codebase. 

        Do this before you use the web, command-line or mail interface and
        before any users access the tracker.

        This command will respond with either "Tracker updated" (if you've
        not previously run it on an RDBMS backend) or "No migration action
        required" (if you have run it, or have used another interface to the
        tracker, or possibly because you are using anydbm).

        It's safe to run this even if it's not required, so just get into
        the habit.
        """
        if getattr(self.db, 'db_version_updated'):
            print _('Tracker updated')
            self.db_uncommitted = True
        else:
            print _('No migration action required')
        return 0

    def run_command(self, args):
        """Run a single command
        """
        command = args[0]

        # handle help now
        if command == 'help':
            if len(args)>1:
                self.do_help(args[1:])
                return 0
            self.do_help(['help'])
            return 0
        if command == 'morehelp':
            self.do_help(['help'])
            self.help_commands()
            self.help_all()
            return 0
        if command == 'config':
            self.do_config(args[1:])
            return 0

        # figure what the command is
        try:
            functions = self.commands.get(command)
        except KeyError:
            # not a valid command
            print _('Unknown command "%(command)s" ("help commands" for a '
                'list)')%locals()
            return 1

        # check for multiple matches
        if len(functions) > 1:
            print _('Multiple commands match "%(command)s": %(list)s')%{'command':
                command, 'list': ', '.join([i[0] for i in functions])}
            return 1
        command, function = functions[0]

        # make sure we have a tracker_home
        while not self.tracker_home:
            self.tracker_home = raw_input(_('Enter tracker home: ')).strip()

        # before we open the db, we may be doing an install or init
        if command == 'initialise':
            try:
                return self.do_initialise(self.tracker_home, args)
            except UsageError as message:
                print _('Error: %(message)s')%locals()
                return 1
        elif command == 'install':
            try:
                return self.do_install(self.tracker_home, args)
            except UsageError as message:
                print _('Error: %(message)s')%locals()
                return 1

        # get the tracker
        try:
            tracker = roundup.instance.open(self.tracker_home)
        except ValueError as message:
            self.tracker_home = ''
            print _("Error: Couldn't open tracker: %(message)s")%locals()
            return 1

        # only open the database once!
        if not self.db:
            self.db = tracker.open('admin')

        # do the command
        ret = 0
        try:
            ret = function(args[1:])
        except UsageError as message:
            print _('Error: %(message)s')%locals()
            print
            print function.__doc__
            ret = 1
        except:
            import traceback
            traceback.print_exc()
            ret = 1
        return ret

    def interactive(self):
        """Run in an interactive mode
        """
        print _('Roundup %s ready for input.\nType "help" for help.'
            % roundup_version)
        try:
            import readline
        except ImportError:
            print _('Note: command history and editing not available')

        while 1:
            try:
                command = raw_input(_('roundup> '))
            except EOFError:
                print _('exit...')
                break
            if not command: continue
            args = token.token_split(command)
            if not args: continue
            if args[0] in ('quit', 'exit'): break
            self.run_command(args)

        # exit.. check for transactions
        if self.db and self.db_uncommitted:
            commit = raw_input(_('There are unsaved changes. Commit them (y/N)? '))
            if commit and commit[0].lower() == 'y':
                self.db.commit()
        return 0

    def main(self):
        try:
            opts, args = getopt.getopt(sys.argv[1:], 'i:u:hcdsS:vV')
        except getopt.GetoptError as e:
            self.usage(str(e))
            return 1

        # handle command-line args
        self.tracker_home = os.environ.get('TRACKER_HOME', '')
        # TODO: reinstate the user/password stuff (-u arg too)
        name = password = ''
        if os.environ.has_key('ROUNDUP_LOGIN'):
            l = os.environ['ROUNDUP_LOGIN'].split(':')
            name = l[0]
            if len(l) > 1:
                password = l[1]
        self.separator = None
        self.print_designator = 0
        self.verbose = 0
        for opt, arg in opts:
            if opt == '-h':
                self.usage()
                return 0
            elif opt == '-v':
                print '%s (python %s)'%(roundup_version, sys.version.split()[0])
                return 0
            elif opt == '-V':
                self.verbose = 1
            elif opt == '-i':
                self.tracker_home = arg
            elif opt == '-c':
                if self.separator != None:
                    self.usage('Only one of -c, -S and -s may be specified')
                    return 1
                self.separator = ','
            elif opt == '-S':
                if self.separator != None:
                    self.usage('Only one of -c, -S and -s may be specified')
                    return 1
                self.separator = arg
            elif opt == '-s':
                if self.separator != None:
                    self.usage('Only one of -c, -S and -s may be specified')
                    return 1
                self.separator = ' '
            elif opt == '-d':
                self.print_designator = 1

        # if no command - go interactive
        # wrap in a try/finally so we always close off the db
        ret = 0
        try:
            if not args:
                self.interactive()
            else:
                ret = self.run_command(args)
                if self.db: self.db.commit()
            return ret
        finally:
            if self.db:
                self.db.close()

if __name__ == '__main__':
    tool = AdminTool()
    sys.exit(tool.main())

# vim: set filetype=python sts=4 sw=4 et si :

blob
mark :778
data 49776
#
# Copyright (c) 2001 Bizar Software Pty Ltd (http://www.bizarsoftware.com.au/)
# This module is free software, and you may redistribute it and/or modify
# under the same terms as Python, so long as this copyright message and
# disclaimer are retained in their original form.
#
# IN NO EVENT SHALL BIZAR SOFTWARE PTY LTD BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# BIZAR SOFTWARE PTY LTD SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
# BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS"
# BASIS, AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
# SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#

"""Hyperdatabase implementation, especially field types.
"""
__docformat__ = 'restructuredtext'

# standard python modules
import os, re, shutil, weakref
# Python 2.3 ... 2.6 compatibility:
from roundup.anypy.sets_ import set

# roundup modules
import date, password
from support import ensureParentsExist, PrioList, sorted, reversed
from roundup.i18n import _

#
# Types
#
class _Type(object):
    """A roundup property type."""
    def __init__(self, required=False):
        self.required = required
    def __repr__(self):
        ' more useful for dumps '
        return '<%s.%s>'%(self.__class__.__module__, self.__class__.__name__)
    def sort_repr (self, cls, val, name):
        """Representation used for sorting. This should be a python
        built-in type, otherwise sorting will take ages. Note that
        individual backends may chose to use something different for
        sorting as long as the outcome is the same.
        """
        return val

class String(_Type):
    """An object designating a String property."""
    def __init__(self, indexme='no', required=False):
        super(String, self).__init__(required)
        self.indexme = indexme == 'yes'
    def from_raw(self, value, propname='', **kw):
        """fix the CRLF/CR -> LF stuff"""
        if propname == 'content':
            # Why oh why wasn't the FileClass content property a File
            # type from the beginning?
            return value
        return fixNewlines(value)
    def sort_repr (self, cls, val, name):
        if not val:
            return val
        if name == 'id':
            return int(val)
        return val.lower()

class Password(_Type):
    """An object designating a Password property."""
    def from_raw(self, value, **kw):
        if not value:
            return None
        m = password.Password.pwre.match(value)
        if m:
            # password is being given to us encrypted
            p = password.Password()
            p.scheme = m.group(1)
            if p.scheme not in 'SHA crypt plaintext'.split():
                raise HyperdbValueError, \
                        ('property %s: unknown encryption scheme %r') %\
                        (kw['propname'], p.scheme)
            p.password = m.group(2)
            value = p
        else:
            try:
                value = password.Password(value)
            except password.PasswordValueError as message:
                raise HyperdbValueError, \
                        _('property %s: %s')%(kw['propname'], message)
        return value
    def sort_repr (self, cls, val, name):
        if not val:
            return val
        return str(val)

class Date(_Type):
    """An object designating a Date property."""
    def __init__(self, offset=None, required=False):
        super(Date, self).__init__(required)
        self._offset = offset
    def offset(self, db):
        if self._offset is not None:
            return self._offset
        return db.getUserTimezone()
    def from_raw(self, value, db, **kw):
        try:
            value = date.Date(value, self.offset(db))
        except ValueError as message:
            raise HyperdbValueError, _('property %s: %r is an invalid '\
                'date (%s)')%(kw['propname'], value, message)
        return value
    def range_from_raw(self, value, db):
        """return Range value from given raw value with offset correction"""
        return date.Range(value, date.Date, offset=self.offset(db))
    def sort_repr (self, cls, val, name):
        if not val:
            return val
        return str(val)

class Interval(_Type):
    """An object designating an Interval property."""
    def from_raw(self, value, **kw):
        try:
            value = date.Interval(value)
        except ValueError as message:
            raise HyperdbValueError, _('property %s: %r is an invalid '\
                'date interval (%s)')%(kw['propname'], value, message)
        return value
    def sort_repr (self, cls, val, name):
        if not val:
            return val
        return val.as_seconds()

class _Pointer(_Type):
    """An object designating a Pointer property that links or multilinks
    to a node in a specified class."""
    def __init__(self, classname, do_journal='yes', required=False):
        """ Default is to journal link and unlink events
        """
        super(_Pointer, self).__init__(required)
        self.classname = classname
        self.do_journal = do_journal == 'yes'
    def __repr__(self):
        """more useful for dumps. But beware: This is also used in schema
        storage in SQL backends!
        """
        return '<%s.%s to "%s">'%(self.__class__.__module__,
            self.__class__.__name__, self.classname)

class Link(_Pointer):
    """An object designating a Link property that links to a
       node in a specified class."""
    def from_raw(self, value, db, propname, **kw):
        if value == '-1' or not value:
            value = None
        else:
            value = convertLinkValue(db, propname, self, value)
        return value
    def sort_repr (self, cls, val, name):
        if not val:
            return val
        op = cls.labelprop()
        if op == 'id':
            return int(cls.get(val, op))
        return cls.get(val, op)

class Multilink(_Pointer):
    """An object designating a Multilink property that links
       to nodes in a specified class.

       "classname" indicates the class to link to

       "do_journal" indicates whether the linked-to nodes should have
                    'link' and 'unlink' events placed in their journal
    """
    def from_raw(self, value, db, klass, propname, itemid, **kw):
        if not value:
            return []

        # get the current item value if it's not a new item
        if itemid and not itemid.startswith('-'):
            curvalue = klass.get(itemid, propname)
        else:
            curvalue = []

        # if the value is a comma-separated string then split it now
        if isinstance(value, type('')):
            value = value.split(',')

        # handle each add/remove in turn
        # keep an extra list for all items that are
        # definitely in the new list (in case of e.g.
        # <propname>=A,+B, which should replace the old
        # list with A,B)
        do_set = 1
        newvalue = []
        for item in value:
            item = item.strip()

            # skip blanks
            if not item: continue

            # handle +/-
            remove = 0
            if item.startswith('-'):
                remove = 1
                item = item[1:]
                do_set = 0
            elif item.startswith('+'):
                item = item[1:]
                do_set = 0

            # look up the value
            itemid = convertLinkValue(db, propname, self, item)

            # perform the add/remove
            if remove:
                try:
                    curvalue.remove(itemid)
                except ValueError:
                    raise HyperdbValueError, _('property %s: %r is not ' \
                        'currently an element')%(propname, item)
            else:
                newvalue.append(itemid)
                if itemid not in curvalue:
                    curvalue.append(itemid)

        # that's it, set the new Multilink property value,
        # or overwrite it completely
        if do_set:
            value = newvalue
        else:
            value = curvalue

        # TODO: one day, we'll switch to numeric ids and this will be
        # unnecessary :(
        value = [int(x) for x in value]
        value.sort()
        value = [str(x) for x in value]
        return value

    def sort_repr (self, cls, val, name):
        if not val:
            return val
        op = cls.labelprop()
        if op == 'id':
            return [int(cls.get(v, op)) for v in val]
        return [cls.get(v, op) for v in val]

class Boolean(_Type):
    """An object designating a boolean property"""
    def from_raw(self, value, **kw):
        value = value.strip()
        # checked is a common HTML checkbox value
        value = value.lower() in ('checked', 'yes', 'true', 'on', '1')
        return value

class Number(_Type):
    """An object designating a numeric property"""
    def from_raw(self, value, **kw):
        value = value.strip()
        try:
            value = float(value)
        except ValueError:
            raise HyperdbValueError, _('property %s: %r is not a number')%(
                kw['propname'], value)
        return value
#
# Support for splitting designators
#
class DesignatorError(ValueError):
    pass
def splitDesignator(designator, dre=re.compile(r'([^\d]+)(\d+)')):
    """ Take a foo123 and return ('foo', 123)
    """
    m = dre.match(designator)
    if m is None:
        raise DesignatorError, _('"%s" not a node designator')%designator
    return m.group(1), m.group(2)

class Proptree(object):
    """ Simple tree data structure for optimizing searching of
    properties. Each node in the tree represents a roundup Class
    Property that has to be navigated for finding the given search
    or sort properties. The sort_type attribute is used for
    distinguishing nodes in the tree used for sorting or searching: If
    it is 0 for a node, that node is not used for sorting. If it is 1,
    it is used for both, sorting and searching. If it is 2 it is used
    for sorting only.

    The Proptree is also used for transitively searching attributes for
    backends that do not support transitive search (e.g. anydbm). The
    _val attribute with set_val is used for this.
    """

    def __init__(self, db, cls, name, props, parent = None):
        self.db = db
        self.name = name
        self.props = props
        self.parent = parent
        self._val = None
        self.has_values = False
        self.cls = cls
        self.classname = None
        self.uniqname = None
        self.children = []
        self.sortattr = []
        self.propdict = {}
        self.sort_type = 0
        self.sort_direction = None
        self.sort_ids = None
        self.sort_ids_needed = False
        self.sort_result = None
        self.attr_sort_done = False
        self.tree_sort_done = False
        self.propclass = None
        self.orderby = []
        if parent:
            self.root = parent.root
            self.depth = parent.depth + 1
        else:
            self.root = self
            self.seqno = 1
            self.depth = 0
            self.sort_type = 1
        self.id = self.root.seqno
        self.root.seqno += 1
        if self.cls:
            self.classname = self.cls.classname
            self.uniqname = '%s%s' % (self.cls.classname, self.id)
        if not self.parent:
            self.uniqname = self.cls.classname

    def append(self, name, sort_type = 0):
        """Append a property to self.children. Will create a new
        propclass for the child.
        """
        if name in self.propdict:
            pt = self.propdict[name]
            if sort_type and not pt.sort_type:
                pt.sort_type = 1
            return pt
        propclass = self.props[name]
        cls = None
        props = None
        if isinstance(propclass, (Link, Multilink)):
            cls = self.db.getclass(propclass.classname)
            props = cls.getprops()
        child = self.__class__(self.db, cls, name, props, parent = self)
        child.sort_type = sort_type
        child.propclass = propclass
        self.children.append(child)
        self.propdict[name] = child
        return child

    def compute_sort_done(self, mlseen=False):
        """ Recursively check if attribute is needed for sorting
        (self.sort_type > 0) or all children have tree_sort_done set and
        sort_ids_needed unset: set self.tree_sort_done if one of the conditions
        holds. Also remove sort_ids_needed recursively once having seen a
        Multilink.
        """
        if isinstance (self.propclass, Multilink):
            mlseen = True
        if mlseen:
            self.sort_ids_needed = False
        self.tree_sort_done = True
        for p in self.children:
            p.compute_sort_done(mlseen)
            if not p.tree_sort_done:
                self.tree_sort_done = False
        if not self.sort_type:
            self.tree_sort_done = True
        if mlseen:
            self.tree_sort_done = False

    def ancestors(self):
        p = self
        while p.parent:
            yield p
            p = p.parent

    def search(self, search_matches=None, sort=True):
        """ Recursively search for the given properties in a proptree.
        Once all properties are non-transitive, the search generates a
        simple _filter call which does the real work
        """
        filterspec = {}
        for p in self.children:
            if p.sort_type < 2:
                if p.children:
                    p.search(sort = False)
                filterspec[p.name] = p.val
        self.val = self.cls._filter(search_matches, filterspec, sort and self)
        return self.val

    def sort (self, ids=None):
        """ Sort ids by the order information stored in self. With
        optimisations: Some order attributes may be precomputed (by the
        backend) and some properties may already be sorted.
        """
        if ids is None:
            ids = self.val
        if self.sortattr and [s for s in self.sortattr if not s.attr_sort_done]:
            return self._searchsort(ids, True, True)
        return ids

    def sortable_children(self, intermediate=False):
        """ All children needed for sorting. If intermediate is True,
        intermediate nodes (not being a sort attribute) are returned,
        too.
        """
        return [p for p in self.children
                if p.sort_type > 0 and (intermediate or p.sort_direction)]

    def __iter__(self):
        """ Yield nodes in depth-first order -- visited nodes first """
        for p in self.children:
            yield p
            for c in p:
                yield c

    def _get (self, ids):
        """Lookup given ids -- possibly a list of list. We recurse until
        we have a list of ids.
        """
        if not ids:
            return ids
        if isinstance (ids[0], list):
            cids = [self._get(i) for i in ids]
        else:
            cids = [i and self.parent.cls.get(i, self.name) for i in ids]
            if self.sortattr:
                cids = [self._searchsort(i, False, True) for i in cids]
        return cids

    def _searchsort(self, ids=None, update=True, dosort=True):
        """ Recursively compute the sort attributes. Note that ids
        may be a deeply nested list of lists of ids if several
        multilinks are encountered on the way from the root to an
        individual attribute. We make sure that everything is properly
        sorted on the way up. Note that the individual backend may
        already have precomputed self.result or self.sort_ids. In this
        case we do nothing for existing sa.result and recurse further if
        self.sort_ids is available.

        Yech, Multilinks: This gets especially complicated if somebody
        sorts by different attributes of the same multilink (or
        transitively across several multilinks). My use-case is sorting
        by issue.messages.author and (reverse) by issue.messages.date.
        In this case we sort the messages by author and date and use
        this sorted list twice for sorting issues. This means that
        issues are sorted by author and then by the time of the messages
        *of this author*. Probably what the user intends in that case,
        so we do *not* use two sorted lists of messages, one sorted by
        author and one sorted by date for sorting issues.
        """
        for pt in self.sortable_children(intermediate = True):
            # ids can be an empty list
            if pt.tree_sort_done or not ids:
                continue
            if pt.sort_ids: # cached or computed by backend
                cids = pt.sort_ids
            else:
                cids = pt._get(ids)
            if pt.sort_direction and not pt.sort_result:
                sortrep = pt.propclass.sort_repr
                pt.sort_result = pt._sort_repr(sortrep, cids)
            pt.sort_ids = cids
            if pt.children:
                pt._searchsort(cids, update, False)
        if self.sortattr and dosort:
            ids = self._sort(ids)
        if not update:
            for pt in self.sortable_children(intermediate = True):
                pt.sort_ids = None
            for pt in self.sortattr:
                pt.sort_result = None
        return ids

    def _set_val(self, val):
        """Check if self._val is already defined. If yes, we compute the
        intersection of the old and the new value(s)
        """
        if self.has_values:
            v = self._val
            if not isinstance(self._val, type([])):
                v = [self._val]
            vals = set(v)
            vals.intersection_update(val)
            self._val = [v for v in vals]
        else:
            self._val = val
        self.has_values = True

    val = property(lambda self: self._val, _set_val)

    def _sort(self, val):
        """Finally sort by the given sortattr.sort_result. Note that we
        do not sort by attrs having attr_sort_done set. The caller is
        responsible for setting attr_sort_done only for trailing
        attributes (otherwise the sort order is wrong). Since pythons
        sort is stable, we can sort already sorted lists without
        destroying the sort-order for items that compare equal with the
        current sort.

        Sorting-Strategy: We sort repeatedly by different sort-keys from
        right to left. Since pythons sort is stable, we can safely do
        that. An optimisation is a "run-length encoding" of the
        sort-directions: If several sort attributes sort in the same
        direction we can combine them into a single sort. Note that
        repeated sorting is probably more efficient than using
        compare-methods in python due to the overhead added by compare
        methods.
        """
        if not val:
            return val
        sortattr = []
        directions = []
        dir_idx = []
        idx = 0
        curdir = None
        for sa in self.sortattr:
            if sa.attr_sort_done:
                break
            if sortattr:
                assert len(sortattr[0]) == len(sa.sort_result)
            sortattr.append (sa.sort_result)
            if curdir != sa.sort_direction:
                dir_idx.append (idx)
                directions.append (sa.sort_direction)
                curdir = sa.sort_direction
            idx += 1
        sortattr.append (val)
        #print >> sys.stderr, "\nsortattr", sortattr
        sortattr = zip (*sortattr)
        for dir, i in reversed(zip(directions, dir_idx)):
            rev = dir == '-'
            sortattr = sorted (sortattr, key = lambda x:x[i:idx], reverse = rev)
            idx = i
        return [x[-1] for x in sortattr]

    def _sort_repr(self, sortrep, ids):
        """Call sortrep for given ids -- possibly a list of list. We
        recurse until we have a list of ids.
        """
        if not ids:
            return ids
        if isinstance (ids[0], list):
            res = [self._sort_repr(sortrep, i) for i in ids]
        else:
            res = [sortrep(self.cls, i, self.name) for i in ids]
        return res

    def __repr__(self):
        r = ["proptree:" + self.name]
        for n in self:
            r.append("proptree:" + "    " * n.depth + n.name)
        return '\n'.join(r)
    __str__ = __repr__

#
# the base Database class
#
class DatabaseError(ValueError):
    """Error to be raised when there is some problem in the database code
    """
    pass
class Database:
    """A database for storing records containing flexible data types.

This class defines a hyperdatabase storage layer, which the Classes use to
store their data.


Transactions
------------
The Database should support transactions through the commit() and
rollback() methods. All other Database methods should be transaction-aware,
using data from the current transaction before looking up the database.

An implementation must provide an override for the get() method so that the
in-database value is returned in preference to the in-transaction value.
This is necessary to determine if any values have changed during a
transaction.


Implementation
--------------

All methods except __repr__ must be implemented by a concrete backend Database.

"""

    # flag to set on retired entries
    RETIRED_FLAG = '__hyperdb_retired'

    BACKEND_MISSING_STRING = None
    BACKEND_MISSING_NUMBER = None
    BACKEND_MISSING_BOOLEAN = None

    def __init__(self, config, journaltag=None):
        """Open a hyperdatabase given a specifier to some storage.

        The 'storagelocator' is obtained from config.DATABASE.
        The meaning of 'storagelocator' depends on the particular
        implementation of the hyperdatabase.  It could be a file name,
        a directory path, a socket descriptor for a connection to a
        database over the network, etc.

        The 'journaltag' is a token that will be attached to the journal
        entries for any edits done on the database.  If 'journaltag' is
        None, the database is opened in read-only mode: the Class.create(),
        Class.set(), and Class.retire() methods are disabled.
        """
        raise NotImplementedError

    def post_init(self):
        """Called once the schema initialisation has finished.
           If 'refresh' is true, we want to rebuild the backend
           structures.
        """
        raise NotImplementedError

    def refresh_database(self):
        """Called to indicate that the backend should rebuild all tables
           and structures. Not called in normal usage."""
        raise NotImplementedError

    def __getattr__(self, classname):
        """A convenient way of calling self.getclass(classname)."""
        raise NotImplementedError

    def addclass(self, cl):
        """Add a Class to the hyperdatabase.
        """
        raise NotImplementedError

    def getclasses(self):
        """Return a list of the names of all existing classes."""
        raise NotImplementedError

    def getclass(self, classname):
        """Get the Class object representing a particular class.

        If 'classname' is not a valid class name, a KeyError is raised.
        """
        raise NotImplementedError

    def clear(self):
        """Delete all database contents.
        """
        raise NotImplementedError

    def getclassdb(self, classname, mode='r'):
        """Obtain a connection to the class db that will be used for
           multiple actions.
        """
        raise NotImplementedError

    def addnode(self, classname, nodeid, node):
        """Add the specified node to its class's db.
        """
        raise NotImplementedError

    def serialise(self, classname, node):
        """Copy the node contents, converting non-marshallable data into
           marshallable data.
        """
        return node

    def setnode(self, classname, nodeid, node):
        """Change the specified node.
        """
        raise NotImplementedError

    def unserialise(self, classname, node):
        """Decode the marshalled node data
        """
        return node

    def getnode(self, classname, nodeid):
        """Get a node from the database.

        'cache' exists for backwards compatibility, and is not used.
        """
        raise NotImplementedError

    def hasnode(self, classname, nodeid):
        """Determine if the database has a given node.
        """
        raise NotImplementedError

    def countnodes(self, classname):
        """Count the number of nodes that exist for a particular Class.
        """
        raise NotImplementedError

    def storefile(self, classname, nodeid, property, content):
        """Store the content of the file in the database.

           The property may be None, in which case the filename does not
           indicate which property is being saved.
        """
        raise NotImplementedError

    def getfile(self, classname, nodeid, property):
        """Get the content of the file in the database.
        """
        raise NotImplementedError

    def addjournal(self, classname, nodeid, action, params):
        """ Journal the Action
        'action' may be:

            'create' or 'set' -- 'params' is a dictionary of property values
            'link' or 'unlink' -- 'params' is (classname, nodeid, propname)
            'retire' -- 'params' is None
        """
        raise NotImplementedError

    def getjournal(self, classname, nodeid):
        """ get the journal for id
        """
        raise NotImplementedError

    def pack(self, pack_before):
        """ pack the database
        """
        raise NotImplementedError

    def commit(self):
        """ Commit the current transactions.

        Save all data changed since the database was opened or since the
        last commit() or rollback().

        fail_ok indicates that the commit is allowed to fail. This is used
        in the web interface when committing cleaning of the session
        database. We don't care if there's a concurrency issue there.

        The only backend this seems to affect is postgres.
        """
        raise NotImplementedError

    def rollback(self):
        """ Reverse all actions from the current transaction.

        Undo all the changes made since the database was opened or the last
        commit() or rollback() was performed.
        """
        raise NotImplementedError

    def close(self):
        """Close the database.

        This method must be called at the end of processing.

        """

#
# The base Class class
#
class Class:
    """ The handle to a particular class of nodes in a hyperdatabase.

        All methods except __repr__ and getnode must be implemented by a
        concrete backend Class.
    """

    def __init__(self, db, classname, **properties):
        """Create a new class with a given name and property specification.

        'classname' must not collide with the name of an existing class,
        or a ValueError is raised.  The keyword arguments in 'properties'
        must map names to property objects, or a TypeError is raised.
        """
        for name in 'creation activity creator actor'.split():
            if properties.has_key(name):
                raise ValueError, '"creation", "activity", "creator" and '\
                    '"actor" are reserved'

        self.classname = classname
        self.properties = properties
        self.db = weakref.proxy(db)       # use a weak ref to avoid circularity
        self.key = ''

        # should we journal changes (default yes)
        self.do_journal = 1

        # do the db-related init stuff
        db.addclass(self)

        actions = "create set retire restore".split()
        self.auditors = dict([(a, PrioList()) for a in actions])
        self.reactors = dict([(a, PrioList()) for a in actions])

    def __repr__(self):
        """Slightly more useful representation
        """
        return '<hyperdb.Class "%s">'%self.classname

    # Editing nodes:

    def create(self, **propvalues):
        """Create a new node of this class and return its id.

        The keyword arguments in 'propvalues' map property names to values.

        The values of arguments must be acceptable for the types of their
        corresponding properties or a TypeError is raised.

        If this class has a key property, it must be present and its value
        must not collide with other key strings or a ValueError is raised.

        Any other properties on this class that are missing from the
        'propvalues' dictionary are set to None.

        If an id in a link or multilink property does not refer to a valid
        node, an IndexError is raised.
        """
        raise NotImplementedError

    _marker = []
    def get(self, nodeid, propname, default=_marker, cache=1):
        """Get the value of a property on an existing node of this class.

        'nodeid' must be the id of an existing node of this class or an
        IndexError is raised.  'propname' must be the name of a property
        of this class or a KeyError is raised.

        'cache' exists for backwards compatibility, and is not used.
        """
        raise NotImplementedError

    # not in spec
    def getnode(self, nodeid):
        """ Return a convenience wrapper for the node.

        'nodeid' must be the id of an existing node of this class or an
        IndexError is raised.

        'cache' exists for backwards compatibility, and is not used.
        """
        return Node(self, nodeid)

    def getnodeids(self, retired=None):
        """Retrieve all the ids of the nodes for a particular Class.
        """
        raise NotImplementedError

    def set(self, nodeid, **propvalues):
        """Modify a property on an existing node of this class.

        'nodeid' must be the id of an existing node of this class or an
        IndexError is raised.

        Each key in 'propvalues' must be the name of a property of this
        class or a KeyError is raised.

        All values in 'propvalues' must be acceptable types for their
        corresponding properties or a TypeError is raised.

        If the value of the key property is set, it must not collide with
        other key strings or a ValueError is raised.

        If the value of a Link or Multilink property contains an invalid
        node id, a ValueError is raised.
        """
        raise NotImplementedError

    def retire(self, nodeid):
        """Retire a node.

        The properties on the node remain available from the get() method,
        and the node's id is never reused.

        Retired nodes are not returned by the find(), list(), or lookup()
        methods, and other nodes may reuse the values of their key properties.
        """
        raise NotImplementedError

    def restore(self, nodeid):
        """Restpre a retired node.

        Make node available for all operations like it was before retirement.
        """
        raise NotImplementedError

    def is_retired(self, nodeid):
        """Return true if the node is rerired
        """
        raise NotImplementedError

    def destroy(self, nodeid):
        """Destroy a node.

        WARNING: this method should never be used except in extremely rare
                 situations where there could never be links to the node being
                 deleted

        WARNING: use retire() instead

        WARNING: the properties of this node will not be available ever again

        WARNING: really, use retire() instead

        Well, I think that's enough warnings. This method exists mostly to
        support the session storage of the cgi interface.

        The node is completely removed from the hyperdb, including all journal
        entries. It will no longer be available, and will generally break code
        if there are any references to the node.
        """

    def history(self, nodeid):
        """Retrieve the journal of edits on a particular node.

        'nodeid' must be the id of an existing node of this class or an
        IndexError is raised.

        The returned list contains tuples of the form

            (date, tag, action, params)

        'date' is a Timestamp object specifying the time of the change and
        'tag' is the journaltag specified when the database was opened.
        """
        raise NotImplementedError

    # Locating nodes:
    def hasnode(self, nodeid):
        """Determine if the given nodeid actually exists
        """
        raise NotImplementedError

    def setkey(self, propname):
        """Select a String property of this class to be the key property.

        'propname' must be the name of a String property of this class or
        None, or a TypeError is raised.  The values of the key property on
        all existing nodes must be unique or a ValueError is raised.
        """
        raise NotImplementedError

    def setlabelprop(self, labelprop):
        """Set the label property. Used for override of labelprop
           resolution order.
        """
        if labelprop not in self.getprops():
            raise ValueError, _("Not a property name: %s") % labelprop
        self._labelprop = labelprop

    def setorderprop(self, orderprop):
        """Set the order property. Used for override of orderprop
           resolution order
        """
        if orderprop not in self.getprops():
            raise ValueError, _("Not a property name: %s") % orderprop
        self._orderprop = orderprop

    def getkey(self):
        """Return the name of the key property for this class or None."""
        raise NotImplementedError

    def labelprop(self, default_to_id=0):
        """Return the property name for a label for the given node.

        This method attempts to generate a consistent label for the node.
        It tries the following in order:

        0. self._labelprop if set
        1. key property
        2. "name" property
        3. "title" property
        4. first property from the sorted property name list
        """
        if hasattr(self, '_labelprop'):
            return self._labelprop
        k = self.getkey()
        if  k:
            return k
        props = self.getprops()
        if props.has_key('name'):
            return 'name'
        elif props.has_key('title'):
            return 'title'
        if default_to_id:
            return 'id'
        props = props.keys()
        props.sort()
        return props[0]

    def orderprop(self):
        """Return the property name to use for sorting for the given node.

        This method computes the property for sorting.
        It tries the following in order:

        0. self._orderprop if set
        1. "order" property
        2. self.labelprop()
        """

        if hasattr(self, '_orderprop'):
            return self._orderprop
        props = self.getprops()
        if props.has_key('order'):
            return 'order'
        return self.labelprop()

    def lookup(self, keyvalue):
        """Locate a particular node by its key property and return its id.

        If this class has no key property, a TypeError is raised.  If the
        'keyvalue' matches one of the values for the key property among
        the nodes in this class, the matching node's id is returned;
        otherwise a KeyError is raised.
        """
        raise NotImplementedError

    def find(self, **propspec):
        """Get the ids of nodes in this class which link to the given nodes.

        'propspec' consists of keyword args propname={nodeid:1,}
        'propname' must be the name of a property in this class, or a
        KeyError is raised.  That property must be a Link or Multilink
        property, or a TypeError is raised.

        Any node in this class whose 'propname' property links to any of the
        nodeids will be returned. Used by the full text indexing, which knows
        that "foo" occurs in msg1, msg3 and file7, so we have hits on these
        issues:

            db.issue.find(messages={'1':1,'3':1}, files={'7':1})
        """
        raise NotImplementedError

    def _filter(self, search_matches, filterspec, sort=(None,None),
            group=(None,None)):
        """For some backends this implements the non-transitive
        search, for more information see the filter method.
        """
        raise NotImplementedError

    def _proptree(self, filterspec, sortattr=[]):
        """Build a tree of all transitive properties in the given
        filterspec.
        """
        proptree = Proptree(self.db, self, '', self.getprops())
        for key, v in filterspec.iteritems():
            keys = key.split('.')
            p = proptree
            for k in keys:
                p = p.append(k)
            p.val = v
        multilinks = {}
        for s in sortattr:
            keys = s[1].split('.')
            p = proptree
            for k in keys:
                p = p.append(k, sort_type = 2)
                if isinstance (p.propclass, Multilink):
                    multilinks[p] = True
            if p.cls:
                p = p.append(p.cls.orderprop(), sort_type = 2)
            if p.sort_direction: # if an orderprop is also specified explicitly
                continue
            p.sort_direction = s[0]
            proptree.sortattr.append (p)
        for p in multilinks.iterkeys():
            sattr = {}
            for c in p:
                if c.sort_direction:
                    sattr [c] = True
            for sa in proptree.sortattr:
                if sa in sattr:
                    p.sortattr.append (sa)
        return proptree

    def get_transitive_prop(self, propname_path, default = None):
        """Expand a transitive property (individual property names
        separated by '.' into a new property at the end of the path. If
        one of the names does not refer to a valid property, we return
        None.
        Example propname_path (for class issue): "messages.author"
        """
        props = self.db.getclass(self.classname).getprops()
        for k in propname_path.split('.'):
            try:
                prop = props[k]
            except KeyError as TypeError:
                return default
            cl = getattr(prop, 'classname', None)
            props = None
            if cl:
                props = self.db.getclass(cl).getprops()
        return prop

    def _sortattr(self, sort=[], group=[]):
        """Build a single list of sort attributes in the correct order
        with sanity checks (no duplicate properties) included. Always
        sort last by id -- if id is not already in sortattr.
        """
        seen = {}
        sortattr = []
        for srt in group, sort:
            if not isinstance(srt, list):
                srt = [srt]
            for s in srt:
                if s[1] and s[1] not in seen:
                    sortattr.append((s[0] or '+', s[1]))
                    seen[s[1]] = True
        if 'id' not in seen :
            sortattr.append(('+', 'id'))
        return sortattr

    def filter(self, search_matches, filterspec, sort=[], group=[]):
        """Return a list of the ids of the active nodes in this class that
        match the 'filter' spec, sorted by the group spec and then the
        sort spec.

        "filterspec" is {propname: value(s)}

        "sort" and "group" are [(dir, prop), ...] where dir is '+', '-'
        or None and prop is a prop name or None. Note that for
        backward-compatibility reasons a single (dir, prop) tuple is
        also allowed.

        "search_matches" is a container type

        The filter must match all properties specificed. If the property
        value to match is a list:

        1. String properties must match all elements in the list, and
        2. Other properties must match any of the elements in the list.

        Note that now the propname in filterspec and prop in a
        sort/group spec may be transitive, i.e., it may contain
        properties of the form link.link.link.name, e.g. you can search
        for all issues where a message was added by a certain user in
        the last week with a filterspec of
        {'messages.author' : '42', 'messages.creation' : '.-1w;'}

        Implementation note:
        This implements a non-optimized version of Transitive search
        using _filter implemented in a backend class. A more efficient
        version can be implemented in the individual backends -- e.g.,
        an SQL backen will want to create a single SQL statement and
        override the filter method instead of implementing _filter.
        """
        sortattr = self._sortattr(sort = sort, group = group)
        proptree = self._proptree(filterspec, sortattr)
        proptree.search(search_matches)
        return proptree.sort()

    def count(self):
        """Get the number of nodes in this class.

        If the returned integer is 'numnodes', the ids of all the nodes
        in this class run from 1 to numnodes, and numnodes+1 will be the
        id of the next node to be created in this class.
        """
        raise NotImplementedError

    # Manipulating properties:
    def getprops(self, protected=1):
        """Return a dictionary mapping property names to property objects.
           If the "protected" flag is true, we include protected properties -
           those which may not be modified.
        """
        raise NotImplementedError

    def get_required_props(self, propnames = []):
        """Return a dict of property names mapping to property objects.
        All properties that have the "required" flag set will be
        returned in addition to all properties in the propnames
        parameter.
        """
        props = self.getprops(protected = False)
        pdict = dict([(p, props[p]) for p in propnames])
        pdict.update([(k, v) for k, v in props.iteritems() if v.required])
        return pdict

    def addprop(self, **properties):
        """Add properties to this class.

        The keyword arguments in 'properties' must map names to property
        objects, or a TypeError is raised.  None of the keys in 'properties'
        may collide with the names of existing properties, or a ValueError
        is raised before any properties have been added.
        """
        raise NotImplementedError

    def index(self, nodeid):
        """Add (or refresh) the node to search indexes"""
        raise NotImplementedError

    #
    # Detector interface
    #
    def audit(self, event, detector, priority = 100):
        """Register an auditor detector"""
        self.auditors[event].append((priority, detector.__name__, detector))

    def fireAuditors(self, event, nodeid, newvalues):
        """Fire all registered auditors"""
        for prio, name, audit in self.auditors[event]:
            audit(self.db, self, nodeid, newvalues)

    def react(self, event, detector, priority = 100):
        """Register a reactor detector"""
        self.reactors[event].append((priority, detector.__name__, detector))

    def fireReactors(self, event, nodeid, oldvalues):
        """Fire all registered reactors"""
        for prio, name, react in self.reactors[event]:
            react(self.db, self, nodeid, oldvalues)

    #
    # import / export support
    #
    def export_propnames(self):
        """List the property names for export from this Class"""
        propnames = self.getprops().keys()
        propnames.sort()
        return propnames


class HyperdbValueError(ValueError):
    """ Error converting a raw value into a Hyperdb value """
    pass

def convertLinkValue(db, propname, prop, value, idre=re.compile('^\d+$')):
    """ Convert the link value (may be id or key value) to an id value. """
    linkcl = db.classes[prop.classname]
    if not idre.match(value):
        if linkcl.getkey():
            try:
                value = linkcl.lookup(value)
            except KeyError as message:
                raise HyperdbValueError, _('property %s: %r is not a %s.')%(
                    propname, value, prop.classname)
        else:
            raise HyperdbValueError, _('you may only enter ID values '\
                'for property %s')%propname
    return value

def fixNewlines(text):
    """ Homogenise line endings.

        Different web clients send different line ending values, but
        other systems (eg. email) don't necessarily handle those line
        endings. Our solution is to convert all line endings to LF.
    """
    text = text.replace('\r\n', '\n')
    return text.replace('\r', '\n')

def rawToHyperdb(db, klass, itemid, propname, value, **kw):
    """ Convert the raw (user-input) value to a hyperdb-storable value. The
        value is for the "propname" property on itemid (may be None for a
        new item) of "klass" in "db".

        The value is usually a string, but in the case of multilink inputs
        it may be either a list of strings or a string with comma-separated
        values.
    """
    properties = klass.getprops()

    # ensure it's a valid property name
    propname = propname.strip()
    try:
        proptype =  properties[propname]
    except KeyError:
        raise HyperdbValueError, _('%r is not a property of %s')%(propname,
            klass.classname)

    # if we got a string, strip it now
    if isinstance(value, type('')):
        value = value.strip()

    # convert the input value to a real property value
    value = proptype.from_raw(value, db=db, klass=klass,
        propname=propname, itemid=itemid, **kw)

    return value

class FileClass:
    """ A class that requires the "content" property and stores it on
        disk.
    """
    default_mime_type = 'text/plain'

    def __init__(self, db, classname, **properties):
        """The newly-created class automatically includes the "content"
        property.
        """
        if not properties.has_key('content'):
            properties['content'] = String(indexme='yes')

    def export_propnames(self):
        """ Don't export the "content" property
        """
        propnames = self.getprops().keys()
        propnames.remove('content')
        propnames.sort()
        return propnames

    def exportFilename(self, dirname, nodeid):
        subdir_filename = self.db.subdirFilename(self.classname, nodeid)
        return os.path.join(dirname, self.classname+'-files', subdir_filename)

    def export_files(self, dirname, nodeid):
        """ Export the "content" property as a file, not csv column
        """
        source = self.db.filename(self.classname, nodeid)

        dest = self.exportFilename(dirname, nodeid)
        ensureParentsExist(dest)
        shutil.copyfile(source, dest)

    def import_files(self, dirname, nodeid):
        """ Import the "content" property as a file
        """
        source = self.exportFilename(dirname, nodeid)

        dest = self.db.filename(self.classname, nodeid, create=1)
        ensureParentsExist(dest)
        shutil.copyfile(source, dest)

        mime_type = None
        props = self.getprops()
        if props.has_key('type'):
            mime_type = self.get(nodeid, 'type')
        if not mime_type:
            mime_type = self.default_mime_type
        if props['content'].indexme:
            self.db.indexer.add_text((self.classname, nodeid, 'content'),
                self.get(nodeid, 'content'), mime_type)

class Node:
    """ A convenience wrapper for the given node
    """
    def __init__(self, cl, nodeid, cache=1):
        self.__dict__['cl'] = cl
        self.__dict__['nodeid'] = nodeid
    def keys(self, protected=1):
        return self.cl.getprops(protected=protected).keys()
    def values(self, protected=1):
        l = []
        for name in self.cl.getprops(protected=protected).keys():
            l.append(self.cl.get(self.nodeid, name))
        return l
    def items(self, protected=1):
        l = []
        for name in self.cl.getprops(protected=protected).keys():
            l.append((name, self.cl.get(self.nodeid, name)))
        return l
    def has_key(self, name):
        return self.cl.getprops().has_key(name)
    def get(self, name, default=None):
        if self.has_key(name):
            return self[name]
        else:
            return default
    def __getattr__(self, name):
        if self.__dict__.has_key(name):
            return self.__dict__[name]
        try:
            return self.cl.get(self.nodeid, name)
        except KeyError as value:
            # we trap this but re-raise it as AttributeError - all other
            # exceptions should pass through untrapped
            pass
        # nope, no such attribute
        raise AttributeError, str(value)
    def __getitem__(self, name):
        return self.cl.get(self.nodeid, name)
    def __setattr__(self, name, value):
        try:
            return self.cl.set(self.nodeid, **{name: value})
        except KeyError as value:
            raise AttributeError, str(value)
    def __setitem__(self, name, value):
        self.cl.set(self.nodeid, **{name: value})
    def history(self):
        return self.cl.history(self.nodeid)
    def retire(self):
        return self.cl.retire(self.nodeid)


def Choice(name, db, *options):
    """Quick helper to create a simple class with choices
    """
    cl = Class(db, name, name=String(), order=String())
    for i in range(len(options)):
        cl.create(name=options[i], order=i)
    return Link(name)

# vim: set filetype=python sts=4 sw=4 et si :

blob
mark :779
data 6397
#
# Copyright (c) 2001 Bizar Software Pty Ltd (http://www.bizarsoftware.com.au/)
# This module is free software, and you may redistribute it and/or modify
# under the same terms as Python, so long as this copyright message and
# disclaimer are retained in their original form.
#
# IN NO EVENT SHALL BIZAR SOFTWARE PTY LTD BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# BIZAR SOFTWARE PTY LTD SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
# BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS"
# BASIS, AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
# SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#
# $Id: init.py,v 1.36 2005-12-03 11:22:50 a1s Exp $

"""Init (create) a roundup instance.
"""
__docformat__ = 'restructuredtext'

import os, errno, rfc822

from roundup import install_util, password
from roundup.configuration import CoreConfig
from roundup.i18n import _

def copytree(src, dst, symlinks=0):
    """Recursively copy a directory tree using copyDigestedFile().

    The destination directory is allowed to exist.

    If the optional symlinks flag is true, symbolic links in the
    source tree result in symbolic links in the destination tree; if
    it is false, the contents of the files pointed to by symbolic
    links are copied.

    This was copied from shutil.py in std lib.
    """

    # Prevent 'hidden' files (those starting with '.') from being considered.
    names = [f for f in os.listdir(src) if not f.startswith('.')]
    try:
        os.mkdir(dst)
    except OSError as error:
        if error.errno != errno.EEXIST: raise
    for name in names:
        srcname = os.path.join(src, name)
        dstname = os.path.join(dst, name)
        if symlinks and os.path.islink(srcname):
            linkto = os.readlink(srcname)
            os.symlink(linkto, dstname)
        elif os.path.isdir(srcname):
            copytree(srcname, dstname, symlinks)
        else:
            install_util.copyDigestedFile(srcname, dstname)

def install(instance_home, template, settings={}):
    '''Install an instance using the named template and backend.

    'instance_home'
       the directory to place the instance data in
    'template'
       the directory holding the template to use in creating the instance data
    'settings'
       config.ini setting overrides (dictionary)

    The instance_home directory will be created using the files found in
    the named template (roundup.templates.<name>). A usual instance_home
    contains:

    config.ini
      tracker configuration file
    schema.py
      database schema definition
    initial_data.py
      database initialization script, used to populate the database
      with 'roundup-admin init' command
    interfaces.py
      (optional, not installed from standard templates) defines
      the CGI Client and mail gateway MailGW classes that are
      used by roundup.cgi, roundup-server and roundup-mailgw.
    db/
      the actual database that stores the instance's data
    html/
      the html templates that are used by the CGI Client
    detectors/
      the auditor and reactor modules for this instance
    extensions/
      code extensions to Roundup
    '''
    # At the moment, it's just a copy
    copytree(template, instance_home)

    # rename the tempate in the TEMPLATE-INFO.txt file
    ti = loadTemplateInfo(instance_home)
    ti['name'] = ti['name'] + '-' + os.path.split(instance_home)[1]
    saveTemplateInfo(instance_home, ti)

    # if there is no config.ini or old-style config.py
    # installed from the template, write default config text
    config_ini_file = os.path.join(instance_home, CoreConfig.INI_FILE)
    if not os.path.isfile(config_ini_file):
        config = CoreConfig(settings=settings)
        config.save(config_ini_file)


def listTemplates(dir):
    ''' List all the Roundup template directories in a given directory.

        Find all the dirs that contain a TEMPLATE-INFO.txt and parse it.

        Return a list of dicts of info about the templates.
    '''
    ret = {}
    for idir in os.listdir(dir):
        idir = os.path.join(dir, idir)
        ti = loadTemplateInfo(idir)
        if ti:
            ret[ti['name']] = ti
    return ret

def loadTemplateInfo(dir):
    ''' Attempt to load a Roundup template from the indicated directory.

        Return None if there's no template, otherwise a template info
        dictionary.
    '''
    ti = os.path.join(dir, 'TEMPLATE-INFO.txt')
    if not os.path.exists(ti):
        return None

    if os.path.exists(os.path.join(dir, 'config.py')):
        print _("WARNING: directory '%s'\n"
            "\tcontains old-style template - ignored"
            ) % os.path.abspath(dir)
        return None

    # load up the template's information
    f = open(ti)
    try:
        m = rfc822.Message(open(ti))
        ti = {}
        ti['name'] = m['name']
        ti['description'] = m['description']
        ti['intended-for'] = m['intended-for']
        ti['path'] = dir
    finally:
        f.close()
    return ti

def writeHeader(name, value):
    ''' Write an rfc822-compatible header line, making it wrap reasonably
    '''
    out = [name.capitalize() + ':']
    n = len(out[0])
    for word in value.split():
        if len(word) + n > 74:
            out.append('\n')
            n = 0
        out.append(' ' + word)
        n += len(out[-1])
    return ''.join(out) + '\n'

def saveTemplateInfo(dir, info):
    ''' Save the template info (dict of values) to the TEMPLATE-INFO.txt
        file in the indicated directory.
    '''
    ti = os.path.join(dir, 'TEMPLATE-INFO.txt')
    f = open(ti, 'w')
    try:
        for name in 'name description intended-for path'.split():
            f.write(writeHeader(name, info[name]))
    finally:
        f.close()

def write_select_db(instance_home, backend):
    ''' Write the file that selects the backend for the tracker
    '''
    dbdir = os.path.join(instance_home, 'db')
    if not os.path.exists(dbdir):
        os.makedirs(dbdir)
    f = open(os.path.join(dbdir, 'backend_name'), 'w')
    f.write(backend+'\n')
    f.close()



# vim: set filetype=python sts=4 sw=4 et si :

blob
mark :780
data 8366
"""Sending Roundup-specific mail over SMTP.
"""
__docformat__ = 'restructuredtext'
# $Id: mailer.py,v 1.22 2008-07-21 01:44:58 richard Exp $

import time, quopri, os, socket, smtplib, re, sys, traceback, email

from cStringIO import StringIO

from roundup import __version__
from roundup.date import get_timezone

from email.Utils import formatdate, formataddr
from email.Message import Message
from email.Header import Header
from email.MIMEText import MIMEText
from email.MIMEMultipart import MIMEMultipart

class MessageSendError(RuntimeError):
    pass

def encode_quopri(msg):
    orig = msg.get_payload()
    encdata = quopri.encodestring(orig)
    msg.set_payload(encdata)
    del msg['Content-Transfer-Encoding']
    msg['Content-Transfer-Encoding'] = 'quoted-printable'

class Mailer:
    """Roundup-specific mail sending."""
    def __init__(self, config):
        self.config = config

        # set to indicate to roundup not to actually _send_ email
        # this var must contain a file to write the mail to
        self.debug = os.environ.get('SENDMAILDEBUG', '') \
            or config["MAIL_DEBUG"]

        # set timezone so that things like formatdate(localtime=True)
        # use the configured timezone
        # apparently tzset doesn't exist in python under Windows, my bad.
        # my pathetic attempts at googling a Windows-solution failed
        # so if you're on Windows your mail won't use your configured
        # timezone.
        if hasattr(time, 'tzset'):
            os.environ['TZ'] = get_timezone(self.config.TIMEZONE).tzname(None)
            time.tzset()

    def get_standard_message(self, to, subject, author=None, multipart=False):
        '''Form a standard email message from Roundup.

        "to"      - recipients list
        "subject" - Subject
        "author"  - (name, address) tuple or None for admin email

        Subject and author are encoded using the EMAIL_CHARSET from the
        config (default UTF-8).

        Returns a Message object.
        '''
        # encode header values if they need to be
        charset = getattr(self.config, 'EMAIL_CHARSET', 'utf-8')
        tracker_name = unicode(self.config.TRACKER_NAME, 'utf-8')
        if not author:
            author = formataddr((tracker_name, self.config.ADMIN_EMAIL))
        else:
            name = unicode(author[0], 'utf-8')
            author = formataddr((name, author[1]))

        if multipart:
            message = MIMEMultipart()
        else:
            message = Message()
            message.set_type('text/plain')
            message.set_charset(charset)

        try:
            message['Subject'] = subject.encode('ascii')
        except UnicodeError:
            message['Subject'] = Header(subject, charset)
        message['To'] = ', '.join(to)
        try:
            message['From'] = author.encode('ascii')
        except UnicodeError:
            message['From'] = Header(author, charset)
        message['Date'] = formatdate(localtime=True)

        # add a Precedence header so autoresponders ignore us
        message['Precedence'] = 'bulk'

        # Add a unique Roundup header to help filtering
        try:
            message['X-Roundup-Name'] = tracker_name.encode('ascii')
        except UnicodeError:
            message['X-Roundup-Name'] = Header(tracker_name, charset)

        # and another one to avoid loops
        message['X-Roundup-Loop'] = 'hello'
        # finally, an aid to debugging problems
        message['X-Roundup-Version'] = __version__

        message['MIME-Version'] = '1.0'

        return message

    def standard_message(self, to, subject, content, author=None):
        """Send a standard message.

        Arguments:
        - to: a list of addresses usable by rfc822.parseaddr().
        - subject: the subject as a string.
        - content: the body of the message as a string.
        - author: the sender as a (name, address) tuple

        All strings are assumed to be UTF-8 encoded.
        """
        message = self.get_standard_message(to, subject, author)
        message.set_payload(content)
        encode_quopri(message)
        self.smtp_send(to, str(message))

    def bounce_message(self, bounced_message, to, error,
                       subject='Failed issue tracker submission'):
        """Bounce a message, attaching the failed submission.

        Arguments:
        - bounced_message: an RFC822 Message object.
        - to: a list of addresses usable by rfc822.parseaddr(). Might be
          extended or overridden according to the config
          ERROR_MESSAGES_TO setting.
        - error: the reason of failure as a string.
        - subject: the subject as a string.

        """
        # see whether we should send to the dispatcher or not
        dispatcher_email = getattr(self.config, "DISPATCHER_EMAIL",
            getattr(self.config, "ADMIN_EMAIL"))
        error_messages_to = getattr(self.config, "ERROR_MESSAGES_TO", "user")
        if error_messages_to == "dispatcher":
            to = [dispatcher_email]
        elif error_messages_to == "both":
            to.append(dispatcher_email)

        message = self.get_standard_message(to, subject)

        # add the error text
        part = MIMEText(error)
        message.attach(part)

        # attach the original message to the returned message
        try:
            bounced_message.rewindbody()
        except IOError as message:
            body.write("*** couldn't include message body: %s ***"
                       % bounced_message)
        else:
            body.write(bounced_message.fp.read())
        part = MIMEText(bounced_message.fp.read())
        part['Content-Disposition'] = 'attachment'
        for header in bounced_message.headers:
            part.write(header)
        message.attach(part)

        # send
        try:
            self.smtp_send(to, str(message))
        except MessageSendError:
            # squash mail sending errors when bouncing mail
            # TODO this *could* be better, as we could notify admin of the
            # problem (even though the vast majority of bounce errors are
            # because of spam)
            pass

    def exception_message(self):
        '''Send a message to the admins with information about the latest
        traceback.
        '''
        subject = '%s: %s'%(self.config.TRACKER_NAME, sys.exc_info()[1])
        to = [self.config.ADMIN_EMAIL]
        content = '\n'.join(traceback.format_exception(*sys.exc_info()))
        self.standard_message(to, subject, content)

    def smtp_send(self, to, message):
        """Send a message over SMTP, using roundup's config.

        Arguments:
        - to: a list of addresses usable by rfc822.parseaddr().
        - message: a StringIO instance with a full message.
        """
        if self.debug:
            # don't send - just write to a file
            open(self.debug, 'a').write('FROM: %s\nTO: %s\n%s\n' %
                                        (self.config.ADMIN_EMAIL,
                                         ', '.join(to), message))
        else:
            # now try to send the message
            try:
                # send the message as admin so bounces are sent there
                # instead of to roundup
                smtp = SMTPConnection(self.config)
                smtp.sendmail(self.config.ADMIN_EMAIL, to, message)
            except socket.error as value:
                raise MessageSendError("Error: couldn't send email: "
                                       "mailhost %s"%value)
            except smtplib.SMTPException as msg:
                raise MessageSendError("Error: couldn't send email: %s"%msg)

class SMTPConnection(smtplib.SMTP):
    ''' Open an SMTP connection to the mailhost specified in the config
    '''
    def __init__(self, config):
        smtplib.SMTP.__init__(self, config.MAILHOST, port=config['MAIL_PORT'],
                              local_hostname=config['MAIL_LOCAL_HOSTNAME'])

        # start the TLS if requested
        if config["MAIL_TLS"]:
            self.ehlo()
            self.starttls(config["MAIL_TLS_KEYFILE"],
                config["MAIL_TLS_CERTFILE"])

        # ok, now do we also need to log in?
        mailuser = config["MAIL_USERNAME"]
        if mailuser:
            self.login(mailuser, config["MAIL_PASSWORD"])

# vim: set et sts=4 sw=4 :

blob
mark :781
data 60447
# -*- coding: utf-8 -*-
#
# Copyright (c) 2001 Bizar Software Pty Ltd (http://www.bizarsoftware.com.au/)
# This module is free software, and you may redistribute it and/or modify
# under the same terms as Python, so long as this copyright message and
# disclaimer are retained in their original form.
#
# IN NO EVENT SHALL BIZAR SOFTWARE PTY LTD BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# BIZAR SOFTWARE PTY LTD SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
# BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS"
# BASIS, AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
# SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#

"""An e-mail gateway for Roundup.

Incoming messages are examined for multiple parts:
 . In a multipart/mixed message or part, each subpart is extracted and
   examined. The text/plain subparts are assembled to form the textual
   body of the message, to be stored in the file associated with a "msg"
   class node. Any parts of other types are each stored in separate files
   and given "file" class nodes that are linked to the "msg" node.
 . In a multipart/alternative message or part, we look for a text/plain
   subpart and ignore the other parts.

Summary
-------
The "summary" property on message nodes is taken from the first non-quoting
section in the message body. The message body is divided into sections by
blank lines. Sections where the second and all subsequent lines begin with
a ">" or "|" character are considered "quoting sections". The first line of
the first non-quoting section becomes the summary of the message.

Addresses
---------
All of the addresses in the To: and Cc: headers of the incoming message are
looked up among the user nodes, and the corresponding users are placed in
the "recipients" property on the new "msg" node. The address in the From:
header similarly determines the "author" property of the new "msg"
node. The default handling for addresses that don't have corresponding
users is to create new users with no passwords and a username equal to the
address. (The web interface does not permit logins for users with no
passwords.) If we prefer to reject mail from outside sources, we can simply
register an auditor on the "user" class that prevents the creation of user
nodes with no passwords.

Actions
-------
The subject line of the incoming message is examined to determine whether
the message is an attempt to create a new item or to discuss an existing
item. A designator enclosed in square brackets is sought as the first thing
on the subject line (after skipping any "Fwd:" or "Re:" prefixes).

If an item designator (class name and id number) is found there, the newly
created "msg" node is added to the "messages" property for that item, and
any new "file" nodes are added to the "files" property for the item.

If just an item class name is found there, we attempt to create a new item
of that class with its "messages" property initialized to contain the new
"msg" node and its "files" property initialized to contain any new "file"
nodes.

Triggers
--------
Both cases may trigger detectors (in the first case we are calling the
set() method to add the message to the item's spool; in the second case we
are calling the create() method to create a new node). If an auditor raises
an exception, the original message is bounced back to the sender with the
explanatory message given in the exception.

$Id: mailgw.py,v 1.196 2008-07-23 03:04:44 richard Exp $
"""
__docformat__ = 'restructuredtext'

import string, re, os, mimetools, cStringIO, smtplib, socket, binascii, quopri
import time, random, sys, logging
import traceback, MimeWriter, rfc822

from email.Header import decode_header

from roundup import configuration, hyperdb, date, password, rfc2822, exceptions
from roundup.mailer import Mailer, MessageSendError
from roundup.i18n import _

try:
    import pyme, pyme.core, pyme.gpgme
except ImportError:
    pyme = None

SENDMAILDEBUG = os.environ.get('SENDMAILDEBUG', '')

class MailGWError(ValueError):
    pass

class MailUsageError(ValueError):
    pass

class MailUsageHelp(Exception):
    """ We need to send the help message to the user. """
    pass

class Unauthorized(Exception):
    """ Access denied """
    pass

class IgnoreMessage(Exception):
    """ A general class of message that we should ignore. """
    pass
class IgnoreBulk(IgnoreMessage):
        """ This is email from a mailing list or from a vacation program. """
        pass
class IgnoreLoop(IgnoreMessage):
        """ We've seen this message before... """
        pass

def initialiseSecurity(security):
    ''' Create some Permissions and Roles on the security object

        This function is directly invoked by security.Security.__init__()
        as a part of the Security object instantiation.
    '''
    p = security.addPermission(name="Email Access",
        description="User may use the email interface")
    security.addPermissionToRole('Admin', p)

def getparam(str, param):
    ''' From the rfc822 "header" string, extract "param" if it appears.
    '''
    if ';' not in str:
        return None
    str = str[str.index(';'):]
    while str[:1] == ';':
        str = str[1:]
        if ';' in str:
            # XXX Should parse quotes!
            end = str.index(';')
        else:
            end = len(str)
        f = str[:end]
        if '=' in f:
            i = f.index('=')
            if f[:i].strip().lower() == param:
                return rfc822.unquote(f[i+1:].strip())
    return None

def gpgh_key_getall(key, attr):
    ''' return list of given attribute for all uids in
        a key
    '''
    u = key.uids
    while u:
        yield getattr(u, attr)
        u = u.next

def gpgh_sigs(sig):
    ''' more pythonic iteration over GPG signatures '''
    while sig:
        yield sig
        sig = sig.next


def iter_roles(roles):
    ''' handle the text processing of turning the roles list
        into something python can use more easily
    '''
    for role in [x.lower().strip() for x in roles.split(',')]:
        yield role

def user_has_role(db, userid, role_list):
    ''' see if the given user has any roles that appear
        in the role_list
    '''
    for role in iter_roles(db.user.get(userid, 'roles')):
        if role in iter_roles(role_list):
            return True
    return False


def check_pgp_sigs(sig, gpgctx, author):
    ''' Theoretically a PGP message can have several signatures. GPGME
        returns status on all signatures in a linked list. Walk that
        linked list looking for the author's signature
    '''
    for sig in gpgh_sigs(sig):
        key = gpgctx.get_key(sig.fpr, False)
        # we really only care about the signature of the user who
        # submitted the email
        if key and (author in gpgh_key_getall(key, 'email')):
            if sig.summary & pyme.gpgme.GPGME_SIGSUM_VALID:
                return True
            else:
                # try to narrow down the actual problem to give a more useful
                # message in our bounce
                if sig.summary & pyme.gpgme.GPGME_SIGSUM_KEY_MISSING:
                    raise MailUsageError, \
                        _("Message signed with unknown key: %s") % sig.fpr
                elif sig.summary & pyme.gpgme.GPGME_SIGSUM_KEY_EXPIRED:
                    raise MailUsageError, \
                        _("Message signed with an expired key: %s") % sig.fpr
                elif sig.summary & pyme.gpgme.GPGME_SIGSUM_KEY_REVOKED:
                    raise MailUsageError, \
                        _("Message signed with a revoked key: %s") % sig.fpr
                else:
                    raise MailUsageError, \
                        _("Invalid PGP signature detected.")

    # we couldn't find a key belonging to the author of the email
    raise MailUsageError, _("Message signed with unknown key: %s") % sig.fpr

class Message(mimetools.Message):
    ''' subclass mimetools.Message so we can retrieve the parts of the
        message...
    '''
    def getpart(self):
        ''' Get a single part of a multipart message and return it as a new
            Message instance.
        '''
        boundary = self.getparam('boundary')
        mid, end = '--'+boundary, '--'+boundary+'--'
        s = cStringIO.StringIO()
        while 1:
            line = self.fp.readline()
            if not line:
                break
            if line.strip() in (mid, end):
                # according to rfc 1431 the preceding line ending is part of
                # the boundary so we need to strip that
                length = s.tell()
                s.seek(-2, 1)
                lineending = s.read(2)
                if lineending == '\r\n':
                    s.truncate(length - 2)
                elif lineending[1] in ('\r', '\n'):
                    s.truncate(length - 1)
                else:
                    raise ValueError('Unknown line ending in message.')
                break
            s.write(line)
        if not s.getvalue().strip():
            return None
        s.seek(0)
        return Message(s)

    def getparts(self):
        """Get all parts of this multipart message."""
        # skip over the intro to the first boundary
        self.fp.seek(0)
        self.getpart()

        # accumulate the other parts
        parts = []
        while 1:
            part = self.getpart()
            if part is None:
                break
            parts.append(part)
        return parts

    def getheader(self, name, default=None):
        hdr = mimetools.Message.getheader(self, name, default)
        if not hdr:
            return ''
        if hdr:
            hdr = hdr.replace('\n','') # Inserted by rfc822.readheaders
        # historically this method has returned utf-8 encoded string
        l = []
        for part, encoding in decode_header(hdr):
            if encoding:
                part = part.decode(encoding)
            l.append(part)
        return ''.join([s.encode('utf-8') for s in l])

    def getaddrlist(self, name):
        # overload to decode the name part of the address
        l = []
        for (name, addr) in mimetools.Message.getaddrlist(self, name):
            p = []
            for part, encoding in decode_header(name):
                if encoding:
                    part = part.decode(encoding)
                p.append(part)
            name = ''.join([s.encode('utf-8') for s in p])
            l.append((name, addr))
        return l

    def getname(self):
        """Find an appropriate name for this message."""
        if self.gettype() == 'message/rfc822':
            # handle message/rfc822 specially - the name should be
            # the subject of the actual e-mail embedded here
            self.fp.seek(0)
            name = Message(self.fp).getheader('subject')
        else:
            # try name on Content-Type
            name = self.getparam('name')
            if not name:
                disp = self.getheader('content-disposition', None)
                if disp:
                    name = getparam(disp, 'filename')

        if name:
            return name.strip()

    def getbody(self):
        """Get the decoded message body."""
        self.rewindbody()
        encoding = self.getencoding()
        data = None
        if encoding == 'base64':
            # BUG: is base64 really used for text encoding or
            # are we inserting zip files here.
            data = binascii.a2b_base64(self.fp.read())
        elif encoding == 'quoted-printable':
            # the quopri module wants to work with files
            decoded = cStringIO.StringIO()
            quopri.decode(self.fp, decoded)
            data = decoded.getvalue()
        elif encoding == 'uuencoded':
            data = binascii.a2b_uu(self.fp.read())
        else:
            # take it as text
            data = self.fp.read()

        # Encode message to unicode
        charset = rfc2822.unaliasCharset(self.getparam("charset"))
        if charset:
            # Do conversion only if charset specified - handle
            # badly-specified charsets
            edata = unicode(data, charset, 'replace').encode('utf-8')
            # Convert from dos eol to unix
            edata = edata.replace('\r\n', '\n')
        else:
            # Leave message content as is
            edata = data

        return edata

    # General multipart handling:
    #   Take the first text/plain part, anything else is considered an
    #   attachment.
    # multipart/mixed:
    #   Multiple "unrelated" parts.
    # multipart/Alternative (rfc 1521):
    #   Like multipart/mixed, except that we'd only want one of the
    #   alternatives. Generally a top-level part from MUAs sending HTML
    #   mail - there will be a text/plain version.
    # multipart/signed (rfc 1847):
    #   The control information is carried in the second of the two
    #   required body parts.
    #   ACTION: Default, so if content is text/plain we get it.
    # multipart/encrypted (rfc 1847):
    #   The control information is carried in the first of the two
    #   required body parts.
    #   ACTION: Not handleable as the content is encrypted.
    # multipart/related (rfc 1872, 2112, 2387):
    #   The Multipart/Related content-type addresses the MIME
    #   representation of compound objects, usually HTML mail with embedded
    #   images. Usually appears as an alternative.
    #   ACTION: Default, if we must.
    # multipart/report (rfc 1892):
    #   e.g. mail system delivery status reports.
    #   ACTION: Default. Could be ignored or used for Delivery Notification
    #   flagging.
    # multipart/form-data:
    #   For web forms only.

    def extract_content(self, parent_type=None, ignore_alternatives = False):
        """Extract the body and the attachments recursively.

           If the content is hidden inside a multipart/alternative part,
           we use the *last* text/plain part of the *first*
           multipart/alternative in the whole message.
        """
        content_type = self.gettype()
        content = None
        attachments = []

        if content_type == 'text/plain':
            content = self.getbody()
        elif content_type[:10] == 'multipart/':
            content_found = bool (content)
            ig = ignore_alternatives and not content_found
            for part in self.getparts():
                new_content, new_attach = part.extract_content(content_type,
                    not content and ig)

                # If we haven't found a text/plain part yet, take this one,
                # otherwise make it an attachment.
                if not content:
                    content = new_content
                    cpart   = part
                elif new_content:
                    if content_found or content_type != 'multipart/alternative':
                        attachments.append(part.text_as_attachment())
                    else:
                        # if we have found a text/plain in the current
                        # multipart/alternative and find another one, we
                        # use the first as an attachment (if configured)
                        # and use the second one because rfc 2046, sec.
                        # 5.1.4. specifies that later parts are better
                        # (thanks to Philipp Gortan for pointing this
                        # out)
                        attachments.append(cpart.text_as_attachment())
                        content = new_content
                        cpart   = part

                attachments.extend(new_attach)
            if ig and content_type == 'multipart/alternative' and content:
                attachments = []
        elif (parent_type == 'multipart/signed' and
              content_type == 'application/pgp-signature'):
            # ignore it so it won't be saved as an attachment
            pass
        else:
            attachments.append(self.as_attachment())
        return content, attachments

    def text_as_attachment(self):
        """Return first text/plain part as Message"""
        if not self.gettype().startswith ('multipart/'):
            return self.as_attachment()
        for part in self.getparts():
            content_type = part.gettype()
            if content_type == 'text/plain':
                return part.as_attachment()
            elif content_type.startswith ('multipart/'):
                p = part.text_as_attachment()
                if p:
                    return p
        return None

    def as_attachment(self):
        """Return this message as an attachment."""
        return (self.getname(), self.gettype(), self.getbody())

    def pgp_signed(self):
        ''' RFC 3156 requires OpenPGP MIME mail to have the protocol parameter
        '''
        return self.gettype() == 'multipart/signed' \
            and self.typeheader.find('protocol="application/pgp-signature"') != -1

    def pgp_encrypted(self):
        ''' RFC 3156 requires OpenPGP MIME mail to have the protocol parameter
        '''
        return self.gettype() == 'multipart/encrypted' \
            and self.typeheader.find('protocol="application/pgp-encrypted"') != -1

    def decrypt(self, author):
        ''' decrypt an OpenPGP MIME message
            This message must be signed as well as encrypted using the "combined"
            method. The decrypted contents are returned as a new message.
        '''
        (hdr, msg) = self.getparts()
        # According to the RFC 3156 encrypted mail must have exactly two parts.
        # The first part contains the control information. Let's verify that
        # the message meets the RFC before we try to decrypt it.
        if hdr.getbody() != 'Version: 1' or hdr.gettype() != 'application/pgp-encrypted':
            raise MailUsageError, \
                _("Unknown multipart/encrypted version.")

        context = pyme.core.Context()
        ciphertext = pyme.core.Data(msg.getbody())
        plaintext = pyme.core.Data()

        result = context.op_decrypt_verify(ciphertext, plaintext)

        if result:
            raise MailUsageError, _("Unable to decrypt your message.")

        # we've decrypted it but that just means they used our public
        # key to send it to us. now check the signatures to see if it
        # was signed by someone we trust
        result = context.op_verify_result()
        check_pgp_sigs(result.signatures, context, author)

        plaintext.seek(0,0)
        # pyme.core.Data implements a seek method with a different signature
        # than roundup can handle. So we'll put the data in a container that
        # the Message class can work with.
        c = cStringIO.StringIO()
        c.write(plaintext.read())
        c.seek(0)
        return Message(c)

    def verify_signature(self, author):
        ''' verify the signature of an OpenPGP MIME message
            This only handles detached signatures. Old style
            PGP mail (i.e. '-----BEGIN PGP SIGNED MESSAGE----')
            is archaic and not supported :)
        '''
        # we don't check the micalg parameter...gpgme seems to
        # figure things out on its own
        (msg, sig) = self.getparts()

        if sig.gettype() != 'application/pgp-signature':
            raise MailUsageError, \
                _("No PGP signature found in message.")

        context = pyme.core.Context()
        # msg.getbody() is skipping over some headers that are
        # required to be present for verification to succeed so
        # we'll do this by hand
        msg.fp.seek(0)
        # according to rfc 3156 the data "MUST first be converted
        # to its content-type specific canonical form. For
        # text/plain this means conversion to an appropriate
        # character set and conversion of line endings to the
        # canonical <CR><LF> sequence."
        # TODO: what about character set conversion?
        canonical_msg = re.sub('(?<!\r)\n', '\r\n', msg.fp.read())
        msg_data = pyme.core.Data(canonical_msg)
        sig_data = pyme.core.Data(sig.getbody())

        context.op_verify(sig_data, msg_data, None)

        # check all signatures for validity
        result = context.op_verify_result()
        check_pgp_sigs(result.signatures, context, author)

class MailGW:

    def __init__(self, instance, db, arguments=()):
        self.instance = instance
        self.db = db
        self.arguments = arguments
        self.default_class = None
        for option, value in self.arguments:
            if option == '-c':
                self.default_class = value.strip()

        self.mailer = Mailer(instance.config)
        self.logger = logging.getLogger('mailgw')

        # should we trap exceptions (normal usage) or pass them through
        # (for testing)
        self.trapExceptions = 1

    def do_pipe(self):
        """ Read a message from standard input and pass it to the mail handler.

            Read into an internal structure that we can seek on (in case
            there's an error).

            XXX: we may want to read this into a temporary file instead...
        """
        s = cStringIO.StringIO()
        s.write(sys.stdin.read())
        s.seek(0)
        self.main(s)
        return 0

    def do_mailbox(self, filename):
        """ Read a series of messages from the specified unix mailbox file and
            pass each to the mail handler.
        """
        # open the spool file and lock it
        import fcntl
        # FCNTL is deprecated in py2.3 and fcntl takes over all the symbols
        if hasattr(fcntl, 'LOCK_EX'):
            FCNTL = fcntl
        else:
            import FCNTL
        f = open(filename, 'r+')
        fcntl.flock(f.fileno(), FCNTL.LOCK_EX)

        # handle and clear the mailbox
        try:
            from mailbox import UnixMailbox
            mailbox = UnixMailbox(f, factory=Message)
            # grab one message
            message = mailbox.next()
            while message:
                # handle this message
                self.handle_Message(message)
                message = mailbox.next()
            # nuke the file contents
            os.ftruncate(f.fileno(), 0)
        except:
            import traceback
            traceback.print_exc()
            return 1
        fcntl.flock(f.fileno(), FCNTL.LOCK_UN)
        return 0

    def do_imap(self, server, user='', password='', mailbox='', ssl=0):
        ''' Do an IMAP connection
        '''
        import getpass, imaplib, socket
        try:
            if not user:
                user = raw_input('User: ')
            if not password:
                password = getpass.getpass()
        except (KeyboardInterrupt, EOFError):
            # Ctrl C or D maybe also Ctrl Z under Windows.
            print "\nAborted by user."
            return 1
        # open a connection to the server and retrieve all messages
        try:
            if ssl:
                self.logger.debug('Trying server %r with ssl'%server)
                server = imaplib.IMAP4_SSL(server)
            else:
                self.logger.debug('Trying server %r without ssl'%server)
                server = imaplib.IMAP4(server)
        except (imaplib.IMAP4.error, socket.error, socket.sslerror):
            self.logger.exception('IMAP server error')
            return 1

        try:
            server.login(user, password)
        except imaplib.IMAP4.error, e:
            self.logger.exception('IMAP login failure')
            return 1

        try:
            if not mailbox:
                (typ, data) = server.select()
            else:
                (typ, data) = server.select(mailbox=mailbox)
            if typ != 'OK':
                self.logger.error('Failed to get mailbox %r: %s'%(mailbox,
                    data))
                return 1
            try:
                numMessages = int(data[0])
            except ValueError as value:
                self.logger.error('Invalid message count from mailbox %r'%
                    data[0])
                return 1
            for i in range(1, numMessages+1):
                (typ, data) = server.fetch(str(i), '(RFC822)')

                # mark the message as deleted.
                server.store(str(i), '+FLAGS', r'(\Deleted)')

                # process the message
                s = cStringIO.StringIO(data[0][1])
                s.seek(0)
                self.handle_Message(Message(s))
            server.close()
        finally:
            try:
                server.expunge()
            except:
                pass
            server.logout()

        return 0


    def do_apop(self, server, user='', password='', ssl=False):
        ''' Do authentication POP
        '''
        self._do_pop(server, user, password, True, ssl)

    def do_pop(self, server, user='', password='', ssl=False):
        ''' Do plain POP
        '''
        self._do_pop(server, user, password, False, ssl)

    def _do_pop(self, server, user, password, apop, ssl):
        '''Read a series of messages from the specified POP server.
        '''
        import getpass, poplib, socket
        try:
            if not user:
                user = raw_input('User: ')
            if not password:
                password = getpass.getpass()
        except (KeyboardInterrupt, EOFError):
            # Ctrl C or D maybe also Ctrl Z under Windows.
            print "\nAborted by user."
            return 1

        # open a connection to the server and retrieve all messages
        try:
            if ssl:
                klass = poplib.POP3_SSL
            else:
                klass = poplib.POP3
            server = klass(server)
        except socket.error:
            self.logger.exception('POP server error')
            return 1
        if apop:
            server.apop(user, password)
        else:
            server.user(user)
            server.pass_(password)
        numMessages = len(server.list()[1])
        for i in range(1, numMessages+1):
            # retr: returns
            # [ pop response e.g. '+OK 459 octets',
            #   [ array of message lines ],
            #   number of octets ]
            lines = server.retr(i)[1]
            s = cStringIO.StringIO('\n'.join(lines))
            s.seek(0)
            self.handle_Message(Message(s))
            # delete the message
            server.dele(i)

        # quit the server to commit changes.
        server.quit()
        return 0

    def main(self, fp):
        ''' fp - the file from which to read the Message.
        '''
        return self.handle_Message(Message(fp))

    def handle_Message(self, message):
        """Handle an RFC822 Message

        Handle the Message object by calling handle_message() and then cope
        with any errors raised by handle_message.
        This method's job is to make that call and handle any
        errors in a sane manner. It should be replaced if you wish to
        handle errors in a different manner.
        """
        # in some rare cases, a particularly stuffed-up e-mail will make
        # its way into here... try to handle it gracefully

        sendto = message.getaddrlist('resent-from')
        if not sendto:
            sendto = message.getaddrlist('from')
        if not sendto:
            # very bad-looking message - we don't even know who sent it
            msg = ['Badly formed message from mail gateway. Headers:']
            msg.extend(message.headers)
            msg = '\n'.join(map(str, msg))
            self.logger.error(msg)
            return

        msg = 'Handling message'
        if message.getheader('message-id'):
            msg += ' (Message-id=%r)'%message.getheader('message-id')
        self.logger.info(msg)

        # try normal message-handling
        if not self.trapExceptions:
            return self.handle_message(message)

        # no, we want to trap exceptions
        try:
            return self.handle_message(message)
        except MailUsageHelp:
            # bounce the message back to the sender with the usage message
            fulldoc = '\n'.join(string.split(__doc__, '\n')[2:])
            m = ['']
            m.append('\n\nMail Gateway Help\n=================')
            m.append(fulldoc)
            self.mailer.bounce_message(message, [sendto[0][1]], m,
                subject="Mail Gateway Help")
        except MailUsageError as value:
            # bounce the message back to the sender with the usage message
            fulldoc = '\n'.join(string.split(__doc__, '\n')[2:])
            m = ['']
            m.append(str(value))
            m.append('\n\nMail Gateway Help\n=================')
            m.append(fulldoc)
            self.mailer.bounce_message(message, [sendto[0][1]], m)
        except Unauthorized as value:
            # just inform the user that he is not authorized
            m = ['']
            m.append(str(value))
            self.mailer.bounce_message(message, [sendto[0][1]], m)
        except IgnoreMessage:
            # do not take any action
            # this exception is thrown when email should be ignored
            msg = 'IgnoreMessage raised'
            if message.getheader('message-id'):
                msg += ' (Message-id=%r)'%message.getheader('message-id')
            self.logger.info(msg)
            return
        except:
            msg = 'Exception handling message'
            if message.getheader('message-id'):
                msg += ' (Message-id=%r)'%message.getheader('message-id')
            self.logger.exception(msg)

            # bounce the message back to the sender with the error message
            # let the admin know that something very bad is happening
            m = ['']
            m.append('An unexpected error occurred during the processing')
            m.append('of your message. The tracker administrator is being')
            m.append('notified.\n')
            self.mailer.bounce_message(message, [sendto[0][1]], m)

            m.append('----------------')
            m.append(traceback.format_exc())
            self.mailer.bounce_message(message, [self.instance.config.ADMIN_EMAIL], m)

    def handle_message(self, message):
        ''' message - a Message instance

        Parse the message as per the module docstring.
        '''
        # detect loops
        if message.getheader('x-roundup-loop', ''):
            raise IgnoreLoop

        # handle the subject line
        subject = message.getheader('subject', '')
        if not subject:
            raise MailUsageError, _("""
Emails to Roundup trackers must include a Subject: line!
""")

        # detect Precedence: Bulk, or Microsoft Outlook autoreplies
        if (message.getheader('precedence', '') == 'bulk'
                or subject.lower().find("autoreply") > 0):
            raise IgnoreBulk

        if subject.strip().lower() == 'help':
            raise MailUsageHelp

        # config is used many times in this method.
        # make local variable for easier access
        config = self.instance.config

        # determine the sender's address
        from_list = message.getaddrlist('resent-from')
        if not from_list:
            from_list = message.getaddrlist('from')

        # XXX Don't enable. This doesn't work yet.
#  "[^A-z.]tracker\+(?P<classname>[^\d\s]+)(?P<nodeid>\d+)\@some.dom.ain[^A-z.]"
        # handle delivery to addresses like:tracker+issue25@some.dom.ain
        # use the embedded issue number as our issue
#        issue_re = config['MAILGW_ISSUE_ADDRESS_RE']
#        if issue_re:
#            for header in ['to', 'cc', 'bcc']:
#                addresses = message.getheader(header, '')
#            if addresses:
#              # FIXME, this only finds the first match in the addresses.
#                issue = re.search(issue_re, addresses, 'i')
#                if issue:
#                    classname = issue.group('classname')
#                    nodeid = issue.group('nodeid')
#                    break

        # Matches subjects like:
        # Re: "[issue1234] title of issue [status=resolved]"

        # Alias since we need a reference to the original subject for
        # later use in error messages
        tmpsubject = subject

        sd_open, sd_close = config['MAILGW_SUBJECT_SUFFIX_DELIMITERS']
        delim_open = re.escape(sd_open)
        if delim_open in '[(': delim_open = '\\' + delim_open
        delim_close = re.escape(sd_close)
        if delim_close in '[(': delim_close = '\\' + delim_close

        matches = dict.fromkeys(['refwd', 'quote', 'classname',
                                 'nodeid', 'title', 'args',
                                 'argswhole'])

        # Look for Re: et. al. Used later on for MAILGW_SUBJECT_CONTENT_MATCH
        re_re = r"(?P<refwd>%s)\s*" % config["MAILGW_REFWD_RE"].pattern
        m = re.match(re_re, tmpsubject, re.IGNORECASE|re.VERBOSE|re.UNICODE)
        if m:
            m = m.groupdict()
            if m['refwd']:
                matches.update(m)
                tmpsubject = tmpsubject[len(m['refwd']):] # Consume Re:

        # Look for Leading "
        m = re.match(r'(?P<quote>\s*")', tmpsubject,
                     re.IGNORECASE)
        if m:
            matches.update(m.groupdict())
            tmpsubject = tmpsubject[len(matches['quote']):] # Consume quote

        has_prefix = re.search(r'^%s(\w+)%s'%(delim_open,
            delim_close), tmpsubject.strip())

        class_re = r'%s(?P<classname>(%s))(?P<nodeid>\d+)?%s'%(delim_open,
            "|".join(self.db.getclasses()), delim_close)
        # Note: re.search, not re.match as there might be garbage
        # (mailing list prefix, etc.) before the class identifier
        m = re.search(class_re, tmpsubject, re.IGNORECASE)
        if m:
            matches.update(m.groupdict())
            # Skip to the end of the class identifier, including any
            # garbage before it.

            tmpsubject = tmpsubject[m.end():]

        # if we've not found a valid classname prefix then force the
        # scanning to handle there being a leading delimiter
        title_re = r'(?P<title>%s[^%s]+)'%(
            not matches['classname'] and '.' or '', delim_open)
        m = re.match(title_re, tmpsubject.strip(), re.IGNORECASE)
        if m:
            matches.update(m.groupdict())
            tmpsubject = tmpsubject[len(matches['title']):] # Consume title

        args_re = r'(?P<argswhole>%s(?P<args>.+?)%s)?'%(delim_open,
            delim_close)
        m = re.search(args_re, tmpsubject.strip(), re.IGNORECASE|re.VERBOSE)
        if m:
            matches.update(m.groupdict())

        # figure subject line parsing modes
        pfxmode = config['MAILGW_SUBJECT_PREFIX_PARSING']
        sfxmode = config['MAILGW_SUBJECT_SUFFIX_PARSING']

        # check for registration OTK
        # or fallback on the default class
        if self.db.config['EMAIL_REGISTRATION_CONFIRMATION']:
            otk_re = re.compile('-- key (?P<otk>[a-zA-Z0-9]{32})')
            otk = otk_re.search(matches['title'] or '')
            if otk:
                self.db.confirm_registration(otk.group('otk'))
                subject = 'Your registration to %s is complete' % \
                          config['TRACKER_NAME']
                sendto = [from_list[0][1]]
                self.mailer.standard_message(sendto, subject, '')
                return

        # get the classname
        if pfxmode == 'none':
            classname = None
        else:
            classname = matches['classname']

        if not classname and has_prefix and pfxmode == 'strict':
            raise MailUsageError, _("""
The message you sent to roundup did not contain a properly formed subject
line. The subject must contain a class name or designator to indicate the
'topic' of the message. For example:
    Subject: [issue] This is a new issue
      - this will create a new issue in the tracker with the title 'This is
        a new issue'.
    Subject: [issue1234] This is a followup to issue 1234
      - this will append the message's contents to the existing issue 1234
        in the tracker.

Subject was: '%(subject)s'
""") % locals()

        # try to get the class specified - if "loose" or "none" then fall
        # back on the default
        attempts = []
        if classname:
            attempts.append(classname)

        if self.default_class:
            attempts.append(self.default_class)
        else:
            attempts.append(config['MAILGW_DEFAULT_CLASS'])

        # first valid class name wins
        cl = None
        for trycl in attempts:
            try:
                cl = self.db.getclass(trycl)
                classname = trycl
                break
            except KeyError:
                pass

        if not cl:
            validname = ', '.join(self.db.getclasses())
            if classname:
                raise MailUsageError, _("""
The class name you identified in the subject line ("%(classname)s") does
not exist in the database.

Valid class names are: %(validname)s
Subject was: "%(subject)s"
""") % locals()
            else:
                raise MailUsageError, _("""
You did not identify a class name in the subject line and there is no
default set for this tracker. The subject must contain a class name or
designator to indicate the 'topic' of the message. For example:
    Subject: [issue] This is a new issue
      - this will create a new issue in the tracker with the title 'This is
        a new issue'.
    Subject: [issue1234] This is a followup to issue 1234
      - this will append the message's contents to the existing issue 1234
        in the tracker.

Subject was: '%(subject)s'
""") % locals()

        # get the optional nodeid
        if pfxmode == 'none':
            nodeid = None
        else:
            nodeid = matches['nodeid']

        # try in-reply-to to match the message if there's no nodeid
        inreplyto = message.getheader('in-reply-to') or ''
        if nodeid is None and inreplyto:
            l = self.db.getclass('msg').stringFind(messageid=inreplyto)
            if l:
                nodeid = cl.filter(None, {'messages':l})[0]

        # title is optional too
        title = matches['title']
        if title:
            title = title.strip()
        else:
            title = ''

        # strip off the quotes that dumb emailers put around the subject, like
        #      Re: "[issue1] bla blah"
        if matches['quote'] and title.endswith('"'):
            title = title[:-1]

        # but we do need either a title or a nodeid...
        if nodeid is None and not title:
            raise MailUsageError, _("""
I cannot match your message to a node in the database - you need to either
supply a full designator (with number, eg "[issue123]") or keep the
previous subject title intact so I can match that.

Subject was: "%(subject)s"
""") % locals()

        # If there's no nodeid, check to see if this is a followup and
        # maybe someone's responded to the initial mail that created an
        # entry. Try to find the matching nodes with the same title, and
        # use the _last_ one matched (since that'll _usually_ be the most
        # recent...). The subject_content_match config may specify an
        # additional restriction based on the matched node's creation or
        # activity.
        tmatch_mode = config['MAILGW_SUBJECT_CONTENT_MATCH']
        if tmatch_mode != 'never' and nodeid is None and matches['refwd']:
            l = cl.stringFind(title=title)
            limit = None
            if (tmatch_mode.startswith('creation') or
                    tmatch_mode.startswith('activity')):
                limit, interval = tmatch_mode.split(' ', 1)
                threshold = date.Date('.') - date.Interval(interval)
            for id in l:
                if limit:
                    if threshold < cl.get(id, limit):
                        nodeid = id
                else:
                    nodeid = id

        # if a nodeid was specified, make sure it's valid
        if nodeid is not None and not cl.hasnode(nodeid):
            if pfxmode == 'strict':
                raise MailUsageError, _("""
The node specified by the designator in the subject of your message
("%(nodeid)s") does not exist.

Subject was: "%(subject)s"
""") % locals()
            else:
                title = subject
                nodeid = None

        # Handle the arguments specified by the email gateway command line.
        # We do this by looping over the list of self.arguments looking for
        # a -C to tell us what class then the -S setting string.
        msg_props = {}
        user_props = {}
        file_props = {}
        issue_props = {}
        # so, if we have any arguments, use them
        if self.arguments:
            current_class = 'msg'
            for option, propstring in self.arguments:
                if option in ( '-C', '--class'):
                    current_class = propstring.strip()
                    # XXX this is not flexible enough.
                    #   we should chect for subclasses of these classes,
                    #   not for the class name...
                    if current_class not in ('msg', 'file', 'user', 'issue'):
                        mailadmin = config['ADMIN_EMAIL']
                        raise MailUsageError, _("""
The mail gateway is not properly set up. Please contact
%(mailadmin)s and have them fix the incorrect class specified as:
  %(current_class)s
""") % locals()
                if option in ('-S', '--set'):
                    if current_class == 'issue' :
                        errors, issue_props = setPropArrayFromString(self,
                            cl, propstring.strip(), nodeid)
                    elif current_class == 'file' :
                        temp_cl = self.db.getclass('file')
                        errors, file_props = setPropArrayFromString(self,
                            temp_cl, propstring.strip())
                    elif current_class == 'msg' :
                        temp_cl = self.db.getclass('msg')
                        errors, msg_props = setPropArrayFromString(self,
                            temp_cl, propstring.strip())
                    elif current_class == 'user' :
                        temp_cl = self.db.getclass('user')
                        errors, user_props = setPropArrayFromString(self,
                            temp_cl, propstring.strip())
                    if errors:
                        mailadmin = config['ADMIN_EMAIL']
                        raise MailUsageError, _("""
The mail gateway is not properly set up. Please contact
%(mailadmin)s and have them fix the incorrect properties:
  %(errors)s
""") % locals()

        #
        # handle the users
        #
        # Don't create users if anonymous isn't allowed to register
        create = 1
        anonid = self.db.user.lookup('anonymous')
        if not (self.db.security.hasPermission('Create', anonid, 'user')
                and self.db.security.hasPermission('Email Access', anonid)):
            create = 0

        # ok, now figure out who the author is - create a new user if the
        # "create" flag is true
        author = uidFromAddress(self.db, from_list[0], create=create)

        # if we're not recognised, and we don't get added as a user, then we
        # must be anonymous
        if not author:
            author = anonid

        # make sure the author has permission to use the email interface
        if not self.db.security.hasPermission('Email Access', author):
            if author == anonid:
                # we're anonymous and we need to be a registered user
                from_address = from_list[0][1]
                registration_info = ""
                if self.db.security.hasPermission('Web Access', author) and \
                   self.db.security.hasPermission('Create', anonid, 'user'):
                    tracker_web = self.instance.config.TRACKER_WEB
                    registration_info = """ Please register at:

%(tracker_web)suser?template=register

...before sending mail to the tracker.""" % locals()

                raise Unauthorized, _("""
You are not a registered user.%(registration_info)s

Unknown address: %(from_address)s
""") % locals()
            else:
                # we're registered and we're _still_ not allowed access
                raise Unauthorized, _(
                    'You are not permitted to access this tracker.')

        # make sure they're allowed to edit or create this class of information
        if nodeid:
            if not self.db.security.hasPermission('Edit', author, classname,
                    itemid=nodeid):
                raise Unauthorized, _(
                    'You are not permitted to edit %(classname)s.') % locals()
        else:
            if not self.db.security.hasPermission('Create', author, classname):
                raise Unauthorized, _(
                    'You are not permitted to create %(classname)s.'
                    ) % locals()

        # the author may have been created - make sure the change is
        # committed before we reopen the database
        self.db.commit()

        # set the database user as the author
        username = self.db.user.get(author, 'username')
        self.db.setCurrentUser(username)

        # re-get the class with the new database connection
        cl = self.db.getclass(classname)

        # now update the recipients list
        recipients = []
        tracker_email = config['TRACKER_EMAIL'].lower()
        for recipient in message.getaddrlist('to') + message.getaddrlist('cc'):
            r = recipient[1].strip().lower()
            if r == tracker_email or not r:
                continue

            # look up the recipient - create if necessary (and we're
            # allowed to)
            recipient = uidFromAddress(self.db, recipient, create, **user_props)

            # if all's well, add the recipient to the list
            if recipient:
                recipients.append(recipient)

        #
        # handle the subject argument list
        #
        # figure what the properties of this Class are
        properties = cl.getprops()
        props = {}
        args = matches['args']
        argswhole = matches['argswhole']
        if args:
            if sfxmode == 'none':
                title += ' ' + argswhole
            else:
                errors, props = setPropArrayFromString(self, cl, args, nodeid)
                # handle any errors parsing the argument list
                if errors:
                    if sfxmode == 'strict':
                        errors = '\n- '.join(map(str, errors))
                        raise MailUsageError, _("""
There were problems handling your subject line argument list:
- %(errors)s

Subject was: "%(subject)s"
""") % locals()
                    else:
                        title += ' ' + argswhole


        # set the issue title to the subject
        title = title.strip()
        if (title and properties.has_key('title') and not
                issue_props.has_key('title')):
            issue_props['title'] = title

        #
        # handle message-id and in-reply-to
        #
        messageid = message.getheader('message-id')
        # generate a messageid if there isn't one
        if not messageid:
            messageid = "<%s.%s.%s%s@%s>"%(time.time(), random.random(),
                classname, nodeid, config['MAIL_DOMAIN'])

        # if they've enabled PGP processing then verify the signature
        # or decrypt the message

        # if PGP_ROLES is specified the user must have a Role in the list
        # or we will skip PGP processing
        def pgp_role():
            if self.instance.config.PGP_ROLES:
                return user_has_role(self.db, author,
                    self.instance.config.PGP_ROLES)
            else:
                return True

        if self.instance.config.PGP_ENABLE and pgp_role():
            assert pyme, 'pyme is not installed'
            # signed/encrypted mail must come from the primary address
            author_address = self.db.user.get(author, 'address')
            if self.instance.config.PGP_HOMEDIR:
                os.environ['GNUPGHOME'] = self.instance.config.PGP_HOMEDIR
            if message.pgp_signed():
                message.verify_signature(author_address)
            elif message.pgp_encrypted():
                # replace message with the contents of the decrypted
                # message for content extraction
                # TODO: encrypted message handling is far from perfect
                # bounces probably include the decrypted message, for
                # instance :(
                message = message.decrypt(author_address)
            else:
                raise MailUsageError, _("""
This tracker has been configured to require all email be PGP signed or
encrypted.""")
        # now handle the body - find the message
        ig = self.instance.config.MAILGW_IGNORE_ALTERNATIVES
        content, attachments = message.extract_content(ignore_alternatives = ig)
        if content is None:
            raise MailUsageError, _("""
Roundup requires the submission to be plain text. The message parser could
not find a text/plain part to use.
""")

        # parse the body of the message, stripping out bits as appropriate
        summary, content = parseContent(content, config=config)
        content = content.strip()

        #
        # handle the attachments
        #
        if properties.has_key('files'):
            files = []
            for (name, mime_type, data) in attachments:
                if not self.db.security.hasPermission('Create', author, 'file'):
                    raise Unauthorized, _(
                        'You are not permitted to create files.')
                if not name:
                    name = "unnamed"
                try:
                    fileid = self.db.file.create(type=mime_type, name=name,
                         content=data, **file_props)
                except exceptions.Reject:
                    pass
                else:
                    files.append(fileid)
            # attach the files to the issue
            if not self.db.security.hasPermission('Edit', author,
                    classname, 'files'):
                raise Unauthorized, _(
                    'You are not permitted to add files to %(classname)s.'
                    ) % locals()

            if nodeid:
                # extend the existing files list
                fileprop = cl.get(nodeid, 'files')
                fileprop.extend(files)
                props['files'] = fileprop
            else:
                # pre-load the files list
                props['files'] = files

        #
        # create the message if there's a message body (content)
        #
        if (content and properties.has_key('messages')):
            if not self.db.security.hasPermission('Create', author, 'msg'):
                raise Unauthorized, _(
                    'You are not permitted to create messages.')

            try:
                message_id = self.db.msg.create(author=author,
                    recipients=recipients, date=date.Date('.'),
                    summary=summary, content=content, files=files,
                    messageid=messageid, inreplyto=inreplyto, **msg_props)
            except exceptions.Reject as error:
                raise MailUsageError, _("""
Mail message was rejected by a detector.
%(error)s
""") % locals()
            # attach the message to the node
            if not self.db.security.hasPermission('Edit', author,
                    classname, 'messages'):
                raise Unauthorized, _(
                    'You are not permitted to add messages to %(classname)s.'
                    ) % locals()

            if nodeid:
                # add the message to the node's list
                messages = cl.get(nodeid, 'messages')
                messages.append(message_id)
                props['messages'] = messages
            else:
                # pre-load the messages list
                props['messages'] = [message_id]

        #
        # perform the node change / create
        #
        try:
            # merge the command line props defined in issue_props into
            # the props dictionary because function(**props, **issue_props)
            # is a syntax error.
            for prop in issue_props.keys() :
                if not props.has_key(prop) :
                    props[prop] = issue_props[prop]

            # Check permissions for each property
            for prop in props.keys():
                if not self.db.security.hasPermission('Edit', author,
                        classname, prop):
                    raise Unauthorized, _('You are not permitted to edit '
                        'property %(prop)s of class %(classname)s.') % locals()

            if nodeid:
                cl.set(nodeid, **props)
            else:
                nodeid = cl.create(**props)
        except (TypeError, IndexError, ValueError, exceptions.Reject) as message:
            raise MailUsageError, _("""
There was a problem with the message you sent:
   %(message)s
""") % locals()

        # commit the changes to the DB
        self.db.commit()

        return nodeid


def setPropArrayFromString(self, cl, propString, nodeid=None):
    ''' takes string of form prop=value,value;prop2=value
        and returns (error, prop[..])
    '''
    props = {}
    errors = []
    for prop in string.split(propString, ';'):
        # extract the property name and value
        try:
            propname, value = prop.split('=')
        except ValueError as message:
            errors.append(_('not of form [arg=value,value,...;'
                'arg=value,value,...]'))
            return (errors, props)
        # convert the value to a hyperdb-usable value
        propname = propname.strip()
        try:
            props[propname] = hyperdb.rawToHyperdb(self.db, cl, nodeid,
                propname, value)
        except hyperdb.HyperdbValueError as message:
            errors.append(str(message))
    return errors, props


def extractUserFromList(userClass, users):
    '''Given a list of users, try to extract the first non-anonymous user
       and return that user, otherwise return None
    '''
    if len(users) > 1:
        for user in users:
            # make sure we don't match the anonymous or admin user
            if userClass.get(user, 'username') in ('admin', 'anonymous'):
                continue
            # first valid match will do
            return user
        # well, I guess we have no choice
        return user[0]
    elif users:
        return users[0]
    return None


def uidFromAddress(db, address, create=1, **user_props):
    ''' address is from the rfc822 module, and therefore is (name, addr)

        user is created if they don't exist in the db already
        user_props may supply additional user information
    '''
    (realname, address) = address

    # try a straight match of the address
    user = extractUserFromList(db.user, db.user.stringFind(address=address))
    if user is not None:
        return user

    # try the user alternate addresses if possible
    props = db.user.getprops()
    if props.has_key('alternate_addresses'):
        users = db.user.filter(None, {'alternate_addresses': address})
        user = extractUserFromList(db.user, users)
        if user is not None:
            return user

    # try to match the username to the address (for local
    # submissions where the address is empty)
    user = extractUserFromList(db.user, db.user.stringFind(username=address))

    # couldn't match address or username, so create a new user
    if create:
        # generate a username
        if '@' in address:
            username = address.split('@')[0]
        else:
            username = address
        trying = username
        n = 0
        while 1:
            try:
                # does this username exist already?
                db.user.lookup(trying)
            except KeyError:
                break
            n += 1
            trying = username + str(n)

        # create!
        try:
            return db.user.create(username=trying, address=address,
                realname=realname, roles=db.config.NEW_EMAIL_USER_ROLES,
                password=password.Password(password.generatePassword()),
                **user_props)
        except exceptions.Reject:
            return 0
    else:
        return 0

def parseContent(content, keep_citations=None, keep_body=None, config=None):
    """Parse mail message; return message summary and stripped content

    The message body is divided into sections by blank lines.
    Sections where the second and all subsequent lines begin with a ">"
    or "|" character are considered "quoting sections". The first line of
    the first non-quoting section becomes the summary of the message.

    Arguments:

        keep_citations: declared for backward compatibility.
            If omitted or None, use config["MAILGW_KEEP_QUOTED_TEXT"]

        keep_body: declared for backward compatibility.
            If omitted or None, use config["MAILGW_LEAVE_BODY_UNCHANGED"]

        config: tracker configuration object.
            If omitted or None, use default configuration.

    """
    if config is None:
        config = configuration.CoreConfig()
    if keep_citations is None:
        keep_citations = config["MAILGW_KEEP_QUOTED_TEXT"]
    if keep_body is None:
        keep_body = config["MAILGW_LEAVE_BODY_UNCHANGED"]
    eol = config["MAILGW_EOL_RE"]
    signature = config["MAILGW_SIGN_RE"]
    original_msg = config["MAILGW_ORIGMSG_RE"]

    # strip off leading carriage-returns / newlines
    i = 0
    for i in range(len(content)):
        if content[i] not in '\r\n':
            break
    if i > 0:
        sections = config["MAILGW_BLANKLINE_RE"].split(content[i:])
    else:
        sections = config["MAILGW_BLANKLINE_RE"].split(content)

    # extract out the summary from the message
    summary = ''
    l = []
    for section in sections:
        #section = section.strip()
        if not section:
            continue
        lines = eol.split(section)
        if (lines[0] and lines[0][0] in '>|') or (len(lines) > 1 and
                lines[1] and lines[1][0] in '>|'):
            # see if there's a response somewhere inside this section (ie.
            # no blank line between quoted message and response)
            for line in lines[1:]:
                if line and line[0] not in '>|':
                    break
            else:
                # we keep quoted bits if specified in the config
                if keep_citations:
                    l.append(section)
                continue
            # keep this section - it has reponse stuff in it
            lines = lines[lines.index(line):]
            section = '\n'.join(lines)
            # and while we're at it, use the first non-quoted bit as
            # our summary
            summary = section

        if not summary:
            # if we don't have our summary yet use the first line of this
            # section
            summary = section
        elif signature.match(lines[0]) and 2 <= len(lines) <= 10:
            # lose any signature
            break
        elif original_msg.match(lines[0]):
            # ditch the stupid Outlook quoting of the entire original message
            break

        # and add the section to the output
        l.append(section)

    # figure the summary - find the first sentence-ending punctuation or the
    # first whole line, whichever is longest
    sentence = re.search(r'^([^!?\.]+[!?\.])', summary)
    if sentence:
        sentence = sentence.group(1)
    else:
        sentence = ''
    first = eol.split(summary)[0]
    summary = max(sentence, first)

    # Now reconstitute the message content minus the bits we don't care
    # about.
    if not keep_body:
        content = '\n\n'.join(l)

    return summary, content

# vim: set filetype=python sts=4 sw=4 et si :

blob
mark :782
data 6349
#! /usr/bin/env python
# -*- coding: iso-8859-1 -*-
# Written by Martin v. Lwis <loewis@informatik.hu-berlin.de>
# Plural forms support added by alexander smishlajev <alex@tycobka.lv>

"""Generate binary message catalog from textual translation description.

This program converts a textual Uniforum-style message catalog (.po file) into
a binary GNU catalog (.mo file).  This is essentially the same function as the
GNU msgfmt program, however, it is a simpler implementation.

Usage: msgfmt.py [OPTIONS] filename.po

Options:
    -o file
    --output-file=file
        Specify the output file to write to.  If omitted, output will go to a
        file named filename.mo (based off the input file name).

    -h
    --help
        Print this message and exit.

    -V
    --version
        Display version information and exit.
"""

import sys
import os
import getopt
import struct
import array

__version__ = "1.1"

MESSAGES = {}



def usage(code, msg=''):
    print >> sys.stderr, __doc__
    if msg:
        print >> sys.stderr, msg
    sys.exit(code)



def add(id, str, fuzzy):
    "Add a non-fuzzy translation to the dictionary."
    global MESSAGES
    if not fuzzy and str and not str.startswith('\0'):
        MESSAGES[id] = str



def generate():
    "Return the generated output."
    global MESSAGES
    keys = MESSAGES.keys()
    # the keys are sorted in the .mo file
    keys.sort()
    offsets = []
    ids = strs = ''
    for id in keys:
        # For each string, we need size and file offset.  Each string is NUL
        # terminated; the NUL does not count into the size.
        offsets.append((len(ids), len(id), len(strs), len(MESSAGES[id])))
        ids += id + '\0'
        strs += MESSAGES[id] + '\0'
    output = ''
    # The header is 7 32-bit unsigned integers.  We don't use hash tables, so
    # the keys start right after the index tables.
    # translated string.
    keystart = 7*4+16*len(keys)
    # and the values start after the keys
    valuestart = keystart + len(ids)
    koffsets = []
    voffsets = []
    # The string table first has the list of keys, then the list of values.
    # Each entry has first the size of the string, then the file offset.
    for o1, l1, o2, l2 in offsets:
        koffsets += [l1, o1+keystart]
        voffsets += [l2, o2+valuestart]
    offsets = koffsets + voffsets
    output = struct.pack("Iiiiiii",
                         0x950412deL,       # Magic
                         0,                 # Version
                         len(keys),         # # of entries
                         7*4,               # start of key index
                         7*4+len(keys)*8,   # start of value index
                         0, 0)              # size and offset of hash table
    output += array.array("i", offsets).tostring()
    output += ids
    output += strs
    return output



def make(filename, outfile):
    ID = 1
    STR = 2
    global MESSAGES
    MESSAGES = {}

    # Compute .mo name from .po name and arguments
    if filename.endswith('.po'):
        infile = filename
    else:
        infile = filename + '.po'
    if outfile is None:
        outfile = os.path.splitext(infile)[0] + '.mo'

    try:
        lines = open(infile).readlines()
    except IOError as msg:
        print >> sys.stderr, msg
        sys.exit(1)

    # remove UTF-8 Byte Order Mark, if any.
    # (UCS2 BOMs are not handled because messages in UCS2 cannot be handled)
    if lines[0].startswith('\xEF\xBB\xBF'):
        lines[0] = lines[0][3:]

    section = None
    fuzzy = 0

    # Parse the catalog
    lno = 0
    for l in lines:
        lno += 1
        # If we get a comment line after a msgstr, this is a new entry
        if l[0] == '#' and section == STR:
            add(msgid, msgstr, fuzzy)
            section = None
            fuzzy = 0
        # Record a fuzzy mark
        if l[:2] == '#,' and (l.find('fuzzy') >= 0):
            fuzzy = 1
        # Skip comments
        if l[0] == '#':
            continue
        # Start of msgid_plural section, separate from singular form with \0
        if l.startswith('msgid_plural'):
            msgid += '\0'
            l = l[12:]
        # Now we are in a msgid section, output previous section
        elif l.startswith('msgid'):
            if section == STR:
                add(msgid, msgstr, fuzzy)
            section = ID
            l = l[5:]
            msgid = msgstr = ''
        # Now we are in a msgstr section
        elif l.startswith('msgstr'):
            section = STR
            l = l[6:]
            # Check for plural forms
            if l.startswith('['):
                # Separate plural forms with \0
                if not l.startswith('[0]'):
                    msgstr += '\0'
                # Ignore the index - must come in sequence
                l = l[l.index(']') + 1:]
        # Skip empty lines
        l = l.strip()
        if not l:
            continue
        # XXX: Does this always follow Python escape semantics?
        l = eval(l)
        if section == ID:
            msgid += l
        elif section == STR:
            msgstr += l
        else:
            print >> sys.stderr, 'Syntax error on %s:%d' % (infile, lno), \
                  'before:'
            print >> sys.stderr, l
            sys.exit(1)
    # Add last entry
    if section == STR:
        add(msgid, msgstr, fuzzy)

    # Compute output
    output = generate()

    try:
        open(outfile,"wb").write(output)
    except IOError as msg:
        print >> sys.stderr, msg



def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'hVo:',
                                   ['help', 'version', 'output-file='])
    except getopt.error as msg:
        usage(1, msg)

    outfile = None
    # parse options
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage(0)
        elif opt in ('-V', '--version'):
            print >> sys.stderr, "msgfmt.py", __version__
            sys.exit(0)
        elif opt in ('-o', '--output-file'):
            outfile = arg
    # do it
    if not args:
        print >> sys.stderr, 'No input file given'
        print >> sys.stderr, "Try `msgfmt --help' for more information."
        return

    for filename in args:
        make(filename, outfile)


if __name__ == '__main__':
    main()

# vim: set et sts=4 sw=4 :

blob
mark :783
data 6007
#
# Copyright (C) 2007 Stefan Seefeld
# All rights reserved.
# For license terms see the file COPYING.txt.
#

from roundup import hyperdb
from roundup.cgi.exceptions import *
from roundup.exceptions import UsageError
from roundup.date import Date, Range, Interval
from roundup import actions
from SimpleXMLRPCServer import *

def translate(value):
    """Translate value to becomes valid for XMLRPC transmission."""

    if isinstance(value, (Date, Range, Interval)):
        return repr(value)
    elif type(value) is list:
        return [translate(v) for v in value]
    elif type(value) is tuple:
        return tuple([translate(v) for v in value])
    elif type(value) is dict:
        return dict([[translate(k), translate(value[k])] for k in value])
    else:
        return value


def props_from_args(db, cl, args, itemid=None):
    """Construct a list of properties from the given arguments,
    and return them after validation."""

    props = {}
    for arg in args:
        if arg.find('=') == -1:
            raise UsageError, 'argument "%s" not propname=value'%arg
        l = arg.split('=')
        if len(l) < 2:
            raise UsageError, 'argument "%s" not propname=value'%arg
        key, value = l[0], '='.join(l[1:])
        if value:
            try:
                props[key] = hyperdb.rawToHyperdb(db, cl, itemid,
                                                  key, value)
            except hyperdb.HyperdbValueError as message:
                raise UsageError, message
        else:
            props[key] = None

    return props

class RoundupInstance:
    """The RoundupInstance provides the interface accessible through
    the Python XMLRPC mapping."""

    def __init__(self, db, actions, translator):

        self.db = db
        self.actions = actions
        self.translator = translator

    def list(self, classname, propname=None):
        cl = self.db.getclass(classname)
        if not propname:
            propname = cl.labelprop()
        result = [cl.get(itemid, propname)
                  for itemid in cl.list()
                  if self.db.security.hasPermission('View', self.db.getuid(),
                                                    classname, propname, itemid)
                  ]
        return result

    def filter(self, classname, search_matches, filterspec,
               sort=[], group=[]):
        cl = self.db.getclass(classname)
        result = cl.filter(search_matches, filterspec, sort=sort, group=group)
        return result

    def display(self, designator, *properties):
        classname, itemid = hyperdb.splitDesignator(designator)
        cl = self.db.getclass(classname)
        props = properties and list(properties) or cl.properties.keys()
        props.sort()
        for p in props:
            if not self.db.security.hasPermission('View', self.db.getuid(),
                                                  classname, p, itemid):
                raise Unauthorised('Permission to view %s of %s denied'%
                                   (p, designator))
            result = [(prop, cl.get(itemid, prop)) for prop in props]
        return dict(result)

    def create(self, classname, *args):
        
        if not self.db.security.hasPermission('Create', self.db.getuid(), classname):
            raise Unauthorised('Permission to create %s denied'%classname)

        cl = self.db.getclass(classname)

        # convert types
        props = props_from_args(self.db, cl, args)

        # check for the key property
        key = cl.getkey()
        if key and not props.has_key(key):
            raise UsageError, 'you must provide the "%s" property.'%key

        for key in props:
            if not self.db.security.hasPermission('Edit', self.db.getuid(), classname,
                                                  property=key):
                raise Unauthorised('Permission to create %s denied'%classname)

        # do the actual create
        try:
            result = cl.create(**props)
        except (TypeError, IndexError, ValueError) as message:
            raise UsageError, message
        return result

    def set(self, designator, *args):

        classname, itemid = hyperdb.splitDesignator(designator)
        cl = self.db.getclass(classname)
        props = props_from_args(self.db, cl, args, itemid) # convert types
        for p in props.iterkeys():
            if not self.db.security.hasPermission('Edit', self.db.getuid(),
                                                  classname, p, itemid):
                raise Unauthorised('Permission to edit %s of %s denied'%
                                   (p, designator))
        try:
            return cl.set(itemid, **props)
        except (TypeError, IndexError, ValueError) as message:
            raise UsageError, message


    builtin_actions = {'retire': actions.Retire}

    def action(self, name, *args):
        """Execute a named action."""
        
        if name in self.actions:
            action_type = self.actions[name]
        elif name in self.builtin_actions:
            action_type = self.builtin_actions[name]
        else:
            raise Exception('action "%s" is not supported %s' % (name, ','.join(self.actions.keys())))
        action = action_type(self.db, self.translator)
        return action.execute(*args)


class RoundupDispatcher(SimpleXMLRPCDispatcher):
    """RoundupDispatcher bridges from cgi.client to RoundupInstance.
    It expects user authentication to be done."""

    def __init__(self, db, actions, translator,
                 allow_none=False, encoding=None):

        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)
        self.register_instance(RoundupInstance(db, actions, translator))
                 

    def dispatch(self, input):
        return self._marshaled_dispatch(input)

    def _dispatch(self, method, params):

        retn = SimpleXMLRPCDispatcher._dispatch(self, method, params)
        retn = translate(retn)
        return retn
    

blob
mark :784
data 17490
#!/usr/bin/python
#
# notify-roundup.py: call into a roundup tracker to notify it of commits
#
# USAGE: notify-roundup.py TRACKER-HOME REPOS-DIR REVISION
#        notify-roundup.py TRACKER-HOME REPOS-DIR REVISION AUTHOR PROPNAME
#
#   TRACKER-HOME is the tracker to notify
#
# See end of file for change history

import sys, os, time, cStringIO, re, logging, smtplib, ConfigParser, socket
import commands

# configure logging
logger = logging.getLogger('notify-roundup')
hdlr = logging.FileHandler('/tmp/log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.propogate = False
logger.setLevel(logging.DEBUG)

#print sys.argv
# now try to import stuff that might not work
try:
    import roundup.instance, roundup.date

    import svn.fs
    import svn.delta
    import svn.repos
    import svn.core
    
    from mercurial import ui, hg
except:
    logger.exception('Exception while importing Roundup and SVN/hg')
    sys.exit(1)
    

class Failed(Exception):
    pass
class Unauthorised(Failed):
    pass

def main(pool):
    '''Handle the commit revision.
    '''
    # command-line args
    cfg = ConfigParser.ConfigParser()
    cfg.read(sys.argv[1])
    repos_dir = sys.argv[2]

    
    vcs_type = cfg.get('vcs', 'type')
    
    if vcs_type == 'svn' or vcs_type == 'bzr' or vcs_type == 'git':
        revision = sys.argv[3]
    elif vcs_type == 'hg':
        revisions = sys.argv[3].split(':')
        revision = revisions[1].lstrip()
    else:
        logging.error('something wen\'t wrong')
        
    # get a handle on the revision in the VCS repository
    if vcs_type == 'svn':
        repos = SVNRepository(repos_dir, revision, pool)
    elif vcs_type == 'hg':
        repos = HGRepository(repos_dir, revision, pool)
    else:
        logging.error('we currently don\'t support %s VCS type'%vcs_type)
      
    repos.klass = cfg.get('main', 'item-class')
    if not repos.extract_info():
        return

    if cfg.has_option('main', 'host'):
        repos.host = cfg.get('main', 'host')
    else:
        repos.host = socket.gethostname()

    mode = cfg.get('main', 'mode')
    if mode == 'local':
        notify_local(cfg.get('local', 'tracker-home'), repos)
    elif mode == 'email':
        tracker_address = cfg.get('email', 'tracker-address')
        domain = cfg.get('email', 'default-domain')
        smtp_host = cfg.get('email', 'smtp-host')
        if cfg.has_option('address mappings', repos.author):
            mapped_email = cfg.get('address mappings', repos.author)
        elif cfg.has_option('address mappings', '*'):
            mapped_email = cfg.get('address mappings', '*')
        else:
            mapped_email = repos.author
        if '@' not in mapped_email:
            mapped_email += domain
        notify_email(tracker_address, mapped_email, smtp_host, repos)
    else:
        logging.error('invalid mode %s in config file'%mode)


def notify_email(tracker_address, from_address, smtp_host, repos):
    subject = '[%s%s] SVN commit message'%(repos.klass, repos.itemid)
    if repos.status:
        subject += ' [status=%s]'%repos.status
    date = time.strftime('%Y-%m-%d %H:%M:%S', repos.date)
    message = '''From: %s
To: %s
Subject: %s

revision=%s
host=%s
repos=%s
date=%s
summary=%s

%s'''%(from_address, tracker_address, subject, repos.rev, repos.host,
    repos.repos_dir, date, repos.summary, repos.message)

    logger.debug('MESSAGE TO SEND\n%s'%message)

    smtp = smtplib.SMTP(smtp_host)
    try:
        smtp.sendmail(from_address, [tracker_address], message)
    except:
        logging.exception('mail to %r from %r via %r'%(tracker_address,
            from_address, smtp_host))

def notify_local(tracker_home, repos):
    # get a handle on the tracker db
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open('admin')
    try:
        notify_local_inner(db, tracker_home, repos)
    except:
        db.rollback()
        db.close()
        raise

def notify_local_inner(db, tracker_home, repos):
    # sanity check
    try:
        db.getclass(repos.klass)
    except KeyError:
        logger.error('no such tracker class %s'%repos.klass)
        raise Failed
    if not db.getclass(repos.klass).hasnode(repos.itemid):
        logger.error('no such %s item %s'%(repos.klass, repos.itemid))
        raise Failed
    if repos.status:
        try:
            status_id = db.status.lookup(repos.status)
        except KeyError:
            logger.error('no such status %s'%repos.status)
            raise Failed

    print repos.host, repos.repos_dir
    # get the svn repo information from the tracker
    try:
        vcs_repo_id = db.vcs_repo.stringFind(host=repos.host,
            path=repos.repos_dir)[0]
    except IndexError:
        logger.error('no repository %s in tracker'%repos.repos_dir)
        raise Failed

    
    # log in as the appropriate user
    try:
        matches = db.user.stringFind(vcs_name=repos.author)
    except KeyError:
        # the user class has no property "svn_name"
        matches = []
    if matches:
        userid = matches[0]
    else:
        try:
            userid = db.user.lookup(repos.author)
        except KeyError:
            raise Failed, 'no Roundup user matching %s'%repos.author
    username = db.user.get(userid, 'username')
    
    db.close()

    # tell Roundup
    tracker = roundup.instance.open(tracker_home)
    db = tracker.open(username)

    # check perms
    if not db.security.hasPermission('Create', userid, 'vcs_rev'):
        raise Unauthorised, "Can't create items of class 'vcs_rev'"
    if not db.security.hasPermission('Create', userid, 'msg'):
        raise Unauthorised, "Can't create items of class 'msg'"
    if not db.security.hasPermission('Edit', userid, repos.klass,
            'messages', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass
    if repos.status and not db.security.hasPermission('Edit', userid,
            repos.klass, 'status', repos.itemid):
        raise Unauthorised, "Can't edit items of class '%s'"%repos.klass

    # create the revision
    vcs_rev_id = db.vcs_rev.create(repository=vcs_repo_id, revision=repos.rev)

    # add the message to the spool
    date = roundup.date.Date(repos.date)
    msgid = db.msg.create(content=repos.message, summary=repos.summary,
        author=userid, date=date, revision=vcs_rev_id)
    klass = db.getclass(repos.klass)
    messages = klass.get(repos.itemid, 'messages')
    messages.append(msgid)
    klass.set(repos.itemid, messages=messages)
    
    # and set the status
    if repos.status:
        klass.set(repos.itemid, status=status_id)

    db.commit()
    logger.debug('Roundup modification complete')
    db.close()


def _select_adds(change):
  return change.added
def _select_deletes(change):
  return change.path is None
def _select_modifies(change):
  return not change.added and change.path is not None


def generate_list(output, header, changelist, selection):
    items = [ ]
    for path, change in changelist:
      if selection(change):
        items.append((path, change))
    if not items:
      return

    output.write('%s:\n' % header)
    for fname, change in items:
      if change.item_kind == svn.core.svn_node_dir:
        is_dir = '/'
      else:
        is_dir = ''
      if change.prop_changes:
        if change.text_changed:
          props = '   (contents, props changed)'
        else:
          props = '   (props changed)'
      else:
        props = ''
      output.write('   %s%s%s\n' % (fname, is_dir, props))
      if change.added and change.base_path:
        if is_dir:
          text = ''
        elif change.text_changed:
          text = ', changed'
        else:
          text = ' unchanged'
        output.write('      - copied%s from r%d, %s%s\n'
                     % (text, change.base_rev, change.base_path[1:], is_dir))


class DarcsRepository:
    '''Holds root and other information about the darcs repository.
       THIS IS WIP AND HASN'T BEEN TESTED AT ALL
    '''
    
    def __init__(self,repos_dir,rev,pool):
    
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('
class BZRRepository:
    '''Holds roots and other information about the bzr repository.
       THIS IS WIP AND HASN'T BEEN TESTED AT ALL!
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('bzr log -r-1 ' + self.repos_dir + ' | grep committer')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        author_split2 = authoro[0].rstrip('>').split()
        self.author = author_split[0].lower()
    
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = commands.getoutput('bzr log -r-1 ' + self.repos_dir) or ''
        log_mine = log.split('message:')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        self.summary = "This is bzr change"
        self.date = time.localtime()
        
        return True
                


class GitRepository:
    '''Holds roots and other information about the git repository.
       THIS IS WIP AND HASN'T BEEN TESTED AT ALL!
    '''
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
    
        authors_calls = commands.getoutput('cd ' + self.repos_dir + '; git log --pretty=format:%an | head -n1')
        authors_split = authors_calls.split()
        self.author = authors_split[0].lower()
    
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = commands.getoutput('cd ' + self.repos_dir + '; git log --pretty=format:%s | head -n1') or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        self.summary = "This is git change"
        self.date = time.localtime()
        
        return True
           
    
    
class HGRepository:
    '''Holds roots and other information about the hg repository.
    '''
    
    def __init__(self,repos_dir,rev,pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool
        
        authors_calls = commands.getoutput('hg log ' + self.repos_dir + ' --rev=tip | grep user')
        authors_split = authors_calls.split(':')
        authoro = authors_split[1].lstrip().split('<')
        author_split2 = authoro[0].rstrip('>').split()
        self.author = author_split2[0].lower()

        
    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = commands.getoutput('hg log ' + self.repos_dir + ' --rev=tip | grep summary') or ''
        log_mine = log.split(':')
        log_mines = log_mine[1].lstrip()
        for line in log_mines.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return
            
        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))
        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()
        
        output.write('Log:\n%s\n'%log_mines)

        self.message = output.getvalue()
        self.summary = "This is hg change"
        self.date = time.localtime()
        
        return True
        
    
class SVNRepository:
    '''Hold roots and other information about the svn repository. From mailer.py
    '''
    def __init__(self, repos_dir, rev, pool):
        self.repos_dir = repos_dir
        self.rev = rev
        self.pool = pool

        self.repos_ptr = svn.repos.svn_repos_open(repos_dir, pool)
        self.fs_ptr = svn.repos.svn_repos_fs(self.repos_ptr)
        
        self.roots = {}

        self.root_this = self.roots[rev] = svn.fs.revision_root(self.fs_ptr,
            rev, self.pool)

        self.author = self.get_rev_prop(svn.core.SVN_PROP_REVISION_AUTHOR)

    def get_rev_prop(self, propname):
        return svn.fs.revision_prop(self.fs_ptr, self.rev, propname, self.pool)

    def extract_info(self):
        issue_re = re.compile('^\s*(%s)\s*(\d+)(\s+(\S+))?\s*$'%self.klass,
            re.I)

        # parse for Roundup item information
        log = self.get_rev_prop(svn.core.SVN_PROP_REVISION_LOG) or ''
        for line in log.splitlines():
            m = issue_re.match(line)
            if m:
                break
        else:
            # nothing to do
            return

        # parse out the issue information
        klass = m.group(1)
        self.itemid = m.group(2)

        issue = klass + self.itemid
        self.status = m.group(4)

        logger.debug('Roundup info item=%r, status=%r'%(issue, self.status))

        # get all the changes and sort by path
        editor = svn.repos.RevisionChangeCollector(self.fs_ptr, self.rev,
            self.pool)
        e_ptr, e_baton = svn.delta.make_editor(editor, self.pool)
        svn.repos.svn_repos_replay(self.root_this, e_ptr, e_baton, self.pool)

        changelist = editor.changes.items()
        changelist.sort()

        # figure out the changed directories
        dirs = { }
        for path, change in changelist:
            if change.item_kind == svn.core.svn_node_dir:
                dirs[path] = None
            else:
                idx = path.rfind('/')
                if idx == -1:
                    dirs[''] = None
                else:
                    dirs[path[:idx]] = None

        dirlist = dirs.keys()

        # figure out the common portion of all the dirs. note that there is
        # no "common" if only a single dir was changed, or the root was changed.
        if len(dirs) == 1 or dirs.has_key(''):
            commondir = ''
        else:
            common = dirlist.pop().split('/')
            for d in dirlist:
                parts = d.split('/')
                for i in range(len(common)):
                    if i == len(parts) or common[i] != parts[i]:
                        del common[i:]
                        break
            commondir = '/'.join(common)
            if commondir:
                # strip the common portion from each directory
                l = len(commondir) + 1
                dirlist = [ ]
                for d in dirs.keys():
                    if d == commondir:
                        dirlist.append('.')
                    else:
                        dirlist.append(d[l:])
            else:
                # nothing in common, so reset the list of directories
                dirlist = dirs.keys()

        # compose the basic subject line. later, we can prefix it.
        dirlist.sort()
        dirlist = ' '.join(dirlist)

        if commondir:
            self.summary = 'r%d - in %s: %s' % (self.rev, commondir, dirlist)
        else:
            self.summary = 'r%d - %s' % (self.rev, dirlist)

        # Generate email for the various groups and option-params.
        output = cStringIO.StringIO()

        # print summary sections
        generate_list(output, 'Added', changelist, _select_adds)
        generate_list(output, 'Removed', changelist, _select_deletes)
        generate_list(output, 'Modified', changelist, _select_modifies)

        output.write('Log:\n%s\n'%log)

        self.message = output.getvalue()

        svndate = self.get_rev_prop(svn.core.SVN_PROP_REVISION_DATE)
        self.date = time.localtime(svn.core.secs_from_timestr(svndate,
            self.pool))

        return True

if __name__ == '__main__':
    try:
        svn.core.run_app(main)
    except Failed, message:
        logger.error(message)
        sys.exit(1)
    except:
        logger.exception('top level')
        sys.exit(1)


commit refs/heads/gsoc-2009
mark :785
author Pygi <pygi@users.sourceforge.net> 1248410105 +0000
committer Pygi <pygi@users.sourceforge.net> 1248410105 +0000
data 36
Some preparations for 3.0 migration
from :776
property svn 4 4334
M 100644 :777 roundup/admin.py
M 100644 :778 roundup/hyperdb.py
M 100644 :779 roundup/init.py
M 100644 :780 roundup/mailer.py
M 100644 :781 roundup/mailgw.py
M 100644 :782 roundup/msgfmt.py
M 100644 :783 roundup/xmlrpc.py
M 100755 :784 scripts/notify-roundup/notify-roundup.py

blob
mark :786
data 57524
#! /usr/bin/env python
#
# Copyright (c) 2001 Bizar Software Pty Ltd (http://www.bizarsoftware.com.au/)
# This module is free software, and you may redistribute it and/or modify
# under the same terms as Python, so long as this copyright message and
# disclaimer are retained in their original form.
#
# IN NO EVENT SHALL BIZAR SOFTWARE PTY LTD BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# BIZAR SOFTWARE PTY LTD SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
# BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS"
# BASIS, AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
# SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#

"""Administration commands for maintaining Roundup trackers.
"""
__docformat__ = 'restructuredtext'

import csv, getopt, getpass, os, re, shutil, sys, UserDict

from roundup import date, hyperdb, roundupdb, init, password, token
from roundup import __version__ as roundup_version
import roundup.instance
from roundup.configuration import CoreConfig
from roundup.i18n import _
from roundup.exceptions import UsageError

class CommandDict(UserDict.UserDict):
    """Simple dictionary that lets us do lookups using partial keys.

    Original code submitted by Engelbert Gruber.
    """
    _marker = []
    def get(self, key, default=_marker):
        if self.data.has_key(key):
            return [(key, self.data[key])]
        keylist = self.data.keys()
        keylist.sort()
        l = []
        for ki in keylist:
            if ki.startswith(key):
                l.append((ki, self.data[ki]))
        if not l and default is self._marker:
            raise KeyError, key
        return l

class AdminTool:
    """ A collection of methods used in maintaining Roundup trackers.

        Typically these methods are accessed through the roundup-admin
        script. The main() method provided on this class gives the main
        loop for the roundup-admin script.

        Actions are defined by do_*() methods, with help for the action
        given in the method docstring.

        Additional help may be supplied by help_*() methods.
    """
    def __init__(self):
        self.commands = CommandDict()
        for k in AdminTool.__dict__.keys():
            if k[:3] == 'do_':
                self.commands[k[3:]] = getattr(self, k)
        self.help = {}
        for k in AdminTool.__dict__.keys():
            if k[:5] == 'help_':
                self.help[k[5:]] = getattr(self, k)
        self.tracker_home = ''
        self.db = None
        self.db_uncommitted = False

    def get_class(self, classname):
        """Get the class - raise an exception if it doesn't exist.
        """
        try:
            return self.db.getclass(classname)
        except KeyError:
            raise UsageError, _('no such class "%(classname)s"')%locals()

    def props_from_args(self, args):
        """ Produce a dictionary of prop: value from the args list.

            The args list is specified as ``prop=value prop=value ...``.
        """
        props = {}
        for arg in args:
            if arg.find('=') == -1:
                raise UsageError, _('argument "%(arg)s" not propname=value'
                    )%locals()
            l = arg.split('=')
            if len(l) < 2:
                raise UsageError, _('argument "%(arg)s" not propname=value'
                    )%locals()
            key, value = l[0], '='.join(l[1:])
            if value:
                props[key] = value
            else:
                props[key] = None
        return props

    def usage(self, message=''):
        """ Display a simple usage message.
        """
        if message:
            message = _('Problem: %(message)s\n\n')%locals()
        print _("""%(message)sUsage: roundup-admin [options] [<command> <arguments>]

Options:
 -i instance home  -- specify the issue tracker "home directory" to administer
 -u                -- the user[:password] to use for commands
 -d                -- print full designators not just class id numbers
 -c                -- when outputting lists of data, comma-separate them.
                      Same as '-S ","'.
 -S <string>       -- when outputting lists of data, string-separate them
 -s                -- when outputting lists of data, space-separate them.
                      Same as '-S " "'.
 -V                -- be verbose when importing
 -v                -- report Roundup and Python versions (and quit)

 Only one of -s, -c or -S can be specified.

Help:
 roundup-admin -h
 roundup-admin help                       -- this help
 roundup-admin help <command>             -- command-specific help
 roundup-admin help all                   -- all available help
""")%locals()
        self.help_commands()

    def help_commands(self):
        """List the commands available with their help summary.
        """
        print _('Commands:'),
        commands = ['']
        for command in self.commands.values():
            h = _(command.__doc__).split('\n')[0]
            commands.append(' '+h[7:])
        commands.sort()
        commands.append(_(
"""Commands may be abbreviated as long as the abbreviation
matches only one command, e.g. l == li == lis == list."""))
        print '\n'.join(commands)
        print

    def help_commands_html(self, indent_re=re.compile(r'^(\s+)\S+')):
        """ Produce an HTML command list.
        """
        commands = self.commands.values()
        def sortfun(a, b):
            return cmp(a.__name__, b.__name__)
        commands.sort(sortfun)
        for command in commands:
            h = _(command.__doc__).split('\n')
            name = command.__name__[3:]
            usage = h[0]
            print """
<tr><td valign=top><strong>%(name)s</strong></td>
    <td><tt>%(usage)s</tt><p>
<pre>""" % locals()
            indent = indent_re.match(h[3])
            if indent: indent = len(indent.group(1))
            for line in h[3:]:
                if indent:
                    print line[indent:]
                else:
                    print line
            print '</pre></td></tr>\n'

    def help_all(self):
        print _("""
All commands (except help) require a tracker specifier. This is just
the path to the roundup tracker you're working with. A roundup tracker
is where roundup keeps the database and configuration file that defines
an issue tracker. It may be thought of as the issue tracker's "home
directory". It may be specified in the environment variable TRACKER_HOME
or on the command line as "-i tracker".

A designator is a classname and a nodeid concatenated, eg. bug1, user10, ...

Property values are represented as strings in command arguments and in the
printed results:
 . Strings are, well, strings.
 . Date values are printed in the full date format in the local time zone,
   and accepted in the full format or any of the partial formats explained
   below.
 . Link values are printed as node designators. When given as an argument,
   node designators and key strings are both accepted.
 . Multilink values are printed as lists of node designators joined
   by commas.  When given as an argument, node designators and key
   strings are both accepted; an empty string, a single node, or a list
   of nodes joined by commas is accepted.

When property values must contain spaces, just surround the value with
quotes, either ' or ". A single space may also be backslash-quoted. If a
value must contain a quote character, it must be backslash-quoted or inside
quotes. Examples:
           hello world      (2 tokens: hello, world)
           "hello world"    (1 token: hello world)
           "Roch'e" Compaan (2 tokens: Roch'e Compaan)
           Roch\\'e Compaan  (2 tokens: Roch'e Compaan)
           address="1 2 3"  (1 token: address=1 2 3)
           \\\\               (1 token: \\)
           \\n\\r\\t           (1 token: a newline, carriage-return and tab)

When multiple nodes are specified to the roundup get or roundup set
commands, the specified properties are retrieved or set on all the listed
nodes.

When multiple results are returned by the roundup get or roundup find
commands, they are printed one per line (default) or joined by commas (with
the -c) option.

Where the command changes data, a login name/password is required. The
login may be specified as either "name" or "name:password".
 . ROUNDUP_LOGIN environment variable
 . the -u command-line option
If either the name or password is not supplied, they are obtained from the
command-line.

Date format examples:
  "2000-04-17.03:45" means <Date 2000-04-17.08:45:00>
  "2000-04-17" means <Date 2000-04-17.00:00:00>
  "01-25" means <Date yyyy-01-25.00:00:00>
  "08-13.22:13" means <Date yyyy-08-14.03:13:00>
  "11-07.09:32:43" means <Date yyyy-11-07.14:32:43>
  "14:25" means <Date yyyy-mm-dd.19:25:00>
  "8:47:11" means <Date yyyy-mm-dd.13:47:11>
  "." means "right now"

Command help:
""")
        for name, command in self.commands.items():
            print _('%s:')%name
            print '   ', _(command.__doc__)

    def do_help(self, args, nl_re=re.compile('[\r\n]'),
            indent_re=re.compile(r'^(\s+)\S+')):
        ''"""Usage: help topic
        Give help about topic.

        commands  -- list commands
        <command> -- help specific to a command
        initopts  -- init command options
        all       -- all available help
        """
        if len(args)>0:
            topic = args[0]
        else:
            topic = 'help'


        # try help_ methods
        if self.help.has_key(topic):
            self.help[topic]()
            return 0

        # try command docstrings
        try:
            l = self.commands.get(topic)
        except KeyError:
            print _('Sorry, no help for "%(topic)s"')%locals()
            return 1

        # display the help for each match, removing the docsring indent
        for name, help in l:
            lines = nl_re.split(_(help.__doc__))
            print lines[0]
            indent = indent_re.match(lines[1])
            if indent: indent = len(indent.group(1))
            for line in lines[1:]:
                if indent:
                    print line[indent:]
                else:
                    print line
        return 0

    def listTemplates(self):
        """ List all the available templates.

        Look in the following places, where the later rules take precedence:

         1. <roundup.admin.__file__>/../../share/roundup/templates/*
            this is where they will be if we installed an egg via easy_install
         2. <prefix>/share/roundup/templates/*
            this should be the standard place to find them when Roundup is
            installed
         3. <roundup.admin.__file__>/../templates/*
            this will be used if Roundup's run in the distro (aka. source)
            directory
         4. <current working dir>/*
            this is for when someone unpacks a 3rd-party template
         5. <current working dir>
            this is for someone who "cd"s to the 3rd-party template dir
        """
        # OK, try <prefix>/share/roundup/templates
        #     and <egg-directory>/share/roundup/templates
        # -- this module (roundup.admin) will be installed in something
        # like:
        #    /usr/lib/python2.5/site-packages/roundup/admin.py  (5 dirs up)
        #    c:\python25\lib\site-packages\roundup\admin.py     (4 dirs up)
        #    /usr/lib/python2.5/site-packages/roundup-1.3.3-py2.5-egg/roundup/admin.py
        #    (2 dirs up)
        #
        # we're interested in where the directory containing "share" is
        templates = {}
        for N in 2, 4, 5:
            path = __file__
            # move up N elements in the path
            for i in range(N):
                path = os.path.dirname(path)
            tdir = os.path.join(path, 'share', 'roundup', 'templates')
            if os.path.isdir(tdir):
                templates = init.listTemplates(tdir)
                break

        # OK, now try as if we're in the roundup source distribution
        # directory, so this module will be in .../roundup-*/roundup/admin.py
        # and we're interested in the .../roundup-*/ part.
        path = __file__
        for i in range(2):
            path = os.path.dirname(path)
        tdir = os.path.join(path, 'templates')
        if os.path.isdir(tdir):
            templates.update(init.listTemplates(tdir))

        # Try subdirs of the current dir
        templates.update(init.listTemplates(os.getcwd()))

        # Finally, try the current directory as a template
        template = init.loadTemplateInfo(os.getcwd())
        if template:
            templates[template['name']] = template

        return templates

    def help_initopts(self):
        templates = self.listTemplates()
        print _('Templates:'), ', '.join(templates.keys())
        import roundup.backends
        backends = roundup.backends.list_backends()
        print _('Back ends:'), ', '.join(backends)

    def do_install(self, tracker_home, args):
        ''"""Usage: install [template [backend [key=val[,key=val]]]]
        Install a new Roundup tracker.

        The command will prompt for the tracker home directory
        (if not supplied through TRACKER_HOME or the -i option).
        The template and backend may be specified on the command-line
        as arguments, in that order.

        Command line arguments following the backend allows you to
        pass initial values for config options.  For example, passing
        "web_http_auth=no,rdbms_user=dinsdale" will override defaults
        for options http_auth in section [web] and user in section [rdbms].
        Please be careful to not use spaces in this argument! (Enclose
        whole argument in quotes if you need spaces in option value).

        The initialise command must be called after this command in order
        to initialise the tracker's database. You may edit the tracker's
        initial database contents before running that command by editing
        the tracker's dbinit.py module init() function.

        See also initopts help.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')

        # make sure the tracker home can be created
        tracker_home = os.path.abspath(tracker_home)
        parent = os.path.split(tracker_home)[0]
        if not os.path.exists(parent):
            raise UsageError, _('Instance home parent directory "%(parent)s"'
                ' does not exist')%locals()

        config_ini_file = os.path.join(tracker_home, CoreConfig.INI_FILE)
        # check for both old- and new-style configs
        if filter(os.path.exists, [config_ini_file,
                os.path.join(tracker_home, 'config.py')]):
            ok = raw_input(_(
"""WARNING: There appears to be a tracker in "%(tracker_home)s"!
If you re-install it, you will lose all the data!
Erase it? Y/N: """) % locals())
            if ok.strip().lower() != 'y':
                return 0

            # clear it out so the install isn't confused
            shutil.rmtree(tracker_home)

        # select template
        templates = self.listTemplates()
        template = len(args) > 1 and args[1] or ''
        if not templates.has_key(template):
            print _('Templates:'), ', '.join(templates.keys())
        while not templates.has_key(template):
            template = raw_input(_('Select template [classic]: ')).strip()
            if not template:
                template = 'classic'

        # select hyperdb backend
        import roundup.backends
        backends = roundup.backends.list_backends()
        backend = len(args) > 2 and args[2] or ''
        if backend not in backends:
            print _('Back ends:'), ', '.join(backends)
        while backend not in backends:
            backend = raw_input(_('Select backend [anydbm]: ')).strip()
            if not backend:
                backend = 'anydbm'
        # XXX perform a unit test based on the user's selections

        # Process configuration file definitions
        if len(args) > 3:
            try:
                defns = dict([item.split("=") for item in args[3].split(",")])
            except:
                print _('Error in configuration settings: "%s"') % args[3]
                raise
        else:
            defns = {}

        # install!
        init.install(tracker_home, templates[template]['path'], settings=defns)
        init.write_select_db(tracker_home, backend)

        print _("""
---------------------------------------------------------------------------
 You should now edit the tracker configuration file:
   %(config_file)s""") % {"config_file": config_ini_file}

        # find list of options that need manual adjustments
        # XXX config._get_unset_options() is marked as private
        #   (leading underscore).  make it public or don't care?
        need_set = CoreConfig(tracker_home)._get_unset_options()
        if need_set:
            print _(" ... at a minimum, you must set following options:")
            for section, options in need_set.items():
                print "   [%s]: %s" % (section, ", ".join(options))

        # note about schema modifications
        print _("""
 If you wish to modify the database schema,
 you should also edit the schema file:
   %(database_config_file)s
 You may also change the database initialisation file:
   %(database_init_file)s
 ... see the documentation on customizing for more information.

 You MUST run the "roundup-admin initialise" command once you've performed
 the above steps.
---------------------------------------------------------------------------
""") % {
    'database_config_file': os.path.join(tracker_home, 'schema.py'),
    'database_init_file': os.path.join(tracker_home, 'initial_data.py'),
}
        return 0

    def do_genconfig(self, args):
        ''"""Usage: genconfig <filename>
        Generate a new tracker config file (ini style) with default values
        in <filename>.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        config = CoreConfig()
        config.save(args[0])

    def do_initialise(self, tracker_home, args):
        ''"""Usage: initialise [adminpw]
        Initialise a new Roundup tracker.

        The administrator details will be set at this step.

        Execute the tracker's initialisation function dbinit.init()
        """
        # password
        if len(args) > 1:
            adminpw = args[1]
        else:
            adminpw = ''
            confirm = 'x'
            while adminpw != confirm:
                adminpw = getpass.getpass(_('Admin Password: '))
                confirm = getpass.getpass(_('       Confirm: '))

        # make sure the tracker home is installed
        if not os.path.exists(tracker_home):
            raise UsageError, _('Instance home does not exist')%locals()
        try:
            tracker = roundup.instance.open(tracker_home)
        except roundup.instance.TrackerError:
            raise UsageError, _('Instance has not been installed')%locals()

        # is there already a database?
        if tracker.exists():
            ok = raw_input(_(
"""WARNING: The database is already initialised!
If you re-initialise it, you will lose all the data!
Erase it? Y/N: """))
            if ok.strip().lower() != 'y':
                return 0

            backend = tracker.get_backend_name()

            # nuke it
            tracker.nuke()

            # re-write the backend select file
            init.write_select_db(tracker_home, backend)

        # GO
        tracker.init(password.Password(adminpw))

        return 0


    def do_get(self, args):
        ''"""Usage: get property designator[,designator]*
        Get the given property of one or more designator(s).

        Retrieves the property value of the nodes specified
        by the designators.
        """
        if len(args) < 2:
            raise UsageError, _('Not enough arguments supplied')
        propname = args[0]
        designators = args[1].split(',')
        l = []
        for designator in designators:
            # decode the node designator
            try:
                classname, nodeid = hyperdb.splitDesignator(designator)
            except hyperdb.DesignatorError as message:
                raise UsageError, message

            # get the class
            cl = self.get_class(classname)
            try:
                id=[]
                if self.separator:
                    if self.print_designator:
                        # see if property is a link or multilink for
                        # which getting a desginator make sense.
                        # Algorithm: Get the properties of the
                        #     current designator's class. (cl.getprops)
                        # get the property object for the property the
                        #     user requested (properties[propname])
                        # verify its type (isinstance...)
                        # raise error if not link/multilink
                        # get class name for link/multilink property
                        # do the get on the designators
                        # append the new designators
                        # print
                        properties = cl.getprops()
                        property = properties[propname]
                        if not (isinstance(property, hyperdb.Multilink) or
                          isinstance(property, hyperdb.Link)):
                            raise UsageError, _('property %s is not of type Multilink or Link so -d flag does not apply.')%propname
                        propclassname = self.db.getclass(property.classname).classname
                        id = cl.get(nodeid, propname)
                        for i in id:
                            l.append(propclassname + i)
                    else:
                        id = cl.get(nodeid, propname)
                        for i in id:
                            l.append(i)
                else:
                    if self.print_designator:
                        properties = cl.getprops()
                        property = properties[propname]
                        if not (isinstance(property, hyperdb.Multilink) or
                          isinstance(property, hyperdb.Link)):
                            raise UsageError, _('property %s is not of type Multilink or Link so -d flag does not apply.')%propname
                        propclassname = self.db.getclass(property.classname).classname
                        id = cl.get(nodeid, propname)
                        for i in id:
                            print propclassname + i
                    else:
                        print cl.get(nodeid, propname)
            except IndexError:
                raise UsageError, _('no such %(classname)s node "%(nodeid)s"')%locals()
            except KeyError:
                raise UsageError, _('no such %(classname)s property '
                    '"%(propname)s"')%locals()
        if self.separator:
            print self.separator.join(l)

        return 0


    def do_set(self, args):
        ''"""Usage: set items property=value property=value ...
        Set the given properties of one or more items(s).

        The items are specified as a class or as a comma-separated
        list of item designators (ie "designator[,designator,...]").

        This command sets the properties to the values for all designators
        given. If the value is missing (ie. "property=") then the property
        is un-set. If the property is a multilink, you specify the linked
        ids for the multilink as comma-separated numbers (ie "1,2,3").
        """
        if len(args) < 2:
            raise UsageError, _('Not enough arguments supplied')
        from roundup import hyperdb

        designators = args[0].split(',')
        if len(designators) == 1:
            designator = designators[0]
            try:
                designator = hyperdb.splitDesignator(designator)
                designators = [designator]
            except hyperdb.DesignatorError:
                cl = self.get_class(designator)
                designators = [(designator, x) for x in cl.list()]
        else:
            try:
                designators = [hyperdb.splitDesignator(x) for x in designators]
            except hyperdb.DesignatorError as message:
                raise UsageError, message

        # get the props from the args
        props = self.props_from_args(args[1:])

        # now do the set for all the nodes
        for classname, itemid in designators:
            cl = self.get_class(classname)

            properties = cl.getprops()
            for key, value in props.items():
                try:
                    props[key] = hyperdb.rawToHyperdb(self.db, cl, itemid,
                        key, value)
                except hyperdb.HyperdbValueError as message:
                    raise UsageError, message

            # try the set
            try:
                apply(cl.set, (itemid, ), props)
            except (TypeError, IndexError, ValueError) as message:
                import traceback; traceback.print_exc()
                raise UsageError, message
        self.db_uncommitted = True
        return 0

    def do_find(self, args):
        ''"""Usage: find classname propname=value ...
        Find the nodes of the given class with a given link property value.

        Find the nodes of the given class with a given link property value.
        The value may be either the nodeid of the linked node, or its key
        value.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        classname = args[0]
        # get the class
        cl = self.get_class(classname)

        # handle the propname=value argument
        props = self.props_from_args(args[1:])

        # convert the user-input value to a value used for find()
        for propname, value in props.items():
            if ',' in value:
                values = value.split(',')
            else:
                values = [value]
            d = props[propname] = {}
            for value in values:
                value = hyperdb.rawToHyperdb(self.db, cl, None, propname, value)
                if isinstance(value, list):
                    for entry in value:
                        d[entry] = 1
                else:
                    d[value] = 1

        # now do the find
        try:
            id = []
            designator = []
            if self.separator:
                if self.print_designator:
                    id=apply(cl.find, (), props)
                    for i in id:
                        designator.append(classname + i)
                    print self.separator.join(designator)
                else:
                    print self.separator.join(apply(cl.find, (), props))

            else:
                if self.print_designator:
                    id=apply(cl.find, (), props)
                    for i in id:
                        designator.append(classname + i)
                    print designator
                else:
                    print apply(cl.find, (), props)
        except KeyError:
            raise UsageError, _('%(classname)s has no property '
                '"%(propname)s"')%locals()
        except (ValueError, TypeError) as  message:
            raise UsageError, message
        return 0

    def do_specification(self, args):
        ''"""Usage: specification classname
        Show the properties for a classname.

        This lists the properties for a given class.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        classname = args[0]
        # get the class
        cl = self.get_class(classname)

        # get the key property
        keyprop = cl.getkey()
        for key, value in cl.properties.items():
            if keyprop == key:
                print _('%(key)s: %(value)s (key property)')%locals()
            else:
                print _('%(key)s: %(value)s')%locals()

    def do_display(self, args):
        ''"""Usage: display designator[,designator]*
        Show the property values for the given node(s).

        This lists the properties and their associated values for the given
        node.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')

        # decode the node designator
        for designator in args[0].split(','):
            try:
                classname, nodeid = hyperdb.splitDesignator(designator)
            except hyperdb.DesignatorError as message:
                raise UsageError, message

            # get the class
            cl = self.get_class(classname)

            # display the values
            keys = cl.properties.keys()
            keys.sort()
            for key in keys:
                value = cl.get(nodeid, key)
                print _('%(key)s: %(value)s')%locals()

    def do_create(self, args):
        ''"""Usage: create classname property=value ...
        Create a new entry of a given class.

        This creates a new entry of the given class using the property
        name=value arguments provided on the command line after the "create"
        command.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        from roundup import hyperdb

        classname = args[0]

        # get the class
        cl = self.get_class(classname)

        # now do a create
        props = {}
        properties = cl.getprops(protected = 0)
        if len(args) == 1:
            # ask for the properties
            for key, value in properties.items():
                if key == 'id': continue
                name = value.__class__.__name__
                if isinstance(value , hyperdb.Password):
                    again = None
                    while value != again:
                        value = getpass.getpass(_('%(propname)s (Password): ')%{
                            'propname': key.capitalize()})
                        again = getpass.getpass(_('   %(propname)s (Again): ')%{
                            'propname': key.capitalize()})
                        if value != again: print _('Sorry, try again...')
                    if value:
                        props[key] = value
                else:
                    value = raw_input(_('%(propname)s (%(proptype)s): ')%{
                        'propname': key.capitalize(), 'proptype': name})
                    if value:
                        props[key] = value
        else:
            props = self.props_from_args(args[1:])

        # convert types
        for propname, value in props.items():
            try:
                props[propname] = hyperdb.rawToHyperdb(self.db, cl, None,
                    propname, value)
            except hyperdb.HyperdbValueError as message:
                raise UsageError, message

        # check for the key property
        propname = cl.getkey()
        if propname and not props.has_key(propname):
            raise UsageError, _('you must provide the "%(propname)s" '
                'property.')%locals()

        # do the actual create
        try:
            print apply(cl.create, (), props)
        except (TypeError, IndexError, ValueError) as message:
            raise UsageError, message
        self.db_uncommitted = True
        return 0

    def do_list(self, args):
        ''"""Usage: list classname [property]
        List the instances of a class.

        Lists all instances of the given class. If the property is not
        specified, the  "label" property is used. The label property is
        tried in order: the key, "name", "title" and then the first
        property, alphabetically.

        With -c, -S or -s print a list of item id's if no property
        specified.  If property specified, print list of that property
        for every class instance.
        """
        if len(args) > 2:
            raise UsageError, _('Too many arguments supplied')
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        classname = args[0]
        
        # get the class
        cl = self.get_class(classname)

        # figure the property
        if len(args) > 1:
            propname = args[1]
        else:
            propname = cl.labelprop()

        if self.separator:
            if len(args) == 2:
                # create a list of propnames since user specified propname
                proplist=[]
                for nodeid in cl.list():
                    try:
                        proplist.append(cl.get(nodeid, propname))
                    except KeyError:
                        raise UsageError, _('%(classname)s has no property '
                            '"%(propname)s"')%locals()
                print self.separator.join(proplist)
            else:
                # create a list of index id's since user didn't specify
                # otherwise
                print self.separator.join(cl.list())
        else:
            for nodeid in cl.list():
                try:
                    value = cl.get(nodeid, propname)
                except KeyError:
                    raise UsageError, _('%(classname)s has no property '
                        '"%(propname)s"')%locals()
                print _('%(nodeid)4s: %(value)s')%locals()
        return 0

    def do_table(self, args):
        ''"""Usage: table classname [property[,property]*]
        List the instances of a class in tabular form.

        Lists all instances of the given class. If the properties are not
        specified, all properties are displayed. By default, the column
        widths are the width of the largest value. The width may be
        explicitly defined by defining the property as "name:width".
        For example::

          roundup> table priority id,name:10
          Id Name
          1  fatal-bug
          2  bug
          3  usability
          4  feature

        Also to make the width of the column the width of the label,
        leave a trailing : without a width on the property. For example::

          roundup> table priority id,name:
          Id Name
          1  fata
          2  bug
          3  usab
          4  feat

        will result in a the 4 character wide "Name" column.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        classname = args[0]

        # get the class
        cl = self.get_class(classname)

        # figure the property names to display
        if len(args) > 1:
            prop_names = args[1].split(',')
            all_props = cl.getprops()
            for spec in prop_names:
                if ':' in spec:
                    try:
                        propname, width = spec.split(':')
                    except (ValueError, TypeError):
                        raise UsageError, _('"%(spec)s" not name:width')%locals()
                else:
                    propname = spec
                if not all_props.has_key(propname):
                    raise UsageError, _('%(classname)s has no property '
                        '"%(propname)s"')%locals()
        else:
            prop_names = cl.getprops().keys()

        # now figure column widths
        props = []
        for spec in prop_names:
            if ':' in spec:
                name, width = spec.split(':')
                if width == '':
                    props.append((name, len(spec)))
                else:
                    props.append((name, int(width)))
            else:
               # this is going to be slow
               maxlen = len(spec)
               for nodeid in cl.list():
                   curlen = len(str(cl.get(nodeid, spec)))
                   if curlen > maxlen:
                       maxlen = curlen
               props.append((spec, maxlen))

        # now display the heading
        print ' '.join([name.capitalize().ljust(width) for name,width in props])

        # and the table data
        for nodeid in cl.list():
            l = []
            for name, width in props:
                if name != 'id':
                    try:
                        value = str(cl.get(nodeid, name))
                    except KeyError:
                        # we already checked if the property is valid - a
                        # KeyError here means the node just doesn't have a
                        # value for it
                        value = ''
                else:
                    value = str(nodeid)
                f = '%%-%ds'%width
                l.append(f%value[:width])
            print ' '.join(l)
        return 0

    def do_history(self, args):
        ''"""Usage: history designator
        Show the history entries of a designator.

        Lists the journal entries for the node identified by the designator.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        try:
            classname, nodeid = hyperdb.splitDesignator(args[0])
        except hyperdb.DesignatorError as message:
            raise UsageError, message

        try:
            print self.db.getclass(classname).history(nodeid)
        except KeyError:
            raise UsageError, _('no such class "%(classname)s"')%locals()
        except IndexError:
            raise UsageError, _('no such %(classname)s node "%(nodeid)s"')%locals()
        return 0

    def do_commit(self, args):
        ''"""Usage: commit
        Commit changes made to the database during an interactive session.

        The changes made during an interactive session are not
        automatically written to the database - they must be committed
        using this command.

        One-off commands on the command-line are automatically committed if
        they are successful.
        """
        self.db.commit()
        self.db_uncommitted = False
        return 0

    def do_rollback(self, args):
        ''"""Usage: rollback
        Undo all changes that are pending commit to the database.

        The changes made during an interactive session are not
        automatically written to the database - they must be committed
        manually. This command undoes all those changes, so a commit
        immediately after would make no changes to the database.
        """
        self.db.rollback()
        self.db_uncommitted = False
        return 0

    def do_retire(self, args):
        ''"""Usage: retire designator[,designator]*
        Retire the node specified by designator.

        This action indicates that a particular node is not to be retrieved
        by the list or find commands, and its key value may be re-used.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        designators = args[0].split(',')
        for designator in designators:
            try:
                classname, nodeid = hyperdb.splitDesignator(designator)
            except hyperdb.DesignatorError as message:
                raise UsageError, message
            try:
                self.db.getclass(classname).retire(nodeid)
            except KeyError:
                raise UsageError, _('no such class "%(classname)s"')%locals()
            except IndexError:
                raise UsageError, _('no such %(classname)s node "%(nodeid)s"')%locals()
        self.db_uncommitted = True
        return 0

    def do_restore(self, args):
        ''"""Usage: restore designator[,designator]*
        Restore the retired node specified by designator.

        The given nodes will become available for users again.
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        designators = args[0].split(',')
        for designator in designators:
            try:
                classname, nodeid = hyperdb.splitDesignator(designator)
            except hyperdb.DesignatorError as message:
                raise UsageError, message
            try:
                self.db.getclass(classname).restore(nodeid)
            except KeyError:
                raise UsageError, _('no such class "%(classname)s"')%locals()
            except IndexError:
                raise UsageError, _('no such %(classname)s node "%(nodeid)s"')%locals()
        self.db_uncommitted = True
        return 0

    def do_export(self, args, export_files=True):
        ''"""Usage: export [[-]class[,class]] export_dir
        Export the database to colon-separated-value files.
        To exclude the files (e.g. for the msg or file class),
        use the exporttables command.

        Optionally limit the export to just the named classes
        or exclude the named classes, if the 1st argument starts with '-'.

        This action exports the current data from the database into
        colon-separated-value files that are placed in the nominated
        destination directory.
        """
        # grab the directory to export to
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')

        dir = args[-1]

        # get the list of classes to export
        if len(args) == 2:
            if args[0].startswith('-'):
                classes = [ c for c in self.db.classes.keys()
                            if not c in args[0][1:].split(',') ]
            else:
                classes = args[0].split(',')
        else:
            classes = self.db.classes.keys()

        class colon_separated(csv.excel):
            delimiter = ':'

        # make sure target dir exists
        if not os.path.exists(dir):
            os.makedirs(dir)

        # do all the classes specified
        for classname in classes:
            cl = self.get_class(classname)

            if not export_files and hasattr(cl, 'export_files'):
                sys.stdout.write('Exporting %s WITHOUT the files\r\n'%
                    classname)

            f = open(os.path.join(dir, classname+'.csv'), 'wb')
            writer = csv.writer(f, colon_separated)

            properties = cl.getprops()
            propnames = cl.export_propnames()
            fields = propnames[:]
            fields.append('is retired')
            writer.writerow(fields)

            # all nodes for this class
            for nodeid in cl.getnodeids():
                if self.verbose:
                    sys.stdout.write('\rExporting %s - %s'%(classname, nodeid))
                    sys.stdout.flush()
                writer.writerow(cl.export_list(propnames, nodeid))
                if export_files and hasattr(cl, 'export_files'):
                    cl.export_files(dir, nodeid)

            # close this file
            f.close()

            # export the journals
            jf = open(os.path.join(dir, classname+'-journals.csv'), 'wb')
            if self.verbose:
                sys.stdout.write("\nExporting Journal for %s\n" % classname)
                sys.stdout.flush()
            journals = csv.writer(jf, colon_separated)
            map(journals.writerow, cl.export_journals())
            jf.close()
        return 0

    def do_exporttables(self, args):
        ''"""Usage: exporttables [[-]class[,class]] export_dir
        Export the database to colon-separated-value files, excluding the
        files below $TRACKER_HOME/db/files/ (which can be archived separately).
        To include the files, use the export command.

        Optionally limit the export to just the named classes
        or exclude the named classes, if the 1st argument starts with '-'.

        This action exports the current data from the database into
        colon-separated-value files that are placed in the nominated
        destination directory.
        """
        return self.do_export(args, export_files=False)

    def do_import(self, args):
        ''"""Usage: import import_dir
        Import a database from the directory containing CSV files,
        two per class to import.

        The files used in the import are:

        <class>.csv
          This must define the same properties as the class (including
          having a "header" line with those property names.)
        <class>-journals.csv
          This defines the journals for the items being imported.

        The imported nodes will have the same nodeid as defined in the
        import file, thus replacing any existing content.

        The new nodes are added to the existing database - if you want to
        create a new database using the imported data, then create a new
        database (or, tediously, retire all the old data.)
        """
        if len(args) < 1:
            raise UsageError, _('Not enough arguments supplied')
        from roundup import hyperdb

        # directory to import from
        dir = args[0]

        class colon_separated(csv.excel):
            delimiter = ':'

        # import all the files
        for file in os.listdir(dir):
            classname, ext = os.path.splitext(file)
            # we only care about CSV files
            if ext != '.csv' or classname.endswith('-journals'):
                continue

            cl = self.get_class(classname)

            # ensure that the properties and the CSV file headings match
            f = open(os.path.join(dir, file), 'r')
            reader = csv.reader(f, colon_separated)
            file_props = None
            maxid = 1
            # loop through the file and create a node for each entry
            for n, r in enumerate(reader):
                if file_props is None:
                    file_props = r
                    continue

                if self.verbose:
                    sys.stdout.write('\rImporting %s - %s'%(classname, n))
                    sys.stdout.flush()

                # do the import and figure the current highest nodeid
                nodeid = cl.import_list(file_props, r)
                if hasattr(cl, 'import_files'):
                    cl.import_files(dir, nodeid)
                maxid = max(maxid, int(nodeid))
            print
            f.close()

            # import the journals
            f = open(os.path.join(args[0], classname + '-journals.csv'), 'r')
            reader = csv.reader(f, colon_separated)
            cl.import_journals(reader)
            f.close()

            # set the id counter
            print 'setting', classname, maxid+1
            self.db.setid(classname, str(maxid+1))

        self.db_uncommitted = True
        return 0

    def do_pack(self, args):
        ''"""Usage: pack period | date

        Remove journal entries older than a period of time specified or
        before a certain date.

        A period is specified using the suffixes "y", "m", and "d". The
        suffix "w" (for "week") means 7 days.

              "3y" means three years
              "2y 1m" means two years and one month
              "1m 25d" means one month and 25 days
              "2w 3d" means two weeks and three days

        Date format is "YYYY-MM-DD" eg:
            2001-01-01

        """
        if len(args) <> 1:
            raise UsageError, _('Not enough arguments supplied')

        # are we dealing with a period or a date
        value = args[0]
        date_re = re.compile(r"""
              (?P<date>\d\d\d\d-\d\d?-\d\d?)? # yyyy-mm-dd
              (?P<period>(\d+y\s*)?(\d+m\s*)?(\d+d\s*)?)?
              """, re.VERBOSE)
        m = date_re.match(value)
        if not m:
            raise ValueError, _('Invalid format')
        m = m.groupdict()
        if m['period']:
            pack_before = date.Date(". - %s"%value)
        elif m['date']:
            pack_before = date.Date(value)
        self.db.pack(pack_before)
        self.db_uncommitted = True
        return 0

    def do_reindex(self, args, desre=re.compile('([A-Za-z]+)([0-9]+)')):
        ''"""Usage: reindex [classname|designator]*
        Re-generate a tracker's search indexes.

        This will re-generate the search indexes for a tracker.
        This will typically happen automatically.
        """
        if args:
            for arg in args:
                m = desre.match(arg)
                if m:
                    cl = self.get_class(m.group(1))
                    try:
                        cl.index(m.group(2))
                    except IndexError:
                        raise UsageError, _('no such item "%(designator)s"')%{
                            'designator': arg}
                else:
                    cl = self.get_class(arg)
                    self.db.reindex(arg)
        else:
            self.db.reindex(show_progress=True)
        return 0

    def do_security(self, args):
        ''"""Usage: security [Role name]
        Display the Permissions available to one or all Roles.
        """
        if len(args) == 1:
            role = args[0]
            try:
                roles = [(args[0], self.db.security.role[args[0]])]
            except KeyError:
                print _('No such Role "%(role)s"')%locals()
                return 1
        else:
            roles = self.db.security.role.items()
            role = self.db.config.NEW_WEB_USER_ROLES
            if ',' in role:
                print _('New Web users get the Roles "%(role)s"')%locals()
            else:
                print _('New Web users get the Role "%(role)s"')%locals()
            role = self.db.config.NEW_EMAIL_USER_ROLES
            if ',' in role:
                print _('New Email users get the Roles "%(role)s"')%locals()
            else:
                print _('New Email users get the Role "%(role)s"')%locals()
        roles.sort()
        for rolename, role in roles:
            print _('Role "%(name)s":')%role.__dict__
            for permission in role.permissions:
                d = permission.__dict__
                if permission.klass:
                    if permission.properties:
                        print _(' %(description)s (%(name)s for "%(klass)s"'
                          ': %(properties)s only)')%d
                    else:
                        print _(' %(description)s (%(name)s for "%(klass)s" '
                            'only)')%d
                else:
                    print _(' %(description)s (%(name)s)')%d
        return 0


    def do_migrate(self, args):
        ''"""Usage: migrate
        Update a tracker's database to be compatible with the Roundup
        codebase.

        You should run the "migrate" command for your tracker once you've
        installed the latest codebase. 

        Do this before you use the web, command-line or mail interface and
        before any users access the tracker.

        This command will respond with either "Tracker updated" (if you've
        not previously run it on an RDBMS backend) or "No migration action
        required" (if you have run it, or have used another interface to the
        tracker, or possibly because you are using anydbm).

        It's safe to run this even if it's not required, so just get into
        the habit.
        """
        if getattr(self.db, 'db_version_updated'):
            print _('Tracker updated')
            self.db_uncommitted = True
        else:
            print _('No migration action required')
        return 0

    def run_command(self, args):
        """Run a single command
        """
        command = args[0]

        # handle help now
        if command == 'help':
            if len(args)>1:
                self.do_help(args[1:])
                return 0
            self.do_help(['help'])
            return 0
        if command == 'morehelp':
            self.do_help(['help'])
            self.help_commands()
            self.help_all()
            return 0
        if command == 'config':
            self.do_config(args[1:])
            return 0

        # figure what the command is
        try:
            functions = self.commands.get(command)
        except KeyError:
            # not a valid command
            print _('Unknown command "%(command)s" ("help commands" for a '
                'list)')%locals()
            return 1

        # check for multiple matches
        if len(functions) > 1:
            print _('Multiple commands match "%(command)s": %(list)s')%{'command':
                command, 'list': ', '.join([i[0] for i in functions])}
            return 1
        command, function = functions[0]

        # make sure we have a tracker_home
        while not self.tracker_home:
            self.tracker_home = raw_input(_('Enter tracker home: ')).strip()

        # before we open the db, we may be doing an install or init
        if command == 'initialise':
            try:
                return self.do_initialise(self.tracker_home, args)
            except UsageError as message:
                print _('Error: %(message)s')%locals()
                return 1
        elif command == 'install':
            try:
                return self.do_install(self.tracker_home, args)
            except UsageError as message:
                print _('Error: %(message)s')%locals()
                return 1

        # get the tracker
        try:
            tracker = roundup.instance.open(self.tracker_home)
        except ValueError as message:
            self.tracker_home = ''
            print _("Error: Couldn't open tracker: %(message)s")%locals()
            return 1

        # only open the database once!
        if not self.db:
            self.db = tracker.open('admin')

        # do the command
        ret = 0
        try:
            ret = function(args[1:])
        except UsageError as message:
            print _('Error: %(message)s')%locals()
            print
            print function.__doc__
            ret = 1
        except:
            import traceback
            traceback.print_exc()
            ret = 1
        return ret

    def interactive(self):
        """Run in an interactive mode
        """
        print _('Roundup %s ready for input.\nType "help" for help.'
            % roundup_version)
        try:
            import readline
        except ImportError:
            print _('Note: command history and editing not available')

        while 1:
            try:
                command = raw_input(_('roundup> '))
            except EOFError:
                print _('exit...')
                break
            if not command: continue
            args = token.token_split(command)
            if not args: continue
            if args[0] in ('quit', 'exit'): break
            self.run_command(args)

        # exit.. check for transactions
        if self.db and self.db_uncommitted:
            commit = raw_input(_('There are unsaved changes. Commit them (y/N)? '))
            if commit and commit[0].lower() == 'y':
                self.db.commit()
        return 0

    def main(self):
        try:
            opts, args = getopt.getopt(sys.argv[1:], 'i:u:hcdsS:vV')
        except getopt.GetoptError as e:
            self.usage(str(e))
            return 1

        # handle command-line args
        self.tracker_home = os.environ.get('TRACKER_HOME', '')
        # TODO: reinstate the user/password stuff (-u arg too)
        name = password = ''
        if os.environ.has_key('ROUNDUP_LOGIN'):
            l = os.environ['ROUNDUP_LOGIN'].split(':')
            name = l[0]
            if len(l) > 1:
                password = l[1]
        self.separator = None
        self.print_designator = 0
        self.verbose = 0
        for opt, arg in opts:
            if opt == '-h':
                self.usage()
                return 0
            elif opt == '-v':
                print '%s (python %s)'%(roundup_version, sys.version.split()[0])
                return 0
            elif opt == '-V':
                self.verbose = 1
            elif opt == '-i':
                self.tracker_home = arg
            elif opt == '-c':
                if self.separator != None:
                    self.usage('Only one of -c, -S and -s may be specified')
                    return 1
                self.separator = ','
            elif opt == '-S':
                if self.separator != None:
                    self.usage('Only one of -c, -S and -s may be specified')
                    return 1
                self.separator = arg
            elif opt == '-s':
                if self.separator != None:
                    self.usage('Only one of -c, -S and -s may be specified')
                    return 1
                self.separator = ' '
            elif opt == '-d':
                self.print_designator = 1

        # if no command - go interactive
        # wrap in a try/finally so we always close off the db
        ret = 0
        try:
            if not args:
                self.interactive()
            else:
                ret = self.run_command(args)
                if self.db: self.db.commit()
            return ret
        finally:
            if self.db:
                self.db.close()

if __name__ == '__main__':
    tool = AdminTool()
    sys.exit(tool.main())

# vim: set filetype=python sts=4 sw=4 et si :

commit refs/heads/gsoc-2009
mark :787
author Pygi <pygi@users.sourceforge.net> 1248410908 +0000
committer Pygi <pygi@users.sourceforge.net> 1248410908 +0000
data 25
Fixed some stuf for 2to3
from :785
property svn 4 4335
M 100644 :786 roundup/admin.py

blob
mark :788
data 12867
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title">
<tal:block condition="context/id" i18n:translate=""
 >Bug <span tal:replace="context/id" i18n:name="id"
 />: <span tal:replace="context/title" i18n:name="title"
 /> - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
<tal:block condition="not:context/id" i18n:translate=""
 >New Bug report - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker"
/></tal:block>
</title>
<tal:block metal:fill-slot="body_title">
 <span tal:condition="python: not (context.id or context.is_edit_ok())"
  tal:omit-tag="python:1" i18n:translate="">New Bug</span>
 <span tal:condition="python: not context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">New Bug Editing</span>
 <span tal:condition="python: context.id and not context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Bug <tal:x
  replace="context/id" i18n:name="id" /></span>
 <span tal:condition="python: context.id and context.is_edit_ok()"
  tal:omit-tag="python:1" i18n:translate="">Bug<tal:x
  replace="context/id" i18n:name="id" /> Editing</span>
</tal:block>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<div tal:condition="context/is_view_ok">

<form method="POST" name="itemSynopsis"
      onSubmit="return submit_once()" enctype="multipart/form-data"
      tal:attributes="action context/designator">

<fieldset><legend>classification</legend>
<table class="form">
<tr>
 <th class="required" i18n:translate="">Title:</th>
 <td colspan="3" tal:condition="context/title/is_edit_ok"
     tal:content="structure python:context.title.field(size=40)">title</td>
 <td colspan="3" tal:condition="not:context/title/is_edit_ok">
  <span tal:content="structure context/title/plain"/>
  <input type="hidden" name="title" tal:attributes="value context/title">
 </td>
</tr>

<tr>
 <th class="required" i18n:translate="">
   <span tal:condition="context/type/is_edit_ok" 
         tal:replace="structure python:db.bug_type.classhelp('id,name,description',property='type',label='Type')" />
   <span tal:condition="not:context/type/is_edit_ok">Type</span>:
 </th>
 <td tal:content="structure context/type/menu">type</td>
 <th i18n:translate="">
   <span tal:condition="context/severity/is_edit_ok"
         tal:replace="structure python:db.severity.classhelp('id,name,description',property='severity',label='Severity')" />
   <span tal:condition="not:context/severity/is_edit_ok">Severity</span>:
 </th>
 <td tal:content="structure context/severity/menu">severity</td>
</tr>

<tr>
 <th i18n:translate="">
   <span tal:condition="context/components/is_edit_ok" 
         tal:replace="structure python:db.component.classhelp('id,name,description',property='components',label='Components')" />
   <span tal:condition="not:context/components/is_edit_ok">Components</span>:
 </th>
 <td tal:content="structure context/components/menu">components</td>
 <th i18n:translate="">
   <span tal:condition="context/versions/is_edit_ok" 
         tal:replace="structure python:db.version.classhelp('id,name,description',property='versions',label='Versions')" />
   <span tal:condition="not:context/versions/is_edit_ok">Versions</span>:
 </th>
 <td tal:content="structure context/versions/menu">versions</td>
</tr>
</table>
</fieldset>

<fieldset><legend>process</legend>
<table class="form">
<tr tal:condition="context/id">
 <th i18n:translate="">
   <span tal:condition="context/status/is_edit_ok" 
         tal:replace="structure python:db.status.classhelp('id,name,description',property='status', label='Status')" />
   <span tal:condition="not:context/status/is_edit_ok">Status</span>:
 </th>
 <td tal:content="structure context/status/menu">status</td>
 <th i18n:translate="">
   <span tal:condition="context/resolution/is_edit_ok" 
         tal:replace="structure python:db.resolution.classhelp('id,name,description',property='resolution', label='Resolution')" />
   <span tal:condition="not:context/resolution/is_edit_ok">Resolution</span>:
 </th>
 <td tal:content="structure context/resolution/menu">resolution</td>
</tr>

<tr tal:condition="context/id">
 <th>
  <tal:block i18n:translate="">Dependencies</tal:block>:
  <span tal:condition="context/dependencies/is_edit_ok"
        tal:replace="structure python:db.bug.classhelp('id,title', filter='status=0,1', property='dependencies')" />
 </th>
 <td>
  <span tal:replace="structure python:context.dependencies.field(showid=1,size=20)" />
  <span tal:condition="context/dependencies" tal:repeat="d python:context.dependencies.sorted('creation')">
   <br/>View: <a tal:attributes="href string:bug${d/id}" tal:content="d/id"></a>
  </span>
 </td>
 <th i18n:translate="">
  <tal:block i18n:translate="">Superseder</tal:block>:
  <span tal:condition="context/superseder/is_edit_ok"
        tal:replace="structure python:db.bug.classhelp('id,title', filter='status=0,1', property='superseder')" />
 </th>
 <td>
  <span tal:replace="structure python:context.superseder.field(showid=1, size=20)" />
 <span tal:condition="context/superseder">
<!--   <br><span i18n:translate="">View</span>:
     <a tal:repeat="sup context/superseder"
        tal:content="python:sup['id'] + ', '*(not repeat['sup'].end)"
        tal:attributes="href string:bug${sup/id}; title sup/title;"></a> -->
   <br><span i18n:translate="">View</span>:
     <a tal:content="context/superseder/id"
        tal:attributes="href string:bug${context/superseder/id}; title context/superseder/title;"></a> 
  </span> 
 </td>
 </tr>
 <tr>
 <th><tal:block i18n:translate="">Assigned To</tal:block>:</th>
 <td tal:content="structure context/assignee/menu">assignedto menu</td>
 <th><tal:block i18n:translate="">Nosy List</tal:block>:
  <span tal:condition="context/nosy/is_edit_ok"
        tal:replace="structure python:db.user.classhelp('username,realname,address', property='nosy')" />
 </th>
 <td>
  <span tal:replace="structure context/nosy/field" />
 </td>
</tr>
<tr>
 <th>
   <span tal:condition="context/priority/is_edit_ok"
         tal:replace="structure python:db.priority.classhelp('id,name,description',property='priority',label='Priority')" />
   <span tal:condition="not:context/priority/is_edit_ok">Priority</span>:
 </th>
 <td tal:content="structure context/priority/menu">priority</td>
 <th i18n:translate="">Keywords:</th>
 <td tal:content="structure python:context['keywords'].menu(height=5)">keywords</td>


</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">Comment</tal:block>:</th>
 <td colspan="3">
  <textarea tal:content="request/form/@note/value | default"
            name="@note" wrap="hard" rows="10" cols="60"></textarea>
 </td>
</tr>

<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">File</tal:block>:</th>
 <td colspan="3">
   <input type="hidden" name="@link@files" value="file-1">
   <input type="file" name="file-1@content" size="35">
 </td>
</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">File Description</tal:block>:</th>
 <td colspan=3><input type="edit" name="file-1@description" size="40"></td>
</tr>

<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">Patch</tal:block>:</th>
 <td colspan="3">
   <input type="hidden" name="@link@patches" value="patch-1"/>
   <input type="file" name="patch-1@content" size="35"/>
 </td>
</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">Patch Description</tal:block>:</th>
 <td colspan=3><input type="edit" name="patch-1@description" size="40"></td>
</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">Repository</tal:block>:</th>
 <td colspan=3><input type="edit" name="patch-1@repository" size="40"></td>
</tr>
<tr tal:condition="context/is_edit_ok">
 <th><tal:block i18n:translate="">Repo. Revision</tal:block>:</th>
 <td colspan=3><input type="edit" name="patch-1@revision" size="40"></td>
</tr>

</table>
</fieldset>
<table class="form">
<tr tal:condition="context/is_edit_ok">
 <td>
  &nbsp;
  <input type="hidden" name="@template" value="item">
  <input type="hidden" name="@required" value="title">
 </td>
 <td colspan=3>
  <span tal:replace="structure context/submit">submit button</span>
  <a tal:condition="context/id" tal:attributes="href context/copy_url"
   i18n:translate="">Make a copy</a>
 </td>
</tr>
</table>
</form>

<p tal:condition="context/id" i18n:translate="">
 Created on <b><tal:x replace="python:context.creation.pretty('%Y-%m-%d %H:%M')" i18n:name="creation" /></b>
 by <b><tal:x replace="context/creator" i18n:name="creator" /></b>,
 last changed <b><tal:x replace="python:context.activity.pretty('%Y-%m-%d %H:%M')" i18n:name="activity" /></b>
 by <b><tal:x replace="context/actor" i18n:name="actor" /></b>.
</p>

<table class="files" tal:condition="context/files">
 <tr><th colspan="5" class="header" i18n:translate="">Files</th></tr>
 <tr>
  <th i18n:translate="">File name</th>
  <th i18n:translate="">Uploaded</th>
  <th i18n:translate="">Description</th>
  <th i18n:translate="">Edit</th>
  <th i18n:translate="">Remove</th>
 </tr>
 <tr tal:repeat="file python:context.files.sorted('creation')">
  <td>
   <a tal:attributes="href file/download_url"
      tal:content="file/name">dld link</a>
  </td>
  <td>
   <span tal:content="file/creator">creator's name</span>,
   <span tal:content="python:file.creation.pretty('%Y-%m-%d %H:%M')">creation date</span>
  </td>
  <td tal:content="file/description" />
  <td><a tal:condition="file/is_edit_ok"
          tal:attributes="href string:file${file/id}">edit</a>
  </td>
  <td>
   <form style="padding:0" tal:condition="file/is_edit_ok"
         tal:attributes="action string:bug${context/id}">
    <input type="hidden" name="@remove@files" tal:attributes="value file/id">
    <input type="hidden" name="@action" value="edit">
    <input type="submit" value="remove" i18n:attributes="value">
   </form>
  </td>
 </tr>
</table>

<table class="files" tal:condition="context/patches">
 <tr><th colspan="5" class="header" i18n:translate="">Patches</th></tr>
 <tr>
  <th i18n:translate="">Patch name</th>
  <th i18n:translate="">Uploaded</th>
  <th i18n:translate="">Description</th>
  <th i18n:translate="">View</th>
  <th i18n:translate="">Edit</th>
  <th i18n:translate="">Remove</th>
 </tr>
 <tr tal:repeat="patch python:context.patches.sorted('creation')">
  <td>
   <a tal:attributes="href patch/download_url"
      tal:content="patch/name">dld link</a>
  </td>
  <td>
   <span tal:content="patch/creator">creator's name</span>,
   <span tal:content="python:patch.creation.pretty('%Y-%m-%d %H:%M')">creation date</span>
  </td>
  <td tal:content="patch/description" />
  <td><a tal:attributes="href string:patch_view${patch/id}">Show patch</a>
  </td>
  <td><a tal:condition="patch/is_edit_ok"
          tal:attributes="href string:patch${patch/id}">Edit</a>
  </td>
  <td>
   <form style="padding:0" tal:condition="patch/is_edit_ok"
         tal:attributes="action string:bug${context/id}">
    <input type="hidden" name="@remove@patches" tal:attributes="value patch/id"/>
    <input type="hidden" name="@action" value="edit"/>
    <input type="submit" value="remove" i18n:attributes="value"/>
   </form>
  </td>
 </tr>
</table>

<table class="messages" tal:condition="context/messages">
 <tr><th colspan="4" class="header" i18n:translate="">Messages</th></tr>
 <tal:block tal:repeat="msg context/messages">
  <tr>
   <th><a tal:attributes="href string:msg${msg/id}"
    i18n:translate="">msg<tal:x replace="msg/id" i18n:name="id" /></a></th>
   <th i18n:translate="">Author: <tal:x replace="python:msg.author.realname.plain()"
       i18n:name="author" /> (<tal:x replace="msg/author"/>)</th>
   <th i18n:translate="">Date: <tal:x replace="python:msg.date.pretty('%Y-%m-%d %H:%M')"
       i18n:name="date" /></th>
   <th>
    <form style="padding:0" tal:condition="msg/is_edit_ok"
          tal:attributes="action string:bug${context/id}">
     <input type="hidden" name="@remove@messages" tal:attributes="value msg/id">
     <input type="hidden" name="@action" value="edit">
     <input type="submit" value="remove" i18n:attributes="value">
    </form>
   </th>
  </tr>
  <tr>
   <td colspan="4" class="content">
    <pre tal:condition="python:msg.content.is_view_ok()"
         tal:content="structure python:utils.localReplace(msg.content.hyperlinked())">content</pre>
   </td>
  </tr>
 </tal:block>
</table>

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</div>

</td>

</tal:block>

blob
mark :789
data 2630
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate="">
  List of patches - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker" />
</title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
  i18n:translate="">List of patches</span>
<td class="content" metal:fill-slot="content">

<table class="otherinfo" tal:define="batch request/batch">
 <tr><th style="padding-right: 10" i18n:translate="">Download</th>
     <th style="padding-right: 10" i18n:translate="">Description</th>
     <th style="padding-right: 10" i18n:translate="">Content Type</th>
     <th style="padding-right: 10" i18n:translate="">Uploaded By</th>
     <th style="padding-right: 10" i18n:translate="">Date</th>
 </tr>
 <tr tal:repeat="patch batch" tal:attributes="class python:['normal', 'alt'][repeat['patch'].index%6/3]">
  <td>
   <a tal:attributes="href string:patch${patch/id}/${patch/name}"
      tal:content="patch/name">dld link</a>
  </td>
  <td tal:content="patch/description">description</td>
  <td tal:content="patch/type">content type</td>
  <td tal:content="patch/creator">creator's name</td>
  <td tal:content="patch/creation">creation date</td>
 </tr>

 <metal:block use-macro="templates/issue.index/macros/batch-footer" />

</table>

</td>

</tal:block>
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate="">
  List of patches - <span tal:replace="config/TRACKER_NAME" i18n:name="tracker" />
</title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
  i18n:translate="">List of patches</span>
<td class="content" metal:fill-slot="content">

<table class="otherinfo" tal:define="batch request/batch">
 <tr><th style="padding-right: 10" i18n:translate="">Download</th>
     <th style="padding-right: 10" i18n:translate="">Description</th>
     <th style="padding-right: 10" i18n:translate="">Content Type</th>
     <th style="padding-right: 10" i18n:translate="">Uploaded By</th>
     <th style="padding-right: 10" i18n:translate="">Date</th>
 </tr>
 <tr tal:repeat="patch batch" tal:attributes="class python:['normal', 'alt'][repeat['patch'].index%6/3]">
  <td>
   <a tal:attributes="href string:patch${patch/id}/${patch/name}"
      tal:content="patch/name">dld link</a>
  </td>
  <td tal:content="patch/description">description</td>
  <td tal:content="patch/type">content type</td>
  <td tal:content="patch/creator">creator's name</td>
  <td tal:content="patch/creation">creation date</td>
 </tr>

 <metal:block use-macro="templates/issue.index/macros/batch-footer" />

</table>

</td>

</tal:block>

blob
mark :790
data 6465
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate="">Patch display - <span
 i18n:name="tracker" tal:replace="config/TRACKER_NAME" /></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
 i18n:translate="">Modify patch</span>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<form method="POST" onSubmit="return submit_once()"
      enctype="multipart/form-data" tal:condition="context/is_view_ok"
      tal:attributes="action context/designator">

<table class="form">
 <tr>
  <th i18n:translate="">Name</th>
  <td tal:content="structure context/name/field"></td>
 </tr>
 <tr>
  <th i18n:translate="">Description</th>
  <td tal:content="structure context/description/field"></td>
 </tr>
 <tr>
  <th i18n:translate="">Content Type</th>
  <td tal:content="structure context/type/field"/>
  <td style="border: none" tal:condition="python: context.is_edit_ok()">Please note that
  for security reasons, it's not permitted to set content type to <i>text/html</i>.</td>
 </tr>
 <tr>
  <th i18n:translate="">Repository</th>
  <td tal:content="structure context/repository/field"></td>
 </tr>
 <tr>
  <th i18n:translate="">Repository revision</th>
  <td tal:content="structure context/revision/field"></td>
 </tr>
 <tr tal:condition="python:context.is_edit_ok()">
  <td>
   &nbsp;
   <input type="hidden" name="@template" value="item">
   <input type="hidden" name="@required" value="name,type">
   <input type="hidden" name="@multilink"
          tal:condition="python:request.form.has_key('@multilink')"
          tal:attributes="value request/form/@multilink/value">
  </td>
  <td tal:content="structure context/submit">submit button here</td>
 </tr>
</table>
</form>

<!--<p tal:condition="python:utils.sb_is_spam(context)" class="error-message">
   File has been classified as spam.</p>-->

<a tal:condition="python:context.id and context.content.is_view_ok()"
 tal:attributes="href string:patch${context/id}/${context/name}"
 i18n:translate="">download</a>

<!--<p tal:condition="python:context.id and not context.content.is_view_ok()">
   Files classified as spam are not available for download by
   unathorized users. If you think the file has been misclassified,
   please login and click on the button for reclassification.
</p>-->


<!--     <form method="POST" onSubmit="return submit_once()"
       enctype="multipart/form-data"
       tal:attributes="action context/designator"
       tal:condition="python:request.user.hasPermission('SB: May Classify')">
 
      <input type="hidden" name="@action" value="spambayes_classify">
      <input type="submit" name="trainspam" value="Mark as SPAM" i18n:attributes="value">
      <input type="submit" name="trainham" value="Mark as HAM (not SPAM)" i18n:attributes="value">
     </form>-->

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</td>

</tal:block>
<tal:block metal:use-macro="templates/page/macros/frame">
<title metal:fill-slot="head_title" i18n:translate="">Patch display - <span
 i18n:name="tracker" tal:replace="config/TRACKER_NAME" /></title>
<span metal:fill-slot="body_title" tal:omit-tag="python:1"
 i18n:translate="">Patch display</span>

<td class="content" metal:fill-slot="content">

<p tal:condition="python:not (context.is_view_ok()
 or request.user.hasRole('Anonymous'))" i18n:translate="">
 You are not allowed to view this page.</p>

<p tal:condition="python:not context.is_view_ok()
 and request.user.hasRole('Anonymous')" i18n:translate="">
 Please login with your username and password.</p>

<form method="POST" onSubmit="return submit_once()"
      enctype="multipart/form-data" tal:condition="context/is_view_ok"
      tal:attributes="action context/designator">

<table class="form">
 <tr>
  <th i18n:translate="">Name</th>
  <td tal:content="structure context/name/field"></td>
 </tr>
 <tr>
  <th i18n:translate="">Description</th>
  <td tal:content="structure context/description/field"></td>
 </tr>
 <tr>
  <th i18n:translate="">Content Type</th>
  <td tal:content="structure context/type/field"/>
  <td style="border: none" tal:condition="python: context.is_edit_ok()">Please note that
  for security reasons, it's not permitted to set content type to <i>text/html</i>.</td>
 </tr>
 <tr>
  <th i18n:translate="">Repository</th>
  <td tal:content="structure context/repository/field"></td>
 </tr>
 <tr>
  <th i18n:translate="">Repository revision</th>
  <td tal:content="structure context/revision/field"></td>
 </tr>
 <tr tal:condition="python:context.is_edit_ok()">
  <td>
   &nbsp;
   <input type="hidden" name="@template" value="item">
   <input type="hidden" name="@required" value="name,type">
   <input type="hidden" name="@multilink"
          tal:condition="python:request.form.has_key('@multilink')"
          tal:attributes="value request/form/@multilink/value">
  </td>
  <td tal:content="structure context/submit">submit button here</td>
 </tr>
</table>
</form>

<!--<p tal:condition="python:utils.sb_is_spam(context)" class="error-message">
   File has been classified as spam.</p>-->

<a tal:condition="python:context.id and context.content.is_view_ok()"
 tal:attributes="href string:patch${context/id}/${context/name}"
 i18n:translate="">download</a>

<!--<p tal:condition="python:context.id and not context.content.is_view_ok()">
   Files classified as spam are not available for download by
   unathorized users. If you think the file has been misclassified,
   please login and click on the button for reclassification.
</p>-->


<!--     <form method="POST" onSubmit="return submit_once()"
       enctype="multipart/form-data"
       tal:attributes="action context/designator"
       tal:condition="python:request.user.hasPermission('SB: May Classify')">
 
      <input type="hidden" name="@action" value="spambayes_classify">
      <input type="submit" name="trainspam" value="Mark as SPAM" i18n:attributes="value">
      <input type="submit" name="trainham" value="Mark as HAM (not SPAM)" i18n:attributes="value">
     </form>-->

<tal:block tal:condition="context/id" tal:replace="structure context/history" />

</td>

</tal:block>

commit refs/heads/gsoc-2009
mark :791
author Pygi <pygi@users.sourceforge.net> 1250322191 +0000
committer Pygi <pygi@users.sourceforge.net> 1250322191 +0000
data 26
Added patch stuff support
from :787
property svn 4 4348
M 100644 :788 share/roundup/templates/devel/html/bug.item.html
M 100644 :789 share/roundup/templates/devel/html/patch.index.html
M 100644 :790 share/roundup/templates/devel/html/patch.item.html

blob
mark :792
data 574
# Patch stuff - used for applying patch to a certain revision

path_global = ''

def _files(path, revision):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    output = open(file, 'w+')
    if path is not None:
        output.write(commands.getoutput('hg cat '  + " --rev " + str(revision) + " " + path))
    output.close()
    return file
    
def info(path, revision):
    global path_global
    path_global = path
    return _info(path, revision)

def init(instance):
    instance.registerUtil('apply_patch', info)

blob
mark :793
data 13857

#
# TRACKER SCHEMA
#

# Class automatically gets these properties:
#   creation = Date()
#   activity = Date()
#   creator = Link('user')
#   actor = Link('user')


# This is the repository class, then you can see/edit repositories in pages like
# "http://tracker/url/vcs_repo1"
vcs_repo = Class(db, "vcs_repo",
name=String(),
host=String(),
path=String(),
webview_url=String())
vcs_repo.setkey('name')

# Stores revision data, lets you see/edit revisions in pages like
# "http://tracker/url/vcs_rev1". The vcs_rev.item.html template is currently
# broken, but this works fine without it.
vcs_rev = Class(db, "vcs_rev",
repository=Link('vcs_repo'),
revision=String())



# Component
component = Class(db, 'component',
                  name=String(),
                  description=String(),
                  order=Number(),
                  assign_to=Link('user'))
component.setkey('name')

# Version
version = Class(db, 'version',
                name=String(),
                description=String(),
                order=Number())
version.setkey('name')

# Severity
severity = Class(db, 'severity',
                 name=String(),
                 description=String(),
                 order=Number())
severity.setkey('name')

# Priority
priority = Class(db, 'priority',
                 name=String(),
                 description=String(),
                 order=Number())
priority.setkey('name')

# Status
status = Class(db, "status",
               name=String(),
               description=String(),
               order=Number())
status.setkey("name")

# Resolution
resolution = Class(db, "resolution",
                   name=String(),
                   description=String(),
                   order=Number())
resolution.setkey('name')

# Keyword
keyword = Class(db, "keyword",
                name=String(),
                description=String())
keyword.setkey("name")
                

# User-defined saved searches
query = Class(db, "query",
              klass=String(),
              name=String(),
              url=String(),
              private_for=Link('user'))

# add any additional database schema configuration here

user = Class(db, "user",
             username=String(),
             password=Password(),
             address=String(),
             realname=String(),
             phone=String(),
             organisation=String(),
             alternate_addresses=String(),
             queries=Multilink('query'),
             roles=String(),     # comma-separated string of Role names
             timezone=String(),
             vcs_name=String())

user.setkey("username")

# Permissions for revision creation and repository viewing.
for role in ('User',):
    db.security.addPermissionToRole(role, 'Create', 'vcs_rev')
    db.security.addPermissionToRole(role, 'View', 'vcs_repo')

# FileClass automatically gets this property in addition to the Class ones:
#   content = String()    [saved to disk in <tracker home>/db/files/]
#   type = String()       [MIME type of the content, default 'text/plain']
msg = FileClass(db, "msg",
                author=Link("user", do_journal='no'),
                recipients=Multilink("user", do_journal='no'),
                date=Date(),
                summary=String(),
                files=Multilink("file"),
                messageid=String(),
                inreplyto=String(),
                revision=Link("vcs_rev"))

# File
file = FileClass(db, "file",
                name=String(),
                description=String(indexme='yes'))

# Patch
patch = FileClass(db, "patch",
                  name=String(),
                  description=String(indexme='yes'),
                  repository=String(),
                  revision=String())

# Bug Type
bug_type = Class(db, 'bug_type',
                 name=String(),
                 description=String(),
                 order=Number())
bug_type.setkey('name')

# IssueClass automatically gets these properties in addition to the Class ones:
#   title = String()
#   messages = Multilink("msg")
#   files = Multilink("file")
#   patches = Multilink("patches")
#   nosy = Multilink("user")
#   superseder = Multilink("issue")
bug = IssueClass(db, "bug",
                 type=Link('bug_type'),
                 components=Multilink('component'),
                 versions=Multilink('version'),
                 severity=Link('severity'),
                 priority=Link('priority'),
                 dependencies=Multilink('bug'),
                 assignee=Link('user'),
                 status=Link('status'),
                 resolution=Link('resolution'),
                 superseder=Link('bug'),
                 keywords=Multilink('keyword'))

# Task Type
task_type = Class(db, 'task_type',
                 name=String(),
                 description=String(),
                 order=Number())
task_type.setkey('name')

# IssueClass automatically gets these properties in addition to the Class ones:
#   title = String()
#   messages = Multilink("msg")
#   files = Multilink("file")
#   nosy = Multilink("user")
#   superseder = Multilink("issue")
task = IssueClass(db, "task",
                  type=Link('task_type'),
                  components=Multilink('component'),
                  priority=Link('priority'),
                  dependencies=Multilink('task'),
                  assignee=Multilink('user'),
                  status=Link('status'),
                  resolution=Link('resolution'),
                  solves=Link('bug'))

milestone = IssueClass(db, "milestone",
                       bugs=Multilink("bug"),
                       tasks=Multilink("task"),
                       status=Link("status"),
                       release_date=String())

#
# TRACKER SECURITY SETTINGS
#
# See the configuration and customisation document for information
# about security setup.

db.security.addRole(name='Developer', description='A developer')
db.security.addRole(name='Coordinator', description='A coordinator')

#
# REGULAR USERS
#
# Give the regular users access to the web and email interface
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, 'Web Access')
    db.security.addPermissionToRole(r, 'Email Access')

##########################
# User permissions
##########################

for cl in ('severity', 'component',
           'version', 'priority', 'status', 'resolution',
           'bug_type', 'bug', 'task_type', 'task', 'milestone',
           'keyword', 'file', 'msg'):
    db.security.addPermissionToRole('User', 'View', cl)
    db.security.addPermissionToRole('Anonymous', 'View', cl)
    db.security.addPermissionToRole('User', 'Create', cl)
    

def may_edit_file(db, userid, itemid):
    return userid == db.file.get(itemid, "creator")

p = db.security.addPermission(name='Edit', klass='file', check=may_edit_file,
    description="User is allowed to remove their own files")
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Create', klass='bug',
                              properties=('title', 'bug_type',
                                          'components', 'versions',
                                          'severity',
                                          'messages', 'files', 'nosy'),
                              description='User can report and discuss bugs')
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Edit', klass='bug',
                              properties=('title', 'bug_type',
                                          'components', 'versions',
                                          'severity',
                                          'messages', 'files', 'nosy'),
                              description='User can report and discuss bugs')
db.security.addPermissionToRole('User', p)

p = db.security.addPermission(name='Create', klass='task',
                              properties=('title', 'task_type',
                                          'components',
                                          'messages', 'files', 'nosy'),
                              description='Developer can create and discuss tasks')
db.security.addPermissionToRole('Developer', p)

p = db.security.addPermission(name='Edit', klass='task',
                              properties=('title', 'task_type',
                                          'components',
                                          'messages', 'files', 'nosy'),
                              description='Developer can create and discuss tasks')
db.security.addPermissionToRole('Developer', p)

p = db.security.addPermission(name='Create', klass='milestone',
                              description='Coordinator can create and discuss milestones')
db.security.addPermissionToRole('Coordinator', p)

p = db.security.addPermission(name='Edit', klass='milestone',
                              description='Coordinator can create and discuss milestones')
db.security.addPermissionToRole('Coordinator', p)


##########################
# Developer permissions
##########################
for cl in ('bug_type', 'severity', 'component',
           'version', 'priority', 'status', 'resolution',
           'bug', 'file', 'msg', 'keyword'):
    db.security.addPermissionToRole('Developer', 'View', cl)

for cl in ('bug', 'file', 'msg', 'keyword'):
    db.security.addPermissionToRole('Developer', 'Edit', cl)
    db.security.addPermissionToRole('Developer', 'Create', cl)


##########################
# Coordinator permissions
##########################
for cl in ('bug_type', 'task_type', 'severity', 'component',
           'version', 'priority', 'status', 'resolution', 'bug', 'task', 'file', 'msg'):
    db.security.addPermissionToRole('Coordinator', 'View', cl)
    db.security.addPermissionToRole('Coordinator', 'Edit', cl)
    db.security.addPermissionToRole('Coordinator', 'Create', cl)

# May users view other user information? Comment these lines out
# if you don't want them to
db.security.addPermissionToRole('User', 'View', 'user')
db.security.addPermissionToRole('Developer', 'View', 'user')
db.security.addPermissionToRole('Coordinator', 'View', 'user')

# Allow Coordinator to edit any user, including their roles.
db.security.addPermissionToRole('Coordinator', 'Edit', 'user')
db.security.addPermissionToRole('Coordinator', 'Web Roles')

# Users should be able to edit their own details -- this permission is
# limited to only the situation where the Viewed or Edited item is their own.
def own_record(db, userid, itemid):
    '''Determine whether the userid matches the item being accessed.'''
    return userid == itemid
p = db.security.addPermission(name='View', klass='user', check=own_record,
    description="User is allowed to view their own user details")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Edit', klass='user', check=own_record,
    description="User is allowed to edit their own user details",
    properties=('username', 'password',
                'address', 'realname',
                'phone', 'organization',
                'alternate_addresses',
                'queries',
                'timezone')) # Note: 'roles' excluded - users should not be able to edit their own roles. 
for r in 'User', 'Developer':
    db.security.addPermissionToRole(r, p)

# Users should be able to edit and view their own queries. They should also
# be able to view any marked as not private. They should not be able to
# edit others' queries, even if they're not private
def view_query(db, userid, itemid):
    private_for = db.query.get(itemid, 'private_for')
    if not private_for: return True
    return userid == private_for
def edit_query(db, userid, itemid):
    return userid == db.query.get(itemid, 'creator')
p = db.security.addPermission(name='View', klass='query', check=view_query,
    description="User is allowed to view their own and public queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Edit', klass='query', check=edit_query,
    description="User is allowed to edit their queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)
p = db.security.addPermission(name='Create', klass='query',
    description="User is allowed to create queries")
for r in 'User', 'Developer', 'Coordinator':
    db.security.addPermissionToRole(r, p)


#
# ANONYMOUS USER PERMISSIONS
#
# Let anonymous users access the web interface. Note that almost all
# trackers will need this Permission. The only situation where it's not
# required is in a tracker that uses an HTTP Basic Authenticated front-end.
db.security.addPermissionToRole('Anonymous', 'Web Access')

# Let anonymous users access the email interface (note that this implies
# that they will be registered automatically, hence they will need the
# "Create" user Permission below)
# This is disabled by default to stop spam from auto-registering users on
# public trackers.
#db.security.addPermissionToRole('Anonymous', 'Email Access')

# Assign the appropriate permissions to the anonymous user's Anonymous
# Role. Choices here are:
# - Allow anonymous users to register
db.security.addPermissionToRole('Anonymous', 'Create', 'user')

# Allow anonymous users access to view issues (and the related, linked
# information).

for cl in 'bug', 'task', 'milestone', 'severity', 'status', 'resolution', 'msg', 'file':
    db.security.addPermissionToRole('Anonymous', 'View', cl)

# [OPTIONAL]
# Allow anonymous users access to create or edit "issue" items (and the
# related file and message items)
#for cl in 'issue', 'file', 'msg':
#   db.security.addPermissionToRole('Anonymous', 'Create', cl)
#   db.security.addPermissionToRole('Anonymous', 'Edit', cl)


# vim: set filetype=python sts=4 sw=4 et si :


commit refs/heads/gsoc-2009
mark :794
author Pygi <pygi@users.sourceforge.net> 1250322225 +0000
committer Pygi <pygi@users.sourceforge.net> 1250322225 +0000
data 33
Added some hg patch apply things
from :791
property svn 4 4349
M 100644 :792 scripts/notify-roundup/extensions/hg_apply_patch.py
M 100644 :793 share/roundup/templates/devel/schema.py

blob
mark :795
data 1385
# Patch stuff - used for applying patch to a certain revision
import sys
import re

path_global = ''
diffs = {}

def _files(repo_path, file_path, revision):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    output = open(file, 'w+')
    if path is not None:
        output.write(commands.getoutput('hg cat '  + " --rev " + str(revision) + " " + repo_path + file_path))
    output.close()
    return file

def _diff(repo_path, file_path, revision):
  from_file = _files(repo_path, file_path, revision)
  # How to get location of from_file so I could patch it with hunk?
  # I am aware of tempfile.NamedTemporaryFile() which might help
  # but that is available only from 2.6
  
def _parse(file_path):
  # How to get patch path on FS?
  global diffs
  key = ''
  for line in lines:
    path = changes_re.findall(line)

    if len(path):
      key = path[0]
      diffs[key] = u''
    elif len(key):
      if not line[0:4] == 'diff':
        diffs[key] += unicode(line, 'utf-8')

def _info(path, revision):
  # How do I get patch location on FS?!
  _parse(patch_path);  
  return [_diff(path, keys, revision) for 
    keys in diffs.keys()]

def info(path, revision):
    global path_global, revision_global
    path_global = path
    return _info(path, revision)

def init(instance):
    instance.registerUtil('apply_patch', info)

commit refs/heads/gsoc-2009
mark :796
author Pygi <pygi@users.sourceforge.net> 1250323474 +0000
committer Pygi <pygi@users.sourceforge.net> 1250323474 +0000
data 24
Some more work comitted
from :794
property svn 4 4350
M 100644 :795 scripts/notify-roundup/extensions/hg_apply_patch.py

blob
mark :797
data 1212
# Patch stuff - used for applying patch to a certain revision
import sys
import re

path_global = ''
diffs = {}

def _files(repo_path, file_path, revision):
    """Download file from repository and store it in local temporary."""

    file = tempfile.mktemp()
    output = open(file, 'w+')
    if path is not None:
        output.write(commands.getoutput('hg cat '  + " --rev " + str(revision) + " " + repo_path + file_path))
    output.close()
    return file

def _diff(repo_path, file_path, revision):
  from_file = _files(repo_path, file_path, revision)
  
def _parse(file_path):
  # How to get patch path on FS?
  global diffs
  key = ''
  for line in lines:
    path = changes_re.findall(line)

    if len(path):
      key = path[0]
      diffs[key] = u''
    elif len(key):
      if not line[0:4] == 'diff':
        diffs[key] += unicode(line, 'utf-8')

def _info(path, revision):
  # How do I get patch location on FS?!
  _parse(patch_path);  
  return [_diff(path, keys, revision) for 
    keys in diffs.keys()]

def info(path, revision):
    global path_global, revision_global
    path_global = path
    return _info(path, revision)

def init(instance):
    instance.registerUtil('apply_patch', info)

commit refs/heads/gsoc-2009
mark :798
author Pygi <pygi@users.sourceforge.net> 1250324300 +0000
committer Pygi <pygi@users.sourceforge.net> 1250324300 +0000
data 5
Oops
from :796
property svn 4 4351
M 100644 :797 scripts/notify-roundup/extensions/hg_apply_patch.py

fossil SVN:4298 :730
fossil SVN:4299 :734
fossil SVN:4292 :722
fossil SVN:4290 :718
fossil SVN:4291 :720
fossil SVN:4296 :726
fossil SVN:4297 :728
fossil SVN:4294 :723
fossil SVN:4295 :724
fossil CVS:roundup/mailgw.py:1.196 :785
fossil SVN:4350 :796
fossil SVN:4322 :765
fossil SVN:4323 :767
fossil CVS:roundup/init.py:1.36 :785
fossil SVN:4225 :622
fossil SVN:4224 :620
fossil SVN:4223 :618
fossil SVN:4289 :716
fossil SVN:4288 :714
fossil SVN:4285 :708
fossil SVN:4284 :706
fossil SVN:4287 :712
fossil SVN:4286 :710
fossil SVN:4281 :700
fossil SVN:4280 :698
fossil SVN:4283 :704
fossil SVN:4282 :702
fossil SVN:4216 :614
fossil SVN:4214 :557
fossil SVN:4215 :612
fossil SVN:4270 :680
fossil SVN:4271 :682
fossil SVN:4273 :684
fossil SVN:4274 :686
fossil SVN:4275 :688
fossil SVN:4276 :690
fossil SVN:4277 :692
fossil SVN:4278 :694
fossil SVN:4279 :696
fossil SVN:4263 :670
fossil SVN:4262 :669
fossil SVN:4261 :666
fossil SVN:4260 :664
fossil SVN:4267 :675
fossil SVN:4266 :674
fossil SVN:4265 :672
fossil SVN:4264 :671
fossil SVN:4269 :679
fossil SVN:4268 :677
fossil CVS:share/roundup/templates/devel/detectors/messagesummary.py:1.1 :612
fossil CVS:roundup/mailer.py:1.22 :785
fossil SVN:4256 :658
fossil SVN:4257 :660
fossil SVN:4254 :653
fossil SVN:4255 :655
fossil SVN:4252 :649
fossil SVN:4253 :651
fossil SVN:4250 :645
fossil SVN:4251 :647
fossil SVN:4258 :661
fossil SVN:4259 :663
fossil SVN:4308 :747
fossil SVN:4309 :749
fossil SVN:4305 :744
fossil SVN:4306 :745
fossil SVN:4307 :746
fossil SVN:4301 :738
fossil SVN:4302 :740
fossil SVN:4303 :742
fossil SVN:4351 :798
fossil SVN:4314 :759
fossil SVN:4313 :758
fossil SVN:4312 :756
fossil SVN:4311 :753
fossil SVN:4310 :751
fossil SVN:4249 :644
fossil SVN:4248 :642
fossil SVN:4320 :761
fossil SVN:4321 :763
fossil SVN:4326 :774
fossil SVN:4327 :776
fossil SVN:4324 :770
fossil SVN:4325 :772
fossil SVN:4241 :631
fossil SVN:4243 :634
fossil SVN:4242 :632
fossil SVN:4245 :638
fossil SVN:4244 :636
fossil SVN:4247 :641
fossil SVN:4246 :639
fossil SVN:4348 :791
fossil SVN:4349 :794
fossil SVN:4335 :787
fossil SVN:4334 :785
fossil SVN:4234 :624
fossil SVN:4235 :626
fossil SVN:4236 :628
fossil SVN:4237 :630
