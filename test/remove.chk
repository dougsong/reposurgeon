blob
mark :1
data 393
#	Makefile for Battleships

# Flags for use with the Linux ncurses package (recommended)
# CFLAGS = -DNDEBUG  -I/usr/local/include -L/usr/local/lib
# TERMLIB = -lncurses

# Flags for use with stock curses
CFLAGS = -DNDEBUG
TERMLIB = -lcurses

bs: bs.c
	cc $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar *~

shar:
	shar READ.ME bs.c Makefile bs.6 >bs.shar

blob
mark :2
data 1341
Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write termcap games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

						Eric S. Raymond
						esr@snark.uu.net


blob
mark :3
data 26995
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 */

#include <stdio.h>
#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <assert.h>

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#ifdef isxdigit		/* aha, must be an AT&T system... */
#define srand(n)	srand48(n)
#define rand()		lrand48()
extern long lrand48();
extern void srand48();
#define bzero(s, n)	(void)memset((char *)(s), '\0', n)
extern char *memset();
/*
 * Try this if ungetch() fails to resolve.
 *
 * #define ungetch ungetc
 */
#endif /* isxdigit */

extern unsigned sleep();
extern char *strchr(), *strcpy();
extern long time();
extern void exit();

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "Stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    char dir;		/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(sig)
/* end the game, either normally or due to signal */
int	sig;
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(0);
}

static void announceopts()
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro()
{
    extern char *getlogin();
    char *tmpname;

    srand(time(0L)+getpid());	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if(tmpname = getlogin())
	(void)strcpy(name,tmpname);
    else
	(void)strcpy(name,dftname);
    name[0] = toupper(name[0]);

    (void)initscr();
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

}		    

/* VARARGS1 */
static void prompt(n, f, s)
/* print a message at the prompt line */
int n;
char *f, *s;
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(s)
char *s;
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static void randomplace(b, ss)
/* generate a valid random ship placement into px,py */
int b;
ship_t *ss;
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame()
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    bzero(board, sizeof(char) * BWIDTH * BDEPTH * 2);
    bzero(hits, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	extern char *strchr();
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...");
    (void) getch();
}

static int rnd(n)
int n;
{
    return(((rand() & 0x7FFF) % n));
}

static int getcoord(atcpu)
int atcpu;
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8': ny = cury+BDEPTH-1; nx = curx;   break;
	case 'j': case '2': ny = cury+1;        nx = curx;   break;
	case 'h': case '4': ny = cury;          nx = curx+BWIDTH-1; break;
	case 'l': case '6': ny = cury;          nx = curx+1; break;
	case 'y': case '7': ny = cury+BDEPTH-1; nx = curx+BWIDTH-1; break;
	case 'b': case '1': ny = cury+1;        nx = curx+BWIDTH-1; break;
	case 'u': case '9': ny = cury+BDEPTH-1; nx = curx+1; break;
	case 'n': case '3': ny = cury+1;        nx = curx+1; break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(b, y, x)
/* is this location on the selected zboard adjacent to a ship? */
int b;
int y, x;
{
    int	collide;

    /* anything on the square */
    if (collide = IS_SHIP(board[b][x][y]))
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static int checkplace(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if(vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert! Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(0);
	    }
	}
    return(1);
}

static int awinna()
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(x, y)
/* register a hit on the targeted ship */
int x, y;
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x, y;
			    
			    x = bx + i * xincr[ss->dir];
			    y = by + i * yincr[ss->dir];
			    if (ONBOARD(x, y))
			    {
				hits[turn][x][y] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y, x);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x = ss->x + i * xincr[ss->dir];
		    int y = ss->y + i * yincr[ss->dir];

		    hits[turn][x][y] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y, x);
			(void) addch(ss->symbol);
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn()
{
    ship_t *ss;
    bool hit;
    char *m;

    prompt(1, "Where do you want to shoot? ");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(s)
char *s;
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame();
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(px, py)
/* random-fire routine -- implements simple diagonal-striping strategy */
int	*px, *py;
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(x, y)
/* fire away at given location */
int	x, y;
{
    bool hit, sunk;
    ship_t *ss;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if (sunk = (hit && (ss = hitship(x, y))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn()
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

playagain()
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(c,op)
int c;
char *op[];
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(who)
int who;
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

main(argc, argv)
int argc;
char *argv[];
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame();
    /*NOTREACHED*/
}

/* bs.c ends here */

reset refs/tags/2.0
commit refs/tags/2.0
mark :4
author Eric S. Raymond <esr@thyrsus.com> 753384316 +0000
committer Eric S. Raymond <esr@thyrsus.com> 753384316 +0000
data 17
Initial revision
M 100644 :1 Makefile
M 100644 :2 README
M 100644 :3 bs.c

blob
mark :5
data 1816
.TH BATTLESHIPS 6 "Aug 23, 1989"
.SH NAME
bs \- battleships game
.SH SYNOPSIS
battle [ -b | -s ] [ -c ]
.SH DESCRIPTION
This program allows you to play the familiar Battleships game against the
computer on a 10x10 board. The interface is visual and largely
self-explanatory; you place your ships and pick your shots by moving the
cursor around the `sea' with the rogue/hack motion keys hjklyubn.
.PP
Note that when selecting a ship to place, you must type the capital letter
(these are, after all, capital ships). During ship placement, the `r' command
may be used to ignore the current position and randomly place your currently
selected ship. The `R' command will place all remaining ships randomly. The ^L
command (form feed, ASCII 12) will force a screen redraw).
.PP
The command-line arguments control game modes. 

.nf
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
.fi

The `blitz' variant allows a side to shoot for as long as it continues to
score hits.
.PP
The `salvo' game allows a player one shot per turn for each of his/her ships
still afloat.  This puts a premium scoring hits early and knocking out some
ships and also makes much harder the situation where you face a superior force
with only your PT-boat.
.PP
Normally, ships must be separated by at least one square of open water. The
-c option disables this check and allows them to close-pack.
.PP
The algorithm the computer uses once it has found a ship to sink is provably
optimal. The dispersion criterion for the random-fire algorithm may not be.
.SH AUTHORS
Originally written by one Bruce Holloway in 1986. Salvo mode added by Chuck A.
DeGaul (cbosgd!cad). Visual user interface, `closepack' option, code rewrite
and manual page by Eric S. Raymond <esr@snark.thyrsus.com> August 1989.

commit refs/tags/2.0
mark :6
author Eric S. Raymond <esr@thyrsus.com> 753386212 +0000
committer Eric S. Raymond <esr@thyrsus.com> 753386212 +0000
data 24
Checkin of manual page.
from :4
M 100644 :5 bs.xml

blob
mark :7
data 429
#	Makefile for bs, the Battleships game

# Flags for use with the Linux ncurses package (recommended)
# CFLAGS = -DNDEBUG  -I/usr/local/include -L/usr/local/lib
# TERMLIB = -lncurses
# CC = gcc

# Flags for use with stock curses
CFLAGS = -DNDEBUG
TERMLIB = -lcurses
CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar *~

shar:
	shar READ.ME bs.c Makefile bs.6 >bs.shar

blob
mark :8
data 1499
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write termcap games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

						Eric S. Raymond
						esr@snark.thyrsus.com


blob
mark :9
data 27718
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 */
#define _POSIX_SOURCE

#include <stdio.h>
#include <termios.h>
#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <assert.h>

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#ifdef isxdigit		/* aha, must be an AT&T system... */
#define srand(n)	srand48(n)
#define rand()		lrand48()
extern long lrand48();
extern void srand48();
#define bzero(s, n)	(void)memset((char *)(s), '\0', n)
extern char *memset();
/*
 * Try this if ungetch() fails to resolve.
 *
 * #define ungetch ungetc
 */
#endif /* isxdigit */

extern unsigned sleep();
extern char *strchr(), *strcpy();
extern long time();
extern void exit();

static bool checkplace();

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    char dir;		/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(sig)
/* end the game, either normally or due to signal */
int	sig;
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(0);
}

static void announceopts()
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro()
{
    extern char *getlogin();
    char *tmpname;

    srand(time(0L)+getpid());	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if(tmpname = getlogin())
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

}		    

/* VARARGS1 */
static void prompt(n, f, s)
/* print a message at the prompt line */
int n;
char *f, *s;
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(s)
char *s;
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(n)
int n;
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(b, ss)
/* generate a valid random ship placement into px,py */
int b;
ship_t *ss;
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame()
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    bzero(board, sizeof(char) * BWIDTH * BDEPTH * 2);
    bzero(hits, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	extern char *strchr();
	static char getcoord();
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...");
    (void) getch();
}

static int getcoord(atcpu)
int atcpu;
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(b, y, x)
/* is this location on the selected zboard adjacent to a ship? */
int b;
int y, x;
{
    int	collide;

    /* anything on the square */
    if (collide = IS_SHIP(board[b][x][y]))
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool checkplace(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna()
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(x, y)
/* register a hit on the targeted ship */
int x, y;
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x, y;
			    
			    x = bx + i * xincr[ss->dir];
			    y = by + i * yincr[ss->dir];
			    if (ONBOARD(x, y))
			    {
				hits[turn][x][y] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y, x);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x = ss->x + i * xincr[ss->dir];
		    int y = ss->y + i * yincr[ss->dir];

		    hits[turn][x][y] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y, x);
			(void) addch(ss->symbol);
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn()
{
    ship_t *ss;
    bool hit;
    char *m;

    prompt(1, "Where do you want to shoot? ");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(s)
char *s;
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame();
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(px, py)
/* random-fire routine -- implements simple diagonal-striping strategy */
int	*px, *py;
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(x, y)
/* fire away at given location */
int	x, y;
{
    bool hit, sunk;
    ship_t *ss;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if (sunk = (hit && (ss = hitship(x, y))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn()
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

playagain()
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(c,op)
int c;
char *op[];
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(who)
int who;
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

main(argc, argv)
int argc;
char *argv[];
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame();
    /*NOTREACHED*/
}

/* bs.c ends here */

blob
mark :10
data 1952
.TH BATTLESHIPS 6 "Nov 15 1993"
.SH NAME
bs \- battleships game
.SH SYNOPSIS
battle [ -b | -s ] [ -c ]
.SH DESCRIPTION
This program allows you to play the familiar Battleships game against the
computer on a 10x10 board. The interface is visual and largely
self-explanatory; you place your ships and pick your shots by moving the
cursor around the `sea' with the rogue/hack motion keys hjklyubn.  If
your UNIX has a modern (non-BSD) curses, your arrow keys will also work.
.PP
Note that when selecting a ship to place, you must type the capital letter
(these are, after all, capital ships). During ship placement, the `r' command
may be used to ignore the current position and randomly place your currently
selected ship. The `R' command will place all remaining ships randomly. The ^L
command (form feed, ASCII 12) will force a screen redraw).
.PP
The command-line arguments control game modes. 

.nf
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
.fi

The `blitz' variant allows a side to shoot for as long as it continues to
score hits.
.PP
The `salvo' game allows a player one shot per turn for each of his/her ships
still afloat.  This puts a premium scoring hits early and knocking out some
ships and also makes much harder the situation where you face a superior force
with only your PT-boat.
.PP
Normally, ships must be separated by at least one square of open water. The
-c option disables this check and allows them to close-pack.
.PP
The algorithm the computer uses once it has found a ship to sink is provably
optimal.  The dispersion criterion for the random-fire algorithm may not be.
.SH AUTHORS
Originally written by one Bruce Holloway in 1986. Salvo mode added by Chuck A.
DeGaul (cbosgd!cad). Visual user interface, `closepack' option, code rewrite
and manual page by Eric S. Raymond <esr@snark.thyrsus.com> August
1989.  Keypad support and ANSI/POSIX conformance, November '93.


commit refs/tags/2.0
mark :11
author Eric S. Raymond <esr@thyrsus.com> 753386483 +0000
committer Eric S. Raymond <esr@thyrsus.com> 753386483 +0000
data 19
Froze 2.0 release.
from :6
M 100644 :7 Makefile
M 100644 :8 README
M 100644 :9 bs.c
M 100644 :10 bs.xml

blob
mark :12
data 1948
.TH BATTLESHIPS 6 "Nov 15 1993"
.SH NAME
bs \- battleships game
.SH SYNOPSIS
bs [ -b | -s ] [ -c ]
.SH DESCRIPTION
This program allows you to play the familiar Battleships game against the
computer on a 10x10 board. The interface is visual and largely
self-explanatory; you place your ships and pick your shots by moving the
cursor around the `sea' with the rogue/hack motion keys hjklyubn.  If
your UNIX has a modern (non-BSD) curses, your arrow keys will also work.
.PP
Note that when selecting a ship to place, you must type the capital letter
(these are, after all, capital ships). During ship placement, the `r' command
may be used to ignore the current position and randomly place your currently
selected ship. The `R' command will place all remaining ships randomly. The ^L
command (form feed, ASCII 12) will force a screen redraw).
.PP
The command-line arguments control game modes. 

.nf
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
.fi

The `blitz' variant allows a side to shoot for as long as it continues to
score hits.
.PP
The `salvo' game allows a player one shot per turn for each of his/her ships
still afloat.  This puts a premium scoring hits early and knocking out some
ships and also makes much harder the situation where you face a superior force
with only your PT-boat.
.PP
Normally, ships must be separated by at least one square of open water. The
-c option disables this check and allows them to close-pack.
.PP
The algorithm the computer uses once it has found a ship to sink is provably
optimal.  The dispersion criterion for the random-fire algorithm may not be.
.SH AUTHORS
Originally written by one Bruce Holloway in 1986. Salvo mode added by Chuck A.
DeGaul (cbosgd!cad). Visual user interface, `closepack' option, code rewrite
and manual page by Eric S. Raymond <esr@snark.thyrsus.com> August
1989.  Keypad support and ANSI/POSIX conformance, November '93.


commit refs/tags/2.1
mark :13
author Eric S. Raymond <esr@thyrsus.com> 782943152 +0000
committer Eric S. Raymond <esr@thyrsus.com> 782943152 +0000
data 10
Fix typo.
from :11
M 100644 :12 bs.xml

blob
mark :14
data 429
#	Makefile for bs, the Battleships game

# Flags for use with the Linux ncurses package (recommended)
CFLAGS = -DNDEBUG  -I/usr/local/include -L/usr/local/lib
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# CFLAGS = -DNDEBUG
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar *~

shar:
	shar READ.ME bs.c Makefile bs.6 >bs.shar

blob
mark :15
data 27798
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 for Linux, October 1994.
 */
#define _POSIX_SOURCE

#include <stdio.h>
#include <termios.h>
#include <ncurses.h>	/* change this to curses.h if not on Linux */
#include <signal.h>
#include <ctype.h>
#include <assert.h>

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#ifdef isxdigit		/* aha, must be an AT&T system... */
#define srand(n)	srand48(n)
#define rand()		lrand48()
extern long lrand48();
extern void srand48();
#define bzero(s, n)	(void)memset((char *)(s), '\0', n)
extern char *memset();
/*
 * Try this if ungetch() fails to resolve.
 *
 * #define ungetch ungetc
 */
#endif /* isxdigit */

extern unsigned sleep();
extern char *strchr(), *strcpy();
extern long time();
extern void exit();

static bool checkplace();

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    char dir;		/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(sig)
/* end the game, either normally or due to signal */
int	sig;
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(0);
}

static void announceopts()
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro()
{
    extern char *getlogin();
    char *tmpname;

    srand(time(0L)+getpid());	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if(tmpname = getlogin())
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

}		    

/* VARARGS1 */
static void prompt(n, f, s)
/* print a message at the prompt line */
int n;
char *f, *s;
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(s)
char *s;
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(n)
int n;
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(b, ss)
/* generate a valid random ship placement into px,py */
int b;
ship_t *ss;
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame()
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    bzero(board, sizeof(char) * BWIDTH * BDEPTH * 2);
    bzero(hits, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	extern char *strchr();
	static char getcoord();
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...");
    (void) getch();
}

static int getcoord(atcpu)
int atcpu;
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(b, y, x)
/* is this location on the selected zboard adjacent to a ship? */
int b;
int y, x;
{
    int	collide;

    /* anything on the square */
    if (collide = IS_SHIP(board[b][x][y]))
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool checkplace(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna()
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(x, y)
/* register a hit on the targeted ship */
int x, y;
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x, y;
			    
			    x = bx + i * xincr[ss->dir];
			    y = by + i * yincr[ss->dir];
			    if (ONBOARD(x, y))
			    {
				hits[turn][x][y] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y, x);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x = ss->x + i * xincr[ss->dir];
		    int y = ss->y + i * yincr[ss->dir];

		    hits[turn][x][y] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y, x);
			(void) addch(ss->symbol);
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn()
{
    ship_t *ss;
    bool hit;
    char *m;

    prompt(1, "Where do you want to shoot? ");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(s)
char *s;
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame();
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(px, py)
/* random-fire routine -- implements simple diagonal-striping strategy */
int	*px, *py;
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(x, y)
/* fire away at given location */
int	x, y;
{
    bool hit, sunk;
    ship_t *ss;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if (sunk = (hit && (ss = hitship(x, y))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn()
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

playagain()
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(c,op)
int c;
char *op[];
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(who)
int who;
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

main(argc, argv)
int argc;
char *argv[];
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame();
    /*NOTREACHED*/
}

/* bs.c ends here */

commit refs/tags/2.1
mark :16
author Eric S. Raymond <esr@thyrsus.com> 782943987 +0000
committer Eric S. Raymond <esr@thyrsus.com> 782943987 +0000
data 18
Freeze for Linux.
from :13
M 100644 :14 Makefile
M 100644 :15 bs.c

blob
mark :17
data 27808
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 for Linux, October 1994.
 */
#define _POSIX_SOURCE

#include <stdio.h>
#include <termios.h>
#ifdef NCURSES
#include <ncurses.h>
#else
#include <curses.h>
#endif NCURSES
#include <signal.h>
#include <ctype.h>
#include <assert.h>

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#ifdef isxdigit		/* aha, must be an AT&T system... */
#define srand(n)	srand48(n)
#define rand()		lrand48()
extern long lrand48();
extern void srand48();
#define bzero(s, n)	(void)memset((char *)(s), '\0', n)
extern char *memset();
/*
 * Try this if ungetch() fails to resolve.
 *
 * #define ungetch ungetc
 */
#endif /* isxdigit */

extern unsigned sleep();
extern char *strchr(), *strcpy();
extern long time();
extern void exit();

static bool checkplace();

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    char dir;		/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(sig)
/* end the game, either normally or due to signal */
int	sig;
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(0);
}

static void announceopts()
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro()
{
    extern char *getlogin();
    char *tmpname;

    srand(time(0L)+getpid());	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if(tmpname = getlogin())
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

}		    

/* VARARGS1 */
static void prompt(n, f, s)
/* print a message at the prompt line */
int n;
char *f, *s;
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(s)
char *s;
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(n)
int n;
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(b, ss)
/* generate a valid random ship placement into px,py */
int b;
ship_t *ss;
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame()
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    bzero(board, sizeof(char) * BWIDTH * BDEPTH * 2);
    bzero(hits, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	extern char *strchr();
	static char getcoord();
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...");
    (void) getch();
}

static int getcoord(atcpu)
int atcpu;
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(b, y, x)
/* is this location on the selected zboard adjacent to a ship? */
int b;
int y, x;
{
    int	collide;

    /* anything on the square */
    if (collide = IS_SHIP(board[b][x][y]))
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool checkplace(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna()
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(x, y)
/* register a hit on the targeted ship */
int x, y;
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x, y;
			    
			    x = bx + i * xincr[ss->dir];
			    y = by + i * yincr[ss->dir];
			    if (ONBOARD(x, y))
			    {
				hits[turn][x][y] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y, x);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x = ss->x + i * xincr[ss->dir];
		    int y = ss->y + i * yincr[ss->dir];

		    hits[turn][x][y] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y, x);
			(void) addch(ss->symbol);
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn()
{
    ship_t *ss;
    bool hit;
    char *m;

    prompt(1, "Where do you want to shoot? ");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(s)
char *s;
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame();
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(px, py)
/* random-fire routine -- implements simple diagonal-striping strategy */
int	*px, *py;
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(x, y)
/* fire away at given location */
int	x, y;
{
    bool hit, sunk;
    ship_t *ss;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if (sunk = (hit && (ss = hitship(x, y))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn()
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

playagain()
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(c,op)
int c;
char *op[];
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(who)
int who;
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

main(argc, argv)
int argc;
char *argv[];
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame();
    /*NOTREACHED*/
}

/* bs.c ends here */

commit refs/tags/2.1
mark :18
author Eric S. Raymond <esr@thyrsus.com> 783030956 +0000
committer Eric S. Raymond <esr@thyrsus.com> 783030956 +0000
data 24
Better ncurses support.
from :16
M 100644 :17 bs.c

blob
mark :19
data 503
#	Makefile for bs, the Battleships game

# Flags for use with the Linux ncurses package (recommended)
CFLAGS = -DNCURSES  -I/usr/local/include -L/usr/local/lib
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# CFLAGS =
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

bs.shar:
	shar READ.ME bs.c Makefile bs.6 >bs.shar

bs.tar.gz:
	tar -cvf bs.tar READ.ME bs.c Makefile bs.6
	gzip bs.tar

commit refs/tags/2.1
mark :20
author Eric S. Raymond <esr@thyrsus.com> 783031868 +0000
committer Eric S. Raymond <esr@thyrsus.com> 783031868 +0000
data 32
Better distribution production.
from :18
M 100644 :19 Makefile

blob
mark :21
data 1543
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write termcap games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

						Eric S. Raymond
						esr@snark.thyrsus.com
					(WWW: //www.thyrsus.com/~esr/home.html)

blob
mark :22
data 2064
.TH BATTLESHIPS 6 "Nov 15 1993"
.SH NAME
bs \- battleships game
.SH SYNOPSIS
bs [ -b | -s ] [ -c ]
.SH DESCRIPTION
This program allows you to play the familiar Battleships game against the
computer on a 10x10 board. The interface is visual and largely
self-explanatory; you place your ships and pick your shots by moving the
cursor around the `sea' with the rogue/hack motion keys hjklyubn.  If
your UNIX has a modern (non-BSD) curses, your arrow keys will also work.
.PP
Note that when selecting a ship to place, you must type the capital letter
(these are, after all, capital ships). During ship placement, the `r' command
may be used to ignore the current position and randomly place your currently
selected ship. The `R' command will place all remaining ships randomly. The ^L
command (form feed, ASCII 12) will force a screen redraw).
.PP
The command-line arguments control game modes. 

.nf
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
.fi

The `blitz' variant allows a side to shoot for as long as it continues to
score hits.
.PP
The `salvo' game allows a player one shot per turn for each of his/her ships
still afloat.  This puts a premium scoring hits early and knocking out some
ships and also makes much harder the situation where you face a superior force
with only your PT-boat.
.PP
Normally, ships must be separated by at least one square of open water. The
-c option disables this check and allows them to close-pack.
.PP
The algorithm the computer uses once it has found a ship to sink is provably
optimal.  The dispersion criterion for the random-fire algorithm may not be.
.SH AUTHORS
Originally written by one Bruce Holloway in 1986. Salvo mode added by Chuck A.
DeGaul (cbosgd!cad). Visual user interface, `closepack' option, code rewrite
and manual page by Eric S. Raymond <esr@snark.thyrsus.com> August
1989.  Keypad support and ANSI/POSIX conformance, November '93.  See
http://www.thyrsus.com/~esr/home.html for the latest version of bs,
also other software and resources by ESR.



commit refs/tags/2.1
mark :23
author Eric S. Raymond <esr@thyrsus.com> 785450861 +0000
committer Eric S. Raymond <esr@thyrsus.com> 785450861 +0000
data 21
Added WWW home page.
from :20
M 100644 :21 README
M 100644 :22 bs.xml

blob
mark :24
data 1545
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write termcap games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

					Eric S. Raymond
					esr@snark.thyrsus.com
				(WWW: http://www.thyrsus.com/~esr/home.html)

blob
mark :25
data 2047
.TH BATTLESHIPS 6 "Nov 15 1993"
.SH NAME
bs \- battleships game
.SH SYNOPSIS
bs [ -b | -s ] [ -c ]
.SH DESCRIPTION
This program allows you to play the familiar Battleships game against the
computer on a 10x10 board. The interface is visual and largely
self-explanatory; you place your ships and pick your shots by moving the
cursor around the `sea' with the rogue/hack motion keys hjklyubn.  If
your UNIX has a modern (non-BSD) curses, your arrow keys will also work.
.PP
Note that when selecting a ship to place, you must type the capital letter
(these are, after all, capital ships). During ship placement, the `r' command
may be used to ignore the current position and randomly place your currently
selected ship. The `R' command will place all remaining ships randomly. The ^L
command (form feed, ASCII 12) will force a screen redraw).
.PP
The command-line arguments control game modes. 

.nf
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
.fi

The `blitz' variant allows a side to shoot for as long as it continues to
score hits.
.PP
The `salvo' game allows a player one shot per turn for each of his/her ships
still afloat.  This puts a premium scoring hits early and knocking out some
ships and also makes much harder the situation where you face a superior force
with only your PT-boat.
.PP
Normally, ships must be separated by at least one square of open water. The
-c option disables this check and allows them to close-pack.
.PP
The algorithm the computer uses once it has found a ship to sink is provably
optimal.  The dispersion criterion for the random-fire algorithm may not be.
.SH AUTHORS
Originally written by one Bruce Holloway in 1986. Salvo mode added by Chuck A.
DeGaul (cbosgd!cad). Visual user interface, `closepack' option, code rewrite
and manual page by Eric S. Raymond <esr@snark.thyrsus.com> August
1989.  Keypad support and ANSI/POSIX conformance, November '93.  See
http://www.thyrsus.com/~esr/home.html for updates,
also other software and resources by ESR.



commit refs/tags/2.1
mark :26
author Eric S. Raymond <esr@thyrsus.com> 785451814 +0000
committer Eric S. Raymond <esr@thyrsus.com> 785451814 +0000
data 21
Added WWW home page.
from :23
M 100644 :24 README

blob
mark :27
data 27977
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 for Linux, October 1994.
 * Slipstreamed in fixes to make it gcc -Wall clean, May '95.
 */
#define _POSIX_SOURCE

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#ifdef isxdigit		/* aha, must be an AT&T system... */

#if !defined(__386BSD__) && !defined(__bsdi__)
#define srand(n)	srand48(n)
#define rand()		lrand48()
extern long lrand48();
extern void srand48();
#endif

#define bzero(s, n)	(void)memset((char *)(s), '\0', n)
extern char *memset();
/*
 * Try this if ungetch() fails to resolve.
 *
 * #define ungetch ungetc
 */
#endif /* isxdigit */

extern unsigned sleep();
extern char *strchr(), *strcpy();
extern long time();
extern void exit();

static bool checkplace();

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    unsigned char dir;	/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(sig)
/* end the game, either normally or due to signal */
int	sig;
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(0);
}

static void announceopts()
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro()
{
    extern char *getlogin();
    char *tmpname;

    srand(time(0L)+getpid());	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

}		    

/* VARARGS1 */
static void prompt(n, f, s)
/* print a message at the prompt line */
int n;
char *f, *s;
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(s)
char *s;
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(n)
int n;
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(b, ss)
/* generate a valid random ship placement into px,py */
int b;
ship_t *ss;
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame()
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    bzero(board, sizeof(char) * BWIDTH * BDEPTH * 2);
    bzero(hits, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	extern char *strchr();
	static char getcoord();
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...");
    (void) getch();
}

static int getcoord(atcpu)
int atcpu;
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(b, y, x)
/* is this location on the selected zboard adjacent to a ship? */
int b;
int y, x;
{
    int	collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != 0)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool checkplace(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna()
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(x, y)
/* register a hit on the targeted ship */
int x, y;
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x, y;
			    
			    x = bx + i * xincr[ss->dir];
			    y = by + i * yincr[ss->dir];
			    if (ONBOARD(x, y))
			    {
				hits[turn][x][y] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y, x);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x = ss->x + i * xincr[ss->dir];
		    int y = ss->y + i * yincr[ss->dir];

		    hits[turn][x][y] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y, x);
			(void) addch(ss->symbol);
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn()
{
    ship_t *ss;
    bool hit;
    char *m = NULL;

    prompt(1, "Where do you want to shoot? ");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(s)
char *s;
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame();
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(px, py)
/* random-fire routine -- implements simple diagonal-striping strategy */
int	*px, *py;
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(x, y)
/* fire away at given location */
int	x, y;
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn()
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

int playagain()
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(c,op)
int c;
char *op[];
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(who)
int who;
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

main(argc, argv)
int argc;
char *argv[];
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame();
    /*NOTREACHED*/
}

/* bs.c ends here */

commit refs/tags/2.1
mark :28
author Eric S. Raymond <esr@thyrsus.com> 799817026 +0000
committer Eric S. Raymond <esr@thyrsus.com> 799817026 +0000
data 19
gcc -Wall changes.
from :26
M 100644 :27 bs.c

blob
mark :29
data 510
#	Makefile for bs, the Battleships game

# Flags for use with the Linux ncurses package (recommended)
CFLAGS = -DNCURSES  -I/usr/local/include -L/usr/local/lib
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# CFLAGS =
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

bs.shar:
	shar READ.ME bs.c Makefile bs.6 >bs.shar

bs.tar.gz:
	tar -cvf bs.tar READ.ME bs.c Makefile bs.6 bs.lsm
	gzip bs.tar

commit refs/tags/2.1
mark :30
author Eric S. Raymond <esr@thyrsus.com> 799819470 +0000
committer Eric S. Raymond <esr@thyrsus.com> 799819470 +0000
data 13
Added bs.lsm
from :28
M 100644 :29 Makefile

blob
mark :31
data 1542
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write termcap games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

					Eric S. Raymond
					esr@snark.thyrsus.com
				(WWW: http://www.ccil.org/~esr/home.html)

blob
mark :32
data 2044
.TH BATTLESHIPS 6 "Nov 15 1993"
.SH NAME
bs \- battleships game
.SH SYNOPSIS
bs [ -b | -s ] [ -c ]
.SH DESCRIPTION
This program allows you to play the familiar Battleships game against the
computer on a 10x10 board. The interface is visual and largely
self-explanatory; you place your ships and pick your shots by moving the
cursor around the `sea' with the rogue/hack motion keys hjklyubn.  If
your UNIX has a modern (non-BSD) curses, your arrow keys will also work.
.PP
Note that when selecting a ship to place, you must type the capital letter
(these are, after all, capital ships). During ship placement, the `r' command
may be used to ignore the current position and randomly place your currently
selected ship. The `R' command will place all remaining ships randomly. The ^L
command (form feed, ASCII 12) will force a screen redraw).
.PP
The command-line arguments control game modes. 

.nf
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
.fi

The `blitz' variant allows a side to shoot for as long as it continues to
score hits.
.PP
The `salvo' game allows a player one shot per turn for each of his/her ships
still afloat.  This puts a premium scoring hits early and knocking out some
ships and also makes much harder the situation where you face a superior force
with only your PT-boat.
.PP
Normally, ships must be separated by at least one square of open water. The
-c option disables this check and allows them to close-pack.
.PP
The algorithm the computer uses once it has found a ship to sink is provably
optimal.  The dispersion criterion for the random-fire algorithm may not be.
.SH AUTHORS
Originally written by one Bruce Holloway in 1986. Salvo mode added by Chuck A.
DeGaul (cbosgd!cad). Visual user interface, `closepack' option, code rewrite
and manual page by Eric S. Raymond <esr@snark.thyrsus.com> August
1989.  Keypad support and ANSI/POSIX conformance, November '93.  See
http://www.ccil.org/~esr/home.html for updates,
also other software and resources by ESR.



commit refs/tags/2.1
mark :33
author Eric S. Raymond <esr@thyrsus.com> 799897049 +0000
committer Eric S. Raymond <esr@thyrsus.com> 799897049 +0000
data 33
Corrected my home page location.
from :30
M 100644 :31 README
M 100644 :32 bs.xml

blob
mark :34
data 28087
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 */
#define _POSIX_SOURCE

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>
#include <time.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

static int getcoord(int);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    unsigned char dir;	/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(int sig)
/* end the game, either normally or due to signal */
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(sig);
}

static void announceopts(void)
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro(void)
{
    extern char *getlogin(void);
    char *tmpname;

    srand((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

#ifdef NCURSES_MOUSE_VERSION
    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
#endif /* NCURSES_MOUSE_VERSION*/
}		    

/* VARARGS1 */
static void prompt(int n, char *f, char *s)
/* print a message at the prompt line */
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(int n)
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(int b, ship_t *ss)
/* generate a valid random ship placement into px,py */
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...", "");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...", "");
    (void) getch();
}

static int getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
#ifdef NCURSES_MOUSE_VERSION
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		    beep();
	    }
	    break;
#endif /* NCURSES_MOUSE_VERSION */
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(int b, int y, int x)
/* is this location on the selected zboard adjacent to a ship? */
{
    int	collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != 0)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(int x, int y)
/* register a hit on the targeted ship */
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;
			    
			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y1, x1);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn(void)
{
    ship_t *ss;
    bool hit;
    char *m = NULL;

    prompt(1, "Where do you want to shoot? ", "");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.", "");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(char *s)
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(int *px, int *py)
/* random-fire routine -- implements simple diagonal-striping strategy */
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(int x, int y)
/* fire away at given location */
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn(void)
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

static
int playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(int c, char *op[])
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(int who)
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int main(int argc, char *argv[])
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    /*NOTREACHED*/
}

/* bs.c ends here */

commit refs/tags/2.1
mark :35
author Eric S. Raymond <esr@thyrsus.com> 811393290 +0000
committer Eric S. Raymond <esr@thyrsus.com> 811393290 +0000
data 55
This matches the 2.1 that went out with ncurses-1.9.5.
from :33
M 100644 :34 bs.c

blob
mark :36
data 1541
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write curses games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

					Eric S. Raymond
					esr@snark.thyrsus.com
				(WWW: http://www.ccil.org/~esr/home.html)

commit refs/tags/2.2
mark :37
author Eric S. Raymond <esr@thyrsus.com> 818221328 +0000
committer Eric S. Raymond <esr@thyrsus.com> 818221328 +0000
data 16
Comment change.
from :35
M 100644 :36 README

blob
mark :38
data 311
Description: Battleships against the computer (text mode)
Name: bs
Version: 2.1
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.1.tar.gz
Copyright: BSD-like
Group: Games

%prep
%setup

%build
make

%install
rm -f /usr/bin/bs
cp bs /usr/bin
cp bs.6 /usr/man/man1/bs.6

%files
%doc /usr/man/man1/bs.6
/usr/bin/bs

commit refs/tags/2.2
mark :39
author Eric S. Raymond <esr@thyrsus.com> 818222264 +0000
committer Eric S. Raymond <esr@thyrsus.com> 818222264 +0000
data 17
Initial revision
from :37
M 100644 :38 bs.spec

blob
mark :40
data 764
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.1

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs.tar.gz:
	(cd ..; tar -cvf bs-$(V)/bs.tar `echo $(SOURCES) | sed "/ /s// bs-$(V)\//g"`)
	gzip bs.tar

rpm: bs.tar.gz
	cp bs.tar.gz /usr/src/SOURCES/bs-$(V).tar.gz
	cp bs.spec /usr/src/SPECS/bs-$(V)-1.spec
	rpm -ba bs-$(V)-1.spec

commit refs/tags/2.2
mark :41
author Eric S. Raymond <esr@thyrsus.com> 818222288 +0000
committer Eric S. Raymond <esr@thyrsus.com> 818222288 +0000
data 21
Made this RPM-ready.
from :39
M 100644 :40 Makefile

blob
mark :42
data 771
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.1

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs.tar.gz:
	(cd ..; tar -cvf bs-$(V)/bs.tar `echo $(SOURCES) | sed "/\(^\| \)/s// bs-$(V)\//g"`)
	gzip bs.tar

rpm: bs.tar.gz
	cp bs.tar.gz /usr/src/SOURCES/bs-$(V).tar.gz
	cp bs.spec /usr/src/SPECS/bs-$(V)-1.spec
	rpm -ba bs-$(V)-1.spec

commit refs/tags/2.2
mark :43
author Eric S. Raymond <esr@thyrsus.com> 818223365 +0000
committer Eric S. Raymond <esr@thyrsus.com> 818223365 +0000
data 29
Fix the initial-file glitch.
from :41
M 100644 :42 Makefile

blob
mark :44
data 782
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.1

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs.tar:
	(cd ..; tar -cvf bs-$(V)/bs.tar `echo $(SOURCES) | sed "/\(^\| \)/s// bs-$(V)\//g"`)
bs.tar.gz:
	gzip -f bs.tar

rpm: bs.tar.gz
	cp bs.tar.gz /usr/src/SOURCES/bs-$(V).tar.gz
	cp bs.spec /usr/src/SPECS/bs-$(V)-1.spec
	rpm -ba bs-$(V)-1.spec

commit refs/tags/2.2
mark :45
author Eric S. Raymond <esr@thyrsus.com> 818223600 +0000
committer Eric S. Raymond <esr@thyrsus.com> 818223600 +0000
data 23
Add -f option to gzip.
from :43
M 100644 :44 Makefile

blob
mark :46
data 306
Description: Battleships against the computer (text mode)
Name: bs
Version: 2.1
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.1.tar.gz
Copyright: BSD-like
Group: Games

%prep
%setup

%build
make

%install
rm -f /usr/bin/bs
cp bs /usr/bin
cp bs.6 /usr/man/man1/bs.6

%files
/usr/man/man1/bs.6
/usr/bin/bs

commit refs/tags/2.2
mark :47
author Eric S. Raymond <esr@thyrsus.com> 818255500 +0000
committer Eric S. Raymond <esr@thyrsus.com> 818255500 +0000
data 16
%doc corrected.
from :45
M 100644 :46 bs.spec

blob
mark :48
data 306
Description: Battleships against the computer (text mode)
Name: bs
Version: 2.1
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.1.tar.gz
Copyright: BSD-like
Group: Games

%prep
%setup

%build
make

%install
rm -f /usr/bin/bs
cp bs /usr/bin
cp bs.6 /usr/man/man6/bs.6

%files
/usr/man/man6/bs.6
/usr/bin/bs

commit refs/tags/2.2
mark :49
author Eric S. Raymond <esr@thyrsus.com> 818257910 +0000
committer Eric S. Raymond <esr@thyrsus.com> 818257910 +0000
data 23
Corrected man section.
from :47
M 100644 :48 bs.spec

blob
mark :50
data 789
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.1

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs.tar:
	(cd ..; tar -cvf bs-$(V)/bs.tar `echo $(SOURCES) | sed "/\(^\| \)/s// bs-$(V)\//g"`)
bs.tar.gz: bs.tar
	gzip -f bs.tar

rpm: bs.tar.gz
	cp bs.tar.gz /usr/src/SOURCES/bs-$(V).tar.gz
	cp bs.spec /usr/src/SPECS/bs-$(V)-1.spec
	rpm -ba bs-$(V)-1.spec

commit refs/tags/2.2
mark :51
author Eric S. Raymond <esr@thyrsus.com> 818377562 +0000
committer Eric S. Raymond <esr@thyrsus.com> 818377562 +0000
data 8
Nailed.
from :49
M 100644 :50 Makefile

blob
mark :52
data 28084
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 */
#define _POSIX_SOURCE

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>
#include <time.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

static int getcoord(int);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    unsigned char dir;	/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(int sig)
/* end the game, either normally or due to signal */
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(sig);
}

static void announceopts(void)
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro(void)
{
    extern char *getlogin(void);
    char *tmpname;

    srand((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

#ifdef NCURSES_MOUSE_VERSION
    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
#endif /* NCURSES_MOUSE_VERSION*/
}		    

/* VARARGS1 */
static void prompt(int n, char *f, char *s)
/* print a message at the prompt line */
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(int n)
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(int b, ship_t *ss)
/* generate a valid random ship placement into px,py */
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...", "");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...", "");
    (void) getch();
}

static int getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
#ifdef NCURSES_MOUSE_VERSION
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		    beep();
	    }
	    break;
#endif /* NCURSES_MOUSE_VERSION */
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(int b, int y, int x)
/* is this location on the selected zboard adjacent to a ship? */
{
    int	collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != 0)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(int x, int y)
/* register a hit on the targeted ship */
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;
			    
			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y1, x1);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn(void)
{
    ship_t *ss;
    bool hit;
    char *m = NULL;

    prompt(1, "Where do you want to shoot? ", "");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.", "");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(char *s)
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(int *px, int *py)
/* random-fire routine -- implements simple diagonal-striping strategy */
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(int x, int y)
/* fire away at given location */
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn(void)
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

static
int playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(int c, char *op[])
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(int who)
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int main(int argc, char *argv[])
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    /*NOTREACHED*/
}

/* bs.c ends here */

commit refs/tags/2.2
mark :53
author Eric S. Raymond <esr@thyrsus.com> 831608059 +0000
committer Eric S. Raymond <esr@thyrsus.com> 831608059 +0000
data 32
Slipstream this minor change...
from :51
M 100644 :52 bs.c

blob
mark :54
data 28473
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 *
 * $Id: bs.c,v 1.22 1997/12/20 15:11:53 tom Exp $
 */

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <unistd.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#define	EXIT_SUCCESS	0
#define EXIT_FAILURE	1

static int getcoord(int);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	(isupper(c) ? TRUE : FALSE)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;			/* name of the ship type */
    int hits;			/* how many times has this ship been hit? */
    char symbol;		/* symbol for game purposes */
    int length;			/* length of ship */
    char x, y;			/* coordinates of ship start point */
    unsigned char dir;		/* direction of `bow' */
    bool placed;		/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

static ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

static ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH];
static char board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(int sig GCC_UNUSED)
/* end the game, either normally or due to signal */
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(EXIT_FAILURE);
}

static void announceopts(void)
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro(void)
{
    char *tmpname;

    srand((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

#ifdef NCURSES_MOUSE_VERSION
    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
#endif /* NCURSES_MOUSE_VERSION*/
}		    

/* VARARGS1 */
static void prompt(int n, NCURSES_CONST char *f, const char *s)
/* print a message at the prompt line */
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(NCURSES_CONST char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(int n)
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(int b, ship_t *ss)
/* generate a valid random ship placement into px,py */
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;

	ss = plyship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...", "");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...", "");
    (void) getch();
}

static int getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
#ifdef NCURSES_MOUSE_VERSION
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		{
		    beep();
		    continue;
		}
	    }
	    /* no fall through */
#endif /* NCURSES_MOUSE_VERSION */

	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static bool collidecheck(int b, int y, int x)
/* is this location on the selected zboard adjacent to a ship? */
{
    bool collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != FALSE)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend)
	     && IS_SHIP(board[b][xend][yend])) {
		collide = TRUE;
		break;
	    }
	}
    }
    return(collide);
}

static bool checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(FALSE);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(int x, int y)
/* register a hit on the targeted ship */
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if((sym = board[OTHER][x][y]) == 0)
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;
			    
			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y1, x1);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn(void)
{
    ship_t *ss;
    bool hit;
    NCURSES_CONST char *m = NULL;

    prompt(1, "Where do you want to shoot? ", "");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.", "");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = (hit ? MARK_HIT : MARK_MISS);
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return (hit);
}

static int sgetc(const char *s)
{
    const char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(int *px, int *py)
/* random-fire routine -- implements simple diagonal-striping strategy */
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(EXIT_FAILURE);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static int cpufire(int x, int y)
/* fire away at given location */
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))) != 0)
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return ((hit ? (sunk ? S_SUNK : S_HIT) : S_MISS) ? TRUE : FALSE);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn(void)
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n;
    int hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return ((hit) ? TRUE : FALSE);
}

static
int playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(int c, char *op[])
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(EXIT_FAILURE);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(EXIT_FAILURE);
		}
	    }
	}
    }
}

static int scount(int who)
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int main(int argc, char *argv[])
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    /*NOTREACHED*/
}

/* bs.c ends here */

commit refs/tags/2.2
mark :55
author Eric S. Raymond <esr@thyrsus.com> 903066799 +0000
committer Eric S. Raymond <esr@thyrsus.com> 903066799 +0000
data 14
Code cleanup.
from :53
M 100644 :54 bs.c

blob
mark :56
data 759
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.2

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs-$(V).tar.gz:
	tar --name-prefix='bs-$(V)/' -czf bs-$(V).tar.gz $(SOURCES)

tgz: bs-$(V).tar.gz

rpm: bs.tar.gz
	cp bs.tar.gz /usr/src/SOURCES/bs-$(V).tar.gz
	cp bs.spec /usr/src/SPECS/bs-$(V)-1.spec
	rpm -ba bs-$(V)-1.spec

commit refs/tags/2.2
mark :57
author Eric S. Raymond <esr@thyrsus.com> 903067214 +0000
committer Eric S. Raymond <esr@thyrsus.com> 903067214 +0000
data 9
Updated.
from :55
M 100644 :56 Makefile

blob
mark :58
data 1018
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.2

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs-$(V).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:bs-$(V)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(V))
	(cd ..; tar -czvf bs/bs-$(V).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(V))

dist: bs-$(V).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(V).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(V)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(V)*.src.rpm .


blob
mark :59
data 510
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.2
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.2.tar.gz
Copyright: BSD-like
Group: Games
%description
The classic game of Battleships agains the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
rm -f /usr/bin/bs
cp bs /usr/bin
cp bs.6 /usr/man/man6/bs.6

%files
/usr/man/man6/bs.6
/usr/bin/bs

commit refs/tags/2.3
mark :60
author Eric S. Raymond <esr@thyrsus.com> 914212464 +0000
committer Eric S. Raymond <esr@thyrsus.com> 914212464 +0000
data 20
We can do RPMs now.
from :57
M 100644 :58 Makefile

blob
mark :61
data 1018
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.3

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs-$(V).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:bs-$(V)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(V))
	(cd ..; tar -czvf bs/bs-$(V).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(V))

dist: bs-$(V).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(V).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(V)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(V)*.src.rpm .


blob
mark :62
data 28800
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 *
 * $Id: bs.c,v 1.8 1998/08/14 03:53:19 esr Exp esr $
 */

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <unistd.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#define	EXIT_SUCCESS	0
#define EXIT_FAILURE	1

static int getcoord(int);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	(isupper(c) ? TRUE : FALSE)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;			/* name of the ship type */
    int hits;			/* how many times has this ship been hit? */
    char symbol;		/* symbol for game purposes */
    int length;			/* length of ship */
    char x, y;			/* coordinates of ship start point */
    unsigned char dir;		/* direction of `bow' */
    bool placed;		/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

static ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

static ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH];
static char board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(int sig GCC_UNUSED)
/* end the game, either normally or due to signal */
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(EXIT_FAILURE);
}

static void announceopts(void)
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro(void)
{
    char *tmpname;

    srand((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

#ifdef NCURSES_MOUSE_VERSION
    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
#endif /* NCURSES_MOUSE_VERSION*/
}		    

/* VARARGS1 */
static void prompt(int n, NCURSES_CONST char *f, const char *s)
/* print a message at the prompt line */
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(NCURSES_CONST char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(int n)
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(int b, ship_t *ss)
/* generate a valid random ship placement into px,py */
{

    do {
	ss->dir = rnd(2) ? E : S;
	ss->x = rnd(BWIDTH - (ss->dir == E ? ss->length : 0));
	ss->y = rnd(BDEPTH - (ss->dir == S ? ss->length : 0));
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;

	ss = plyship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...", "");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...", "");
    (void) getch();
}

static int getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
#ifdef NCURSES_MOUSE_VERSION
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		{
		    beep();
		    continue;
		}
	    }
	    /* no fall through */
#endif /* NCURSES_MOUSE_VERSION */

	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static bool collidecheck(int b, int y, int x)
/* is this location on the selected zboard adjacent to a ship? */
{
    bool collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != FALSE)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend)
	     && IS_SHIP(board[b][xend][yend])) {
		collide = TRUE;
		break;
	    }
	}
    }
    return(collide);
}

static bool checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + (ss->length - 1) * xincr[ss->dir];
    yend = ss->y + (ss->length - 1) * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(FALSE);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(int x, int y)
/* register a hit on the targeted ship */
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if((sym = board[OTHER][x][y]) == 0)
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;
			    
			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y1, x1);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
				else
				{
				  pgoto(y1, x1);
				  (void)addch(SHOWSPLASH);
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		    else
		    {
		      pgoto(y1, x1);
#ifdef A_COLOR
		      if (has_colors())
			attron(COLOR_PAIR(COLOR_RED));
#endif /* A_COLOR */
		      (void)addch(SHOWHIT);
#ifdef A_COLOR
		      attrset(0);
#endif /* A_COLOR */
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn(void)
{
    ship_t *ss;
    bool hit;
    NCURSES_CONST char *m = NULL;

    prompt(1, "Where do you want to shoot? ", "");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.", "");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = (hit ? MARK_HIT : MARK_MISS);
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return (hit);
}

static int sgetc(const char *s)
{
    const char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(int *px, int *py)
/* random-fire routine -- implements simple diagonal-striping strategy */
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(EXIT_FAILURE);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static int cpufire(int x, int y)
/* fire away at given location */
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))) != 0)
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return ((hit ? (sunk ? S_SUNK : S_HIT) : S_MISS) ? TRUE : FALSE);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn(void)
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n;
    int hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return ((hit) ? TRUE : FALSE);
}

static
int playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(int c, char *op[])
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(EXIT_FAILURE);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(EXIT_FAILURE);
		}
	    }
	}
    }
}

static int scount(int who)
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int main(int argc, char *argv[])
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    /*NOTREACHED*/
}

/* bs.c ends here */

commit refs/tags/2.3
mark :63
author Eric S. Raymond <esr@thyrsus.com> 989267279 +0000
committer Eric S. Raymond <esr@thyrsus.com> 989267279 +0000
data 26
Bug fixes by  Eric Sigra.
from :60
M 100644 :61 Makefile

blob
mark :64
data 510
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.3
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.3.tar.gz
Copyright: BSD-like
Group: Games
%description
The classic game of Battleships agains the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
rm -f /usr/bin/bs
cp bs /usr/bin
cp bs.6 /usr/man/man6/bs.6

%files
/usr/man/man6/bs.6
/usr/bin/bs

commit refs/tags/2.3
mark :65
author Eric S. Raymond <esr@thyrsus.com> 989587600 +0000
committer Eric S. Raymond <esr@thyrsus.com> 989587600 +0000
data 31
Version bump for 2.3 release. 
from :63
M 100644 :64 bs.spec
M 100644 :62 bs.c

blob
mark :66
data 522
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.3
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.3.tar.gz
Copyright: BSD-like
Group: Games
%description
The classic game of Battleships agains the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
rm -f /usr/bin/bs
cp bs /usr/bin
cp bs.6 /usr/share/man/man6/bs.6

%files
/usr/share/man/man6/bs.6
/usr/bin/bs

commit refs/tags/2.3
mark :67
author Eric S. Raymond <esr@thyrsus.com> 989587672 +0000
committer Eric S. Raymond <esr@thyrsus.com> 989587672 +0000
data 31
Fix up man directory location.
from :65
M 100644 :66 bs.spec

blob
mark :68
data 1078
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
VERSION=2.3

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs-$(VERSION).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(VERSION).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(VERSION)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERSION)*.src.rpm .


commit refs/tags/2.4
mark :69
author Eric S. Raymond <esr@thyrsus.com> 989587761 +0000
committer Eric S. Raymond <esr@thyrsus.com> 989587761 +0000
data 19
Fix version macro.
from :67
M 100644 :68 Makefile

blob
mark :70
data 2833
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>BATTLESHIPS</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.ccil.org/~esr/'>http://www.ccil.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>


commit refs/tags/2.4
mark :71
author Eric S. Raymond <esr@thyrsus.com> 1026340256 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1026340256 +0000
data 19
First cut at SGML.
from :69
M 100644 :70 bs.xml

blob
mark :72
data 2824
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>bs</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.ccil.org/~esr/'>http://www.ccil.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>


commit refs/tags/2.4
mark :73
author Eric S. Raymond <esr@thyrsus.com> 1026340463 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1026340463 +0000
data 23
Make the right target.
from :71
M 100644 :72 bs.xml

blob
mark :74
data 1174
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
VERSION=2.4

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6:
	docbook2man bs.sgml

clean:
	rm -f bs bs.6 bs.tar.gz *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME bs.c Makefile bs.sgml bs.lsm bs.spec

bs-$(VERSION).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(VERSION).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(VERSION)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERSION)*.src.rpm .


blob
mark :75
data 469
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.4
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.4.tar.gz
Copyright: BSD-like
Group: Games
%description
The classic game of Battleships agains the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs

commit refs/tags/2.4
mark :76
author Eric S. Raymond <esr@thyrsus.com> 1026340819 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1026340819 +0000
data 17
SGML conversion.
from :73
M 100644 :74 Makefile
M 100644 :75 bs.spec

blob
mark :77
data 1201
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
VERSION=2.4

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6:
	docbook2man bs.sgml

clean:
	rm -f bs bs.6 bs.tar.gz manpage.links manpage.refs *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME bs.c Makefile bs.sgml bs.lsm bs.spec

bs-$(VERSION).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(VERSION).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(VERSION)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERSION)*.src.rpm .


commit refs/tags/2.4
mark :78
author Eric S. Raymond <esr@thyrsus.com> 1026399261 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1026399261 +0000
data 30
Improve the clean production.
from :76
M 100644 :77 Makefile

blob
mark :79
data 2828
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>bs</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.tuxedo.org/~esr/'>http://www.tuxedo.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>


commit refs/tags/2.4
mark :80
author Eric S. Raymond <esr@thyrsus.com> 1026405057 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1026405057 +0000
data 9
URL fix.
from :78
M 100644 :79 bs.xml

blob
mark :81
data 1196
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
VERSION=2.4

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME bs.c Makefile bs.xml bs.lsm bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(VERSION).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(VERSION)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERSION)*.src.rpm .


blob
mark :82
data 1543
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write curses games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

					Eric S. Raymond
					esr@snark.thyrsus.com
				(WWW: http://www.tuxedo.org/~esr/home.html)

blob
mark :83
data 2864
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>bs</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.tuxedo.org/~esr/'>http://www.tuxedo.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>


commit refs/tags/2.4
mark :84
author Eric S. Raymond <esr@thyrsus.com> 1027852699 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1027852699 +0000
data 16
Convert to XML.
from :80
M 100644 :81 Makefile
M 100644 :82 README
M 100644 :83 bs.xml

blob
mark :85
data 2908
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>bs</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.tuxedo.org/~esr/'>http://www.tuxedo.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>


commit refs/tags/2.4
mark :86
author Eric S. Raymond <esr@thyrsus.com> 1027972539 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1027972539 +0000
data 14
Added header.
from :84
M 100644 :85 bs.xml

blob
mark :87
data 1204
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
VERSION=2.4

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME COPYING bs.c Makefile bs.xml bs.lsm bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(VERSION).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(VERSION)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERSION)*.src.rpm .


commit refs/tags/2.4
mark :88
author Eric S. Raymond <esr@thyrsus.com> 1028033943 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1028033943 +0000
data 18
Placed under GPL.
from :86
M 100644 :87 Makefile

blob
mark :89
data 464
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.4
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.4.tar.gz
Copyright: GPL
Group: Games
%description
The classic game of Battleships agains the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs

commit refs/tags/2.4
mark :90
author Eric S. Raymond <esr@thyrsus.com> 1028034161 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1028034161 +0000
data 7
GPLed.
from :88
M 100644 :89 bs.spec

blob
mark :91
data 468
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.4
Release: 1
Source: http://www.tuxedo.org/~esr/bs-2.4.tar.gz
Copyright: GPL
Group: Games
%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs

commit refs/tags/2.4
mark :92
author Eric S. Raymond <esr@thyrsus.com> 1028037467 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1028037467 +0000
data 13
Corrections.
from :90
M 100644 :91 bs.spec

blob
mark :93
data 489
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.4
Release: 1
Source: http://www.tuxedo.org/~esr/bs-2.4.tar.gz
Copyright: GPL
Group: Games
%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs
%doc READ.ME COPYING

commit refs/tags/2.4
mark :94
author Eric S. Raymond <esr@thyrsus.com> 1028037509 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1028037509 +0000
data 13
Corrections.
from :92
M 100644 :93 bs.spec

blob
mark :95
data 506
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.4
Release: 1
URL: http://www.tuxedo.org/~esr/
Source0: %{name}-%{version}.tar.gz
License: GPL
Group: Games
%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs
%doc READ.ME COPYING

commit refs/tags/2.5
mark :96
author Eric S. Raymond <esr@thyrsus.com> 1028184038 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1028184038 +0000
data 22
Copyright -> License.
from :94
M 100644 :95 bs.spec

blob
mark :97
data 1006
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change the RPM spec file
VERSION=2.5

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME COPYING bs.c Makefile bs.xml bs.lsm bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
rpm: dist
	rpmbuild -ta bs-$(VERS).tar.gz
	cp $(RPMROOT)/RPMS/*/bs-$(VERS)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERS)*.src.rpm .


blob
mark :98
data 1541
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write curses games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

					Eric S. Raymond
					esr@snark.thyrsus.com
				(WWW: http://www.catb.org/~esr/home.html)

blob
mark :99
data 28560
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 *
 * $Id: bs.c,v 1.9 2001/05/07 20:27:59 esr Exp esr $
 */

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <unistd.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#define	EXIT_SUCCESS	0
#define EXIT_FAILURE	1

static int getcoord(int);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	(isupper(c) ? TRUE : FALSE)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;			/* name of the ship type */
    int hits;			/* how many times has this ship been hit? */
    char symbol;		/* symbol for game purposes */
    int length;			/* length of ship */
    char x, y;			/* coordinates of ship start point */
    unsigned char dir;		/* direction of `bow' */
    bool placed;		/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

static ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

static ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH];
static char board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(int sig GCC_UNUSED)
/* end the game, either normally or due to signal */
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(EXIT_FAILURE);
}

static void announceopts(void)
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro(void)
{
    char *tmpname;

    srand((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

#ifdef NCURSES_MOUSE_VERSION
    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
#endif /* NCURSES_MOUSE_VERSION*/
}		    

/* VARARGS1 */
static void prompt(int n, NCURSES_CONST char *f, const char *s)
/* print a message at the prompt line */
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(NCURSES_CONST char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(int n)
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(int b, ship_t *ss)
/* generate a valid random ship placement into px,py */
{

    do {
	ss->dir = rnd(2) ? E : S;
	ss->x = rnd(BWIDTH - (ss->dir == E ? ss->length : 0));
	ss->y = rnd(BDEPTH - (ss->dir == S ? ss->length : 0));
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;

	ss = plyship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...", "");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...", "");
    (void) getch();
}

static int getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
#ifdef NCURSES_MOUSE_VERSION
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		{
		    beep();
		    continue;
		}
	    }
	    /* no fall through */
#endif /* NCURSES_MOUSE_VERSION */

	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static bool collidecheck(int b, int y, int x)
/* is this location on the selected zboard adjacent to a ship? */
{
    bool collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != FALSE)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend)
	     && IS_SHIP(board[b][xend][yend])) {
		collide = TRUE;
		break;
	    }
	}
    }
    return(collide);
}

static bool checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + (ss->length - 1) * xincr[ss->dir];
    yend = ss->y + (ss->length - 1) * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(FALSE);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(int x, int y)
/* register a hit on the targeted ship */
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if((sym = board[OTHER][x][y]) == 0)
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;
			    
			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y1, x1);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
				else
				{
				  pgoto(y1, x1);
				  (void)addch(SHOWSPLASH);
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		    else
		    {
		      pgoto(y1, x1);
#ifdef A_COLOR
		      if (has_colors())
			attron(COLOR_PAIR(COLOR_RED));
#endif /* A_COLOR */
		      (void)addch(SHOWHIT);
#ifdef A_COLOR
		      attrset(0);
#endif /* A_COLOR */
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn(void)
{
    ship_t *ss;
    bool hit;
    NCURSES_CONST char *m = NULL;

    prompt(1, "Where do you want to shoot? ", "");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.", "");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = (hit ? MARK_HIT : MARK_MISS);
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return (hit);
}

static int sgetc(const char *s)
{
    const char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(int *px, int *py)
/* random-fire routine -- implements simple diagonal-striping strategy */
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(EXIT_FAILURE);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static int cpufire(int x, int y)
/* fire away at given location */
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))) != 0)
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return ((hit ? (sunk ? S_SUNK : S_HIT) : S_MISS) ? TRUE : FALSE);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn(void)
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n;
    int hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return ((hit) ? TRUE : FALSE);
}

static
int playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(int c, char *op[])
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(EXIT_FAILURE);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(EXIT_FAILURE);
		}
	    }
	}
    }
}

static int scount(int who)
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int main(int argc, char *argv[])
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    /*NOTREACHED*/
}

/* bs.c ends here */

blob
mark :100
data 912
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: %{myversion}
Release: 1
URL: http://www.tuxedo.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: GPL
Group: Games
%undefine __check_files

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs
%doc READ.ME COPYING

%changelog
* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.

commit refs/tags/2.5
mark :101
author Eric S. Raymond <esr@thyrsus.com> 1072301668 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1072301668 +0000
data 23
Ready for 2.5 release.
from :96
M 100644 :97 Makefile
M 100644 :98 README
M 100644 :99 bs.c
M 100644 :100 bs.spec

blob
mark :102
data 892
#	Makefile for bs, the Battleships game

VERSION=2.5

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME COPYING bs.c Makefile bs.xml bs.lsm bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
rpm: dist
	rpmbuild --define 'myversion $(VERS)' -ta bs-$(VERS).tar.gz
	cp $(RPMROOT)/RPMS/*/bs-$(VERS)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERS)*.src.rpm .


commit refs/tags/2.5
mark :103
author Eric S. Raymond <esr@thyrsus.com> 1072301762 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1072301762 +0000
data 47
Get the spec version number from the makefile.
from :101
M 100644 :102 Makefile

blob
mark :104
data 885
#	Makefile for bs, the Battleships game

VERSION=2.5

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME COPYING bs.c Makefile bs.xml bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
rpm: dist
	rpmbuild --define 'myversion $(VERS)' -ta bs-$(VERS).tar.gz
	cp $(RPMROOT)/RPMS/*/bs-$(VERS)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERS)*.src.rpm .


commit refs/tags/2.5
mark :105
author Eric S. Raymond <esr@thyrsus.com> 1072301830 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1072301830 +0000
data 24
LSM no longer a source.
from :103
M 100644 :104 Makefile

blob
mark :106
data 910
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: %{myversion}
Release: 1
URL: http://www.catb.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: GPL
Group: Games
%undefine __check_files

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs
%doc READ.ME COPYING

%changelog
* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.

commit refs/tags/2.5
mark :107
author Eric S. Raymond <esr@thyrsus.com> 1072460119 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1072460119 +0000
data 14
Lock for 2.5.
from :105
M 100644 :106 bs.spec

blob
mark :108
data 885
#	Makefile for bs, the Battleships game

VERSION=2.6

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME COPYING bs.c Makefile bs.xml bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
rpm: dist
	rpmbuild --define 'myversion $(VERS)' -ta bs-$(VERS).tar.gz
	cp $(RPMROOT)/RPMS/*/bs-$(VERS)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERS)*.src.rpm .


blob
mark :109
data 1017
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: %{myversion}
Release: 1
URL: http://www.catb.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: GPL
Group: Games
%undefine __check_files

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs
%doc READ.ME COPYING

%changelog
* Fri Dec 26 2003 Eric S. Raymond <esr@snark.thyrsus.com> d2.6
- Fix a broken URL in the documentation

* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.5
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.

blob
mark :110
data 2904
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>bs</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.catb.org/~esr/'>http://www.catb.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>


commit refs/tags/2.6
mark :111
author Eric S. Raymond <esr@thyrsus.com> 1072460640 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1072460640 +0000
data 26
Version bump and cleanup.
from :107
M 100644 :108 Makefile
M 100644 :109 bs.spec
M 100644 :110 bs.xml

blob
mark :112
data 897
#	Makefile for bs, the Battleships game

VERSION=2.6

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME COPYING bs.c Makefile bs.xml bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
rpm: dist
	rpmbuild --define 'myversion $(VERSION)' -ta bs-$(VERSION).tar.gz
	cp $(RPMROOT)/RPMS/*/bs-$(VERSION)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERSION)*.src.rpm .


commit refs/tags/2.6
mark :113
author Eric S. Raymond <esr@thyrsus.com> 1072460719 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1072460719 +0000
data 20
Fix RPM production.
from :111
M 100644 :112 Makefile

blob
mark :114
data 805
#	Makefile for bs, the Battleships game

VERSION=$(shell sed <bs.spec -n -e '/Version: \(.*\)/s//\1/p')

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# DESTDIR support
DESTDIR = 

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs $(DESTDIR)/usr/bin
	cp bs.6 $(DESTDIR)/usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = README COPYING bs.c Makefile bs.xml bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

blob
mark :115
data 1532
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write curses games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

					Eric S. Raymond
					esr@snark.thyrsus.com
				(WWW: http://www.catb.org/~esr/)

blob
mark :116
data 1474
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.7
Release: 1
URL: http://www.catb.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: GPL
Group: Games
BuildRoot: %{_tmppath}/%{name}-root

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
[ ! -z "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
mkdir -p "$RPM_BUILD_ROOT"/usr/bin
mkdir -p "$RPM_BUILD_ROOT"/usr/share/man/man6/
cp bs "$RPM_BUILD_ROOT"/usr/bin
cp bs.6 "$RPM_BUILD_ROOT"/usr/share/man/man6/

%clean
[ ! -z "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
%files
%defattr(-,root,root,-)
%{_mandir}/man6/bs.6*
%{_bindir}/bs
%doc README COPYING

%changelog
* Mon Dec 29 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.7-1
- Source RPMS no longer depend on myversion define.

* Fri Dec 26 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.6
- Fix a broken URL in the documentation

* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.5
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.

commit refs/tags/2.7
mark :117
author Eric S. Raymond <esr@thyrsus.com> 1072682153 +0000
committer Eric S. Raymond <esr@thyrsus.com> 1072682153 +0000
data 21
RPM packaging fixes.
from :113
M 100644 :114 Makefile
M 100644 :115 README
M 100644 :116 bs.spec

blob
mark :118
data 17992
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year  name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.

commit refs/tags/2.8
mark :119
author Eric S. Raymond <esr@thyrsus.com> 1286928454 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1286928454 -0400
data 32
Belatedly check in the license.
from :117
M 100644 :118 COPYING

blob
mark :120
data 28545
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 */

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdbool.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#define	EXIT_SUCCESS	0
#define EXIT_FAILURE	1

static int getcoord(int);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	(isupper(c) ? TRUE : FALSE)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;			/* name of the ship type */
    int hits;			/* how many times has this ship been hit? */
    char symbol;		/* symbol for game purposes */
    int length;			/* length of ship */
    char x, y;			/* coordinates of ship start point */
    unsigned char dir;		/* direction of `bow' */
    bool placed;		/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

static ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

static ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH];
static char board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static bool salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(int sig GCC_UNUSED)
/* end the game, either normally or due to signal */
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(EXIT_FAILURE);
}

static void announceopts(void)
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro(void)
{
    char *tmpname;

    srand((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

#ifdef NCURSES_MOUSE_VERSION
    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
#endif /* NCURSES_MOUSE_VERSION*/
}		    

/* VARARGS1 */
static void prompt(int n, NCURSES_CONST char *f, const char *s)
/* print a message at the prompt line */
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(NCURSES_CONST char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(int n)
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(int b, ship_t *ss)
/* generate a valid random ship placement into px,py */
{

    do {
	ss->dir = rnd(2) ? E : S;
	ss->x = rnd(BWIDTH - (ss->dir == E ? ss->length : 0));
	ss->y = rnd(BDEPTH - (ss->dir == S ? ss->length : 0));
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;

	ss = plyship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...", "");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...", "");
    (void) getch();
}

static int getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
#ifdef NCURSES_MOUSE_VERSION
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		{
		    beep();
		    continue;
		}
	    }
	    /* no fall through */
#endif /* NCURSES_MOUSE_VERSION */

	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static bool collidecheck(int b, int y, int x)
/* is this location on the selected zboard adjacent to a ship? */
{
    bool collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != FALSE)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend)
	     && IS_SHIP(board[b][xend][yend])) {
		collide = TRUE;
		break;
	    }
	}
    }
    return(collide);
}

static bool checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + (ss->length - 1) * xincr[ss->dir];
    yend = ss->y + (ss->length - 1) * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(FALSE);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(int x, int y)
/* register a hit on the targeted ship */
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if((sym = board[OTHER][x][y]) == 0)
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;
			    
			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y1, x1);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
				else
				{
				  pgoto(y1, x1);
				  (void)addch(SHOWSPLASH);
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		    else
		    {
		      pgoto(y1, x1);
#ifdef A_COLOR
		      if (has_colors())
			attron(COLOR_PAIR(COLOR_RED));
#endif /* A_COLOR */
		      (void)addch(SHOWHIT);
#ifdef A_COLOR
		      attrset(0);
#endif /* A_COLOR */
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn(void)
{
    ship_t *ss;
    bool hit;
    NCURSES_CONST char *m = NULL;

    prompt(1, "Where do you want to shoot? ", "");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.", "");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = (hit ? MARK_HIT : MARK_MISS);
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return (hit);
}

static int sgetc(const char *s)
{
    const char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(int *px, int *py)
/* random-fire routine -- implements simple diagonal-striping strategy */
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(EXIT_FAILURE);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static int cpufire(int x, int y)
/* fire away at given location */
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))) != 0)
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return ((hit ? (sunk ? S_SUNK : S_HIT) : S_MISS) ? TRUE : FALSE);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn(void)
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n;
    int hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return ((hit) ? TRUE : FALSE);
}

static
int playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(int c, char *op[])
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(EXIT_FAILURE);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = true;
		    if (salvo)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 's':
		    salvo = true;
		    if (blitz)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 'c':
		    closepack = true;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(EXIT_FAILURE);
		}
	    }
	}
    }
}

static int scount(int who)
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int main(int argc, char *argv[])
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    /*NOTREACHED*/
}

/* bs.c ends here */

commit refs/tags/2.8
mark :121
author Eric S. Raymond <esr@thyrsus.com> 1287483557 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287483557 -0400
data 22
Use bools and stdlib.
from :119
M 100644 :120 bs.c

blob
mark :122
data 17
bs
*~
*.html
*.6

commit refs/tags/2.8
mark :123
author Eric S. Raymond <esr@thyrsus.com> 1287483855 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287483855 -0400
data 29
Ignore some generated stuff.
from :121
M 100644 :122 .gitignore

blob
mark :124
data 1623
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.8
Release: 1
URL: http://www.catb.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: GPL
Group: Games
BuildRoot: %{_tmppath}/%{name}-root
#Project-Tag-List: battleships, game, solitaire

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make %{?_smp_mflags} bs bs.6

%install
[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
mkdir -p "$RPM_BUILD_ROOT"%{_bindir}
mkdir -p "$RPM_BUILD_ROOT"%{_mandir}/man6/
cp bs "$RPM_BUILD_ROOT"%{_bindir}
cp bs.6 "$RPM_BUILD_ROOT"%{_mandir}/man6/

%clean
[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
%files
%defattr(-,root,root,-)
%{_mandir}/man6/bs.6*
%{_bindir}/bs
%doc README COPYING

%changelog
* Tue Oct 19 2010 Eric S. Raymond <esr@snark.thyrsus.com> 2.8-1
- Port to modern C.

* Mon Dec 29 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.7-1
- Source RPMS no longer depend on --define myversion.

* Fri Dec 26 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.6-1
- Fix a broken URL in the documentation

* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.5-1
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.

commit refs/tags/2.8
mark :125
author Eric S. Raymond <esr@thyrsus.com> 1287484006 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287484006 -0400
data 20
Update the history.
from :123
M 100644 :124 bs.spec

blob
mark :126
data 26
bs
*~
*.html
*.6
MANIFEST

commit refs/tags/2.8
mark :127
author Eric S. Raymond <esr@thyrsus.com> 1287484075 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287484075 -0400
data 17
Ignore MANIFEST.
from :125
M 100644 :126 .gitignore

blob
mark :128
data 892
#	Makefile for bs, the Battleships game

VERSION=$(shell sed <bs.spec -n -e '/Version: \(.*\)/s//\1/p')

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# DESTDIR support
DESTDIR = 

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~ *.html SHIPPER.*

install: bs.6 uninstall
	cp bs $(DESTDIR)/usr/bin
	cp bs.6 $(DESTDIR)/usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = README COPYING bs.c Makefile bs.xml bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

release: bs-$(VERSION).tar.gz bs.html
	shipper -u -m -t; make clean


commit refs/tags/2.8
mark :129
author Eric S. Raymond <esr@thyrsus.com> 1287484172 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287484172 -0400
data 33
Adapt for new shipper machinery.
from :127
M 100644 :128 Makefile

blob
mark :130
data 3047
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>bs</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
<refmiscinfo class='manual'>Games</refmiscinfo>
<refmiscinfo class='source'>bs</refmiscinfo>
<refmiscinfo class='productname'>bs</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.catb.org/~esr/'>http://www.catb.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>


commit refs/tags/2.8
mark :131
author Eric S. Raymond <esr@thyrsus.com> 1287484335 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287484335 -0400
data 32
Suppress some warning messages.
from :129
M 100644 :130 bs.xml

blob
mark :132
data 1421
			BSD LICENSE

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

Neither name of the this project nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

blob
mark :133
data 936
#	Makefile for bs, the Battleships game

VERSION=$(shell sed <bs.spec -n -e '/Version: \(.*\)/s//\1/p')

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# DESTDIR support
DESTDIR = 

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml
bs.html: bs.xml
	xmlto html-nochunks bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~ *.html SHIPPER.*

install: bs.6 uninstall
	cp bs $(DESTDIR)/usr/bin
	cp bs.6 $(DESTDIR)/usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = README COPYING bs.c Makefile bs.xml bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

release: bs-$(VERSION).tar.gz bs.html
	shipper -u -m -t; make clean


blob
mark :134
data 1623
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.9
Release: 1
URL: http://www.catb.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: BSD
Group: Games
BuildRoot: %{_tmppath}/%{name}-root
#Project-Tag-List: battleships, game, solitaire

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make %{?_smp_mflags} bs bs.6

%install
[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
mkdir -p "$RPM_BUILD_ROOT"%{_bindir}
mkdir -p "$RPM_BUILD_ROOT"%{_mandir}/man6/
cp bs "$RPM_BUILD_ROOT"%{_bindir}
cp bs.6 "$RPM_BUILD_ROOT"%{_mandir}/man6/

%clean
[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
%files
%defattr(-,root,root,-)
%{_mandir}/man6/bs.6*
%{_bindir}/bs
%doc README COPYING

%changelog
* Tue Oct 19 2010 Eric S. Raymond <esr@snark.thyrsus.com> 2.8-1
- Port to modern C.

* Mon Dec 29 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.7-1
- Source RPMS no longer depend on --define myversion.

* Fri Dec 26 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.6-1
- Fix a broken URL in the documentation

* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.5-1
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.

commit refs/heads/master
mark :135
author Eric S. Raymond <esr@thyrsus.com> 1287486771 -0400
committer Eric S. Raymond <esr@thyrsus.com> 1287486771 -0400
data 23
Change license to BSD.
from :131
M 100644 :132 COPYING
M 100644 :133 Makefile
M 100644 :134 bs.spec

blob
mark :136
data 1648
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.9
Release: 1
URL: http://www.catb.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: BSD
Group: Games
BuildRoot: %{_tmppath}/%{name}-root
#Destinations: freshmeat
#Project-Tag-List: battleships, game, solitaire

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make %{?_smp_mflags} bs bs.6

%install
[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
mkdir -p "$RPM_BUILD_ROOT"%{_bindir}
mkdir -p "$RPM_BUILD_ROOT"%{_mandir}/man6/
cp bs "$RPM_BUILD_ROOT"%{_bindir}
cp bs.6 "$RPM_BUILD_ROOT"%{_mandir}/man6/

%clean
[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
%files
%defattr(-,root,root,-)
%{_mandir}/man6/bs.6*
%{_bindir}/bs
%doc README COPYING

%changelog
* Tue Oct 19 2010 Eric S. Raymond <esr@snark.thyrsus.com> 2.8-1
- Port to modern C.

* Mon Dec 29 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.7-1
- Source RPMS no longer depend on --define myversion.

* Fri Dec 26 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.6-1
- Fix a broken URL in the documentation

* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.5-1
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.

commit refs/heads/master
mark :137
author Eric S. Raymond <esr@thyrsus.com> 1290997985 -0500
committer Eric S. Raymond <esr@thyrsus.com> 1290997985 -0500
data 42
Be explicit about releasing to freshmeat.
from :135
M 100644 :136 bs.spec

reset refs/heads/master
from :137

tag 2.8
from :131
tagger Eric S. Raymond <esr@thyrsus.com> 1287484438 -0400
data 32
Tagged for external release 2.8

