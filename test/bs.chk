SVN-fs-dump-format-version: 2


Revision-number: 0
Prop-content-length: 56
Content-length: 56

K 8
svn:date
V 27
PROPS-END

Revision-number: 1
Prop-content-length: 115
Content-length: 115

K 7
svn:log
V 17
Initial revision

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1993-11-15T17:25:16.000000Z
PROPS-END

Node-path: branches
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: trunk
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: trunk/Makefile
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 393
Text-content-sha1: 2eed664c74cfb63c530cda1296e1e65fed748530
Content-length: 403

PROPS-END
#	Makefile for Battleships

# Flags for use with the Linux ncurses package (recommended)
# CFLAGS = -DNDEBUG  -I/usr/local/include -L/usr/local/lib
# TERMLIB = -lncurses

# Flags for use with stock curses
CFLAGS = -DNDEBUG
TERMLIB = -lcurses

bs: bs.c
	cc $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar *~

shar:
	shar READ.ME bs.c Makefile bs.6 >bs.shar


Node-path: trunk/README
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 1341
Text-content-sha1: 4a196e3e50ca6aa29f0633071466281f76ce15c9
Content-length: 1351

PROPS-END
Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write termcap games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

						Eric S. Raymond
						esr@snark.uu.net



Node-path: trunk/bs.c
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 26995
Text-content-sha1: bdb8bd633975b0a8395001ef99c51eb756e9768a
Content-length: 27005

PROPS-END
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 */

#include <stdio.h>
#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <assert.h>

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#ifdef isxdigit		/* aha, must be an AT&T system... */
#define srand(n)	srand48(n)
#define rand()		lrand48()
extern long lrand48();
extern void srand48();
#define bzero(s, n)	(void)memset((char *)(s), '\0', n)
extern char *memset();
/*
 * Try this if ungetch() fails to resolve.
 *
 * #define ungetch ungetc
 */
#endif /* isxdigit */

extern unsigned sleep();
extern char *strchr(), *strcpy();
extern long time();
extern void exit();

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "Stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    char dir;		/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(sig)
/* end the game, either normally or due to signal */
int	sig;
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(0);
}

static void announceopts()
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro()
{
    extern char *getlogin();
    char *tmpname;

    srand(time(0L)+getpid());	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if(tmpname = getlogin())
	(void)strcpy(name,tmpname);
    else
	(void)strcpy(name,dftname);
    name[0] = toupper(name[0]);

    (void)initscr();
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

}		    

/* VARARGS1 */
static void prompt(n, f, s)
/* print a message at the prompt line */
int n;
char *f, *s;
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(s)
char *s;
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static void randomplace(b, ss)
/* generate a valid random ship placement into px,py */
int b;
ship_t *ss;
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame()
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    bzero(board, sizeof(char) * BWIDTH * BDEPTH * 2);
    bzero(hits, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	extern char *strchr();
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...");
    (void) getch();
}

static int rnd(n)
int n;
{
    return(((rand() & 0x7FFF) % n));
}

static int getcoord(atcpu)
int atcpu;
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8': ny = cury+BDEPTH-1; nx = curx;   break;
	case 'j': case '2': ny = cury+1;        nx = curx;   break;
	case 'h': case '4': ny = cury;          nx = curx+BWIDTH-1; break;
	case 'l': case '6': ny = cury;          nx = curx+1; break;
	case 'y': case '7': ny = cury+BDEPTH-1; nx = curx+BWIDTH-1; break;
	case 'b': case '1': ny = cury+1;        nx = curx+BWIDTH-1; break;
	case 'u': case '9': ny = cury+BDEPTH-1; nx = curx+1; break;
	case 'n': case '3': ny = cury+1;        nx = curx+1; break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(b, y, x)
/* is this location on the selected zboard adjacent to a ship? */
int b;
int y, x;
{
    int	collide;

    /* anything on the square */
    if (collide = IS_SHIP(board[b][x][y]))
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static int checkplace(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if(vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert! Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(0);
	    }
	}
    return(1);
}

static int awinna()
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(x, y)
/* register a hit on the targeted ship */
int x, y;
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x, y;
			    
			    x = bx + i * xincr[ss->dir];
			    y = by + i * yincr[ss->dir];
			    if (ONBOARD(x, y))
			    {
				hits[turn][x][y] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y, x);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x = ss->x + i * xincr[ss->dir];
		    int y = ss->y + i * yincr[ss->dir];

		    hits[turn][x][y] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y, x);
			(void) addch(ss->symbol);
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn()
{
    ship_t *ss;
    bool hit;
    char *m;

    prompt(1, "Where do you want to shoot? ");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(s)
char *s;
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame();
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(px, py)
/* random-fire routine -- implements simple diagonal-striping strategy */
int	*px, *py;
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(x, y)
/* fire away at given location */
int	x, y;
{
    bool hit, sunk;
    ship_t *ss;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if (sunk = (hit && (ss = hitship(x, y))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn()
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

playagain()
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(c,op)
int c;
char *op[];
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(who)
int who;
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

main(argc, argv)
int argc;
char *argv[];
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame();
    /*NOTREACHED*/
}

/* bs.c ends here */


Revision-number: 2
Prop-content-length: 122
Content-length: 122

K 7
svn:log
V 24
Checkin of manual page.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1993-11-15T17:56:52.000000Z
PROPS-END

Node-path: trunk/bs.xml
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 1816
Text-content-sha1: d6818570b7fc03d94f3e23670006f40bbebd0a44
Content-length: 1826

PROPS-END
.TH BATTLESHIPS 6 "Aug 23, 1989"
.SH NAME
bs \- battleships game
.SH SYNOPSIS
battle [ -b | -s ] [ -c ]
.SH DESCRIPTION
This program allows you to play the familiar Battleships game against the
computer on a 10x10 board. The interface is visual and largely
self-explanatory; you place your ships and pick your shots by moving the
cursor around the `sea' with the rogue/hack motion keys hjklyubn.
.PP
Note that when selecting a ship to place, you must type the capital letter
(these are, after all, capital ships). During ship placement, the `r' command
may be used to ignore the current position and randomly place your currently
selected ship. The `R' command will place all remaining ships randomly. The ^L
command (form feed, ASCII 12) will force a screen redraw).
.PP
The command-line arguments control game modes. 

.nf
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
.fi

The `blitz' variant allows a side to shoot for as long as it continues to
score hits.
.PP
The `salvo' game allows a player one shot per turn for each of his/her ships
still afloat.  This puts a premium scoring hits early and knocking out some
ships and also makes much harder the situation where you face a superior force
with only your PT-boat.
.PP
Normally, ships must be separated by at least one square of open water. The
-c option disables this check and allows them to close-pack.
.PP
The algorithm the computer uses once it has found a ship to sink is provably
optimal. The dispersion criterion for the random-fire algorithm may not be.
.SH AUTHORS
Originally written by one Bruce Holloway in 1986. Salvo mode added by Chuck A.
DeGaul (cbosgd!cad). Visual user interface, `closepack' option, code rewrite
and manual page by Eric S. Raymond <esr@snark.thyrsus.com> August 1989.


Revision-number: 3
Prop-content-length: 117
Content-length: 117

K 7
svn:log
V 19
Froze 2.0 release.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1993-11-15T18:01:23.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 429
Text-content-sha1: f18dbed61a47c66723b4d266d966a08898fee859
Content-length: 439

PROPS-END
#	Makefile for bs, the Battleships game

# Flags for use with the Linux ncurses package (recommended)
# CFLAGS = -DNDEBUG  -I/usr/local/include -L/usr/local/lib
# TERMLIB = -lncurses
# CC = gcc

# Flags for use with stock curses
CFLAGS = -DNDEBUG
TERMLIB = -lcurses
CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar *~

shar:
	shar READ.ME bs.c Makefile bs.6 >bs.shar


Node-path: trunk/README
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1499
Text-content-sha1: 8cd4cfcbc8c7be597c9048c31350324df161090d
Content-length: 1509

PROPS-END
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write termcap games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

						Eric S. Raymond
						esr@snark.thyrsus.com



Node-path: trunk/bs.c
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 27718
Text-content-sha1: fb79786830dae27e86f7e7ed622b6c02693d4c6f
Content-length: 27728

PROPS-END
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 */
#define _POSIX_SOURCE

#include <stdio.h>
#include <termios.h>
#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <assert.h>

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#ifdef isxdigit		/* aha, must be an AT&T system... */
#define srand(n)	srand48(n)
#define rand()		lrand48()
extern long lrand48();
extern void srand48();
#define bzero(s, n)	(void)memset((char *)(s), '\0', n)
extern char *memset();
/*
 * Try this if ungetch() fails to resolve.
 *
 * #define ungetch ungetc
 */
#endif /* isxdigit */

extern unsigned sleep();
extern char *strchr(), *strcpy();
extern long time();
extern void exit();

static bool checkplace();

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    char dir;		/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(sig)
/* end the game, either normally or due to signal */
int	sig;
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(0);
}

static void announceopts()
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro()
{
    extern char *getlogin();
    char *tmpname;

    srand(time(0L)+getpid());	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if(tmpname = getlogin())
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

}		    

/* VARARGS1 */
static void prompt(n, f, s)
/* print a message at the prompt line */
int n;
char *f, *s;
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(s)
char *s;
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(n)
int n;
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(b, ss)
/* generate a valid random ship placement into px,py */
int b;
ship_t *ss;
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame()
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    bzero(board, sizeof(char) * BWIDTH * BDEPTH * 2);
    bzero(hits, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	extern char *strchr();
	static char getcoord();
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...");
    (void) getch();
}

static int getcoord(atcpu)
int atcpu;
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(b, y, x)
/* is this location on the selected zboard adjacent to a ship? */
int b;
int y, x;
{
    int	collide;

    /* anything on the square */
    if (collide = IS_SHIP(board[b][x][y]))
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool checkplace(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna()
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(x, y)
/* register a hit on the targeted ship */
int x, y;
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x, y;
			    
			    x = bx + i * xincr[ss->dir];
			    y = by + i * yincr[ss->dir];
			    if (ONBOARD(x, y))
			    {
				hits[turn][x][y] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y, x);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x = ss->x + i * xincr[ss->dir];
		    int y = ss->y + i * yincr[ss->dir];

		    hits[turn][x][y] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y, x);
			(void) addch(ss->symbol);
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn()
{
    ship_t *ss;
    bool hit;
    char *m;

    prompt(1, "Where do you want to shoot? ");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(s)
char *s;
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame();
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(px, py)
/* random-fire routine -- implements simple diagonal-striping strategy */
int	*px, *py;
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(x, y)
/* fire away at given location */
int	x, y;
{
    bool hit, sunk;
    ship_t *ss;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if (sunk = (hit && (ss = hitship(x, y))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn()
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

playagain()
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(c,op)
int c;
char *op[];
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(who)
int who;
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

main(argc, argv)
int argc;
char *argv[];
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame();
    /*NOTREACHED*/
}

/* bs.c ends here */


Node-path: trunk/bs.xml
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1952
Text-content-sha1: 3ebfa0494feaba4ae1053262ce9e2d63f62904f1
Content-length: 1962

PROPS-END
.TH BATTLESHIPS 6 "Nov 15 1993"
.SH NAME
bs \- battleships game
.SH SYNOPSIS
battle [ -b | -s ] [ -c ]
.SH DESCRIPTION
This program allows you to play the familiar Battleships game against the
computer on a 10x10 board. The interface is visual and largely
self-explanatory; you place your ships and pick your shots by moving the
cursor around the `sea' with the rogue/hack motion keys hjklyubn.  If
your UNIX has a modern (non-BSD) curses, your arrow keys will also work.
.PP
Note that when selecting a ship to place, you must type the capital letter
(these are, after all, capital ships). During ship placement, the `r' command
may be used to ignore the current position and randomly place your currently
selected ship. The `R' command will place all remaining ships randomly. The ^L
command (form feed, ASCII 12) will force a screen redraw).
.PP
The command-line arguments control game modes. 

.nf
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
.fi

The `blitz' variant allows a side to shoot for as long as it continues to
score hits.
.PP
The `salvo' game allows a player one shot per turn for each of his/her ships
still afloat.  This puts a premium scoring hits early and knocking out some
ships and also makes much harder the situation where you face a superior force
with only your PT-boat.
.PP
Normally, ships must be separated by at least one square of open water. The
-c option disables this check and allows them to close-pack.
.PP
The algorithm the computer uses once it has found a ship to sink is provably
optimal.  The dispersion criterion for the random-fire algorithm may not be.
.SH AUTHORS
Originally written by one Bruce Holloway in 1986. Salvo mode added by Chuck A.
DeGaul (cbosgd!cad). Visual user interface, `closepack' option, code rewrite
and manual page by Eric S. Raymond <esr@snark.thyrsus.com> August
1989.  Keypad support and ANSI/POSIX conformance, November '93.



Revision-number: 4
Prop-content-length: 80
Content-length: 80

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1993-11-15T18:01:23.000000Z
PROPS-END

Node-path: tags
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: tags/2.0
Node-kind: dir
Node-action: add
Node-copyfrom-rev: 3
Node-copyfrom-path: trunk/
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 5
Prop-content-length: 108
Content-length: 108

K 7
svn:log
V 10
Fix typo.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1994-10-23T20:12:32.000000Z
PROPS-END

Node-path: trunk/bs.xml
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1948
Text-content-sha1: fe3330b9e5b15f1714a024a30c5e2ac214aba6fc
Content-length: 1958

PROPS-END
.TH BATTLESHIPS 6 "Nov 15 1993"
.SH NAME
bs \- battleships game
.SH SYNOPSIS
bs [ -b | -s ] [ -c ]
.SH DESCRIPTION
This program allows you to play the familiar Battleships game against the
computer on a 10x10 board. The interface is visual and largely
self-explanatory; you place your ships and pick your shots by moving the
cursor around the `sea' with the rogue/hack motion keys hjklyubn.  If
your UNIX has a modern (non-BSD) curses, your arrow keys will also work.
.PP
Note that when selecting a ship to place, you must type the capital letter
(these are, after all, capital ships). During ship placement, the `r' command
may be used to ignore the current position and randomly place your currently
selected ship. The `R' command will place all remaining ships randomly. The ^L
command (form feed, ASCII 12) will force a screen redraw).
.PP
The command-line arguments control game modes. 

.nf
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
.fi

The `blitz' variant allows a side to shoot for as long as it continues to
score hits.
.PP
The `salvo' game allows a player one shot per turn for each of his/her ships
still afloat.  This puts a premium scoring hits early and knocking out some
ships and also makes much harder the situation where you face a superior force
with only your PT-boat.
.PP
Normally, ships must be separated by at least one square of open water. The
-c option disables this check and allows them to close-pack.
.PP
The algorithm the computer uses once it has found a ship to sink is provably
optimal.  The dispersion criterion for the random-fire algorithm may not be.
.SH AUTHORS
Originally written by one Bruce Holloway in 1986. Salvo mode added by Chuck A.
DeGaul (cbosgd!cad). Visual user interface, `closepack' option, code rewrite
and manual page by Eric S. Raymond <esr@snark.thyrsus.com> August
1989.  Keypad support and ANSI/POSIX conformance, November '93.



Revision-number: 6
Prop-content-length: 116
Content-length: 116

K 7
svn:log
V 18
Freeze for Linux.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1994-10-23T20:26:27.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 429
Text-content-sha1: e4abe823ee812e297a8f5ee6ac2d335dd08db76e
Content-length: 439

PROPS-END
#	Makefile for bs, the Battleships game

# Flags for use with the Linux ncurses package (recommended)
CFLAGS = -DNDEBUG  -I/usr/local/include -L/usr/local/lib
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# CFLAGS = -DNDEBUG
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar *~

shar:
	shar READ.ME bs.c Makefile bs.6 >bs.shar


Node-path: trunk/bs.c
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 27798
Text-content-sha1: f89f1db37930e8fbe2c0653b2f8b00de38c5df63
Content-length: 27808

PROPS-END
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 for Linux, October 1994.
 */
#define _POSIX_SOURCE

#include <stdio.h>
#include <termios.h>
#include <ncurses.h>	/* change this to curses.h if not on Linux */
#include <signal.h>
#include <ctype.h>
#include <assert.h>

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#ifdef isxdigit		/* aha, must be an AT&T system... */
#define srand(n)	srand48(n)
#define rand()		lrand48()
extern long lrand48();
extern void srand48();
#define bzero(s, n)	(void)memset((char *)(s), '\0', n)
extern char *memset();
/*
 * Try this if ungetch() fails to resolve.
 *
 * #define ungetch ungetc
 */
#endif /* isxdigit */

extern unsigned sleep();
extern char *strchr(), *strcpy();
extern long time();
extern void exit();

static bool checkplace();

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    char dir;		/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(sig)
/* end the game, either normally or due to signal */
int	sig;
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(0);
}

static void announceopts()
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro()
{
    extern char *getlogin();
    char *tmpname;

    srand(time(0L)+getpid());	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if(tmpname = getlogin())
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

}		    

/* VARARGS1 */
static void prompt(n, f, s)
/* print a message at the prompt line */
int n;
char *f, *s;
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(s)
char *s;
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(n)
int n;
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(b, ss)
/* generate a valid random ship placement into px,py */
int b;
ship_t *ss;
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame()
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    bzero(board, sizeof(char) * BWIDTH * BDEPTH * 2);
    bzero(hits, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	extern char *strchr();
	static char getcoord();
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...");
    (void) getch();
}

static int getcoord(atcpu)
int atcpu;
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(b, y, x)
/* is this location on the selected zboard adjacent to a ship? */
int b;
int y, x;
{
    int	collide;

    /* anything on the square */
    if (collide = IS_SHIP(board[b][x][y]))
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool checkplace(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna()
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(x, y)
/* register a hit on the targeted ship */
int x, y;
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x, y;
			    
			    x = bx + i * xincr[ss->dir];
			    y = by + i * yincr[ss->dir];
			    if (ONBOARD(x, y))
			    {
				hits[turn][x][y] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y, x);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x = ss->x + i * xincr[ss->dir];
		    int y = ss->y + i * yincr[ss->dir];

		    hits[turn][x][y] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y, x);
			(void) addch(ss->symbol);
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn()
{
    ship_t *ss;
    bool hit;
    char *m;

    prompt(1, "Where do you want to shoot? ");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(s)
char *s;
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame();
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(px, py)
/* random-fire routine -- implements simple diagonal-striping strategy */
int	*px, *py;
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(x, y)
/* fire away at given location */
int	x, y;
{
    bool hit, sunk;
    ship_t *ss;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if (sunk = (hit && (ss = hitship(x, y))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn()
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

playagain()
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(c,op)
int c;
char *op[];
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(who)
int who;
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

main(argc, argv)
int argc;
char *argv[];
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame();
    /*NOTREACHED*/
}

/* bs.c ends here */


Revision-number: 7
Prop-content-length: 122
Content-length: 122

K 7
svn:log
V 24
Better ncurses support.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1994-10-24T20:35:56.000000Z
PROPS-END

Node-path: trunk/bs.c
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 27808
Text-content-sha1: fcd59c2f3287a3931203cdab74d6bb26b8cefaac
Content-length: 27818

PROPS-END
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 for Linux, October 1994.
 */
#define _POSIX_SOURCE

#include <stdio.h>
#include <termios.h>
#ifdef NCURSES
#include <ncurses.h>
#else
#include <curses.h>
#endif NCURSES
#include <signal.h>
#include <ctype.h>
#include <assert.h>

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#ifdef isxdigit		/* aha, must be an AT&T system... */
#define srand(n)	srand48(n)
#define rand()		lrand48()
extern long lrand48();
extern void srand48();
#define bzero(s, n)	(void)memset((char *)(s), '\0', n)
extern char *memset();
/*
 * Try this if ungetch() fails to resolve.
 *
 * #define ungetch ungetc
 */
#endif /* isxdigit */

extern unsigned sleep();
extern char *strchr(), *strcpy();
extern long time();
extern void exit();

static bool checkplace();

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    char dir;		/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(sig)
/* end the game, either normally or due to signal */
int	sig;
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(0);
}

static void announceopts()
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro()
{
    extern char *getlogin();
    char *tmpname;

    srand(time(0L)+getpid());	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if(tmpname = getlogin())
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

}		    

/* VARARGS1 */
static void prompt(n, f, s)
/* print a message at the prompt line */
int n;
char *f, *s;
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(s)
char *s;
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(n)
int n;
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(b, ss)
/* generate a valid random ship placement into px,py */
int b;
ship_t *ss;
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame()
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    bzero(board, sizeof(char) * BWIDTH * BDEPTH * 2);
    bzero(hits, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	extern char *strchr();
	static char getcoord();
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...");
    (void) getch();
}

static int getcoord(atcpu)
int atcpu;
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(b, y, x)
/* is this location on the selected zboard adjacent to a ship? */
int b;
int y, x;
{
    int	collide;

    /* anything on the square */
    if (collide = IS_SHIP(board[b][x][y]))
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool checkplace(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna()
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(x, y)
/* register a hit on the targeted ship */
int x, y;
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x, y;
			    
			    x = bx + i * xincr[ss->dir];
			    y = by + i * yincr[ss->dir];
			    if (ONBOARD(x, y))
			    {
				hits[turn][x][y] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y, x);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x = ss->x + i * xincr[ss->dir];
		    int y = ss->y + i * yincr[ss->dir];

		    hits[turn][x][y] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y, x);
			(void) addch(ss->symbol);
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn()
{
    ship_t *ss;
    bool hit;
    char *m;

    prompt(1, "Where do you want to shoot? ");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(s)
char *s;
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame();
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(px, py)
/* random-fire routine -- implements simple diagonal-striping strategy */
int	*px, *py;
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(x, y)
/* fire away at given location */
int	x, y;
{
    bool hit, sunk;
    ship_t *ss;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if (sunk = (hit && (ss = hitship(x, y))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn()
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

playagain()
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(c,op)
int c;
char *op[];
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(who)
int who;
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

main(argc, argv)
int argc;
char *argv[];
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame();
    /*NOTREACHED*/
}

/* bs.c ends here */


Revision-number: 8
Prop-content-length: 130
Content-length: 130

K 7
svn:log
V 32
Better distribution production.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1994-10-24T20:51:08.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 503
Text-content-sha1: 5648b3b51b954a25266176e72ca7382f5e26202d
Content-length: 513

PROPS-END
#	Makefile for bs, the Battleships game

# Flags for use with the Linux ncurses package (recommended)
CFLAGS = -DNCURSES  -I/usr/local/include -L/usr/local/lib
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# CFLAGS =
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

bs.shar:
	shar READ.ME bs.c Makefile bs.6 >bs.shar

bs.tar.gz:
	tar -cvf bs.tar READ.ME bs.c Makefile bs.6
	gzip bs.tar


Revision-number: 9
Prop-content-length: 119
Content-length: 119

K 7
svn:log
V 21
Added WWW home page.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1994-11-21T20:47:41.000000Z
PROPS-END

Node-path: trunk/README
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1543
Text-content-sha1: 49c034ad2ba9c3f2869bb75ee2466e7a5681e936
Content-length: 1553

PROPS-END
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write termcap games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

						Eric S. Raymond
						esr@snark.thyrsus.com
					(WWW: //www.thyrsus.com/~esr/home.html)


Node-path: trunk/bs.xml
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 2064
Text-content-sha1: 5d2140b79627ec7781cfe0bd1e0753d7446985f1
Content-length: 2074

PROPS-END
.TH BATTLESHIPS 6 "Nov 15 1993"
.SH NAME
bs \- battleships game
.SH SYNOPSIS
bs [ -b | -s ] [ -c ]
.SH DESCRIPTION
This program allows you to play the familiar Battleships game against the
computer on a 10x10 board. The interface is visual and largely
self-explanatory; you place your ships and pick your shots by moving the
cursor around the `sea' with the rogue/hack motion keys hjklyubn.  If
your UNIX has a modern (non-BSD) curses, your arrow keys will also work.
.PP
Note that when selecting a ship to place, you must type the capital letter
(these are, after all, capital ships). During ship placement, the `r' command
may be used to ignore the current position and randomly place your currently
selected ship. The `R' command will place all remaining ships randomly. The ^L
command (form feed, ASCII 12) will force a screen redraw).
.PP
The command-line arguments control game modes. 

.nf
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
.fi

The `blitz' variant allows a side to shoot for as long as it continues to
score hits.
.PP
The `salvo' game allows a player one shot per turn for each of his/her ships
still afloat.  This puts a premium scoring hits early and knocking out some
ships and also makes much harder the situation where you face a superior force
with only your PT-boat.
.PP
Normally, ships must be separated by at least one square of open water. The
-c option disables this check and allows them to close-pack.
.PP
The algorithm the computer uses once it has found a ship to sink is provably
optimal.  The dispersion criterion for the random-fire algorithm may not be.
.SH AUTHORS
Originally written by one Bruce Holloway in 1986. Salvo mode added by Chuck A.
DeGaul (cbosgd!cad). Visual user interface, `closepack' option, code rewrite
and manual page by Eric S. Raymond <esr@snark.thyrsus.com> August
1989.  Keypad support and ANSI/POSIX conformance, November '93.  See
http://www.thyrsus.com/~esr/home.html for the latest version of bs,
also other software and resources by ESR.




Revision-number: 10
Prop-content-length: 119
Content-length: 119

K 7
svn:log
V 21
Added WWW home page.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1994-11-21T21:03:34.000000Z
PROPS-END

Node-path: trunk/README
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1545
Text-content-sha1: 38643aedfe7647510e9ff550af0d50df1afa4fb8
Content-length: 1555

PROPS-END
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write termcap games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

					Eric S. Raymond
					esr@snark.thyrsus.com
				(WWW: http://www.thyrsus.com/~esr/home.html)


Node-path: trunk/bs.xml
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 2047
Text-content-sha1: bef43379a492df07a15f1b1502b19b7bed514cda
Content-length: 2057

PROPS-END
.TH BATTLESHIPS 6 "Nov 15 1993"
.SH NAME
bs \- battleships game
.SH SYNOPSIS
bs [ -b | -s ] [ -c ]
.SH DESCRIPTION
This program allows you to play the familiar Battleships game against the
computer on a 10x10 board. The interface is visual and largely
self-explanatory; you place your ships and pick your shots by moving the
cursor around the `sea' with the rogue/hack motion keys hjklyubn.  If
your UNIX has a modern (non-BSD) curses, your arrow keys will also work.
.PP
Note that when selecting a ship to place, you must type the capital letter
(these are, after all, capital ships). During ship placement, the `r' command
may be used to ignore the current position and randomly place your currently
selected ship. The `R' command will place all remaining ships randomly. The ^L
command (form feed, ASCII 12) will force a screen redraw).
.PP
The command-line arguments control game modes. 

.nf
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
.fi

The `blitz' variant allows a side to shoot for as long as it continues to
score hits.
.PP
The `salvo' game allows a player one shot per turn for each of his/her ships
still afloat.  This puts a premium scoring hits early and knocking out some
ships and also makes much harder the situation where you face a superior force
with only your PT-boat.
.PP
Normally, ships must be separated by at least one square of open water. The
-c option disables this check and allows them to close-pack.
.PP
The algorithm the computer uses once it has found a ship to sink is provably
optimal.  The dispersion criterion for the random-fire algorithm may not be.
.SH AUTHORS
Originally written by one Bruce Holloway in 1986. Salvo mode added by Chuck A.
DeGaul (cbosgd!cad). Visual user interface, `closepack' option, code rewrite
and manual page by Eric S. Raymond <esr@snark.thyrsus.com> August
1989.  Keypad support and ANSI/POSIX conformance, November '93.  See
http://www.thyrsus.com/~esr/home.html for updates,
also other software and resources by ESR.




Revision-number: 11
Prop-content-length: 117
Content-length: 117

K 7
svn:log
V 19
gcc -Wall changes.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-05-07T03:23:46.000000Z
PROPS-END

Node-path: trunk/bs.c
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 27977
Text-content-sha1: fc0982d33b36662c84b2edb5f2f9c682d48896f2
Content-length: 27987

PROPS-END
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 for Linux, October 1994.
 * Slipstreamed in fixes to make it gcc -Wall clean, May '95.
 */
#define _POSIX_SOURCE

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#ifdef isxdigit		/* aha, must be an AT&T system... */

#if !defined(__386BSD__) && !defined(__bsdi__)
#define srand(n)	srand48(n)
#define rand()		lrand48()
extern long lrand48();
extern void srand48();
#endif

#define bzero(s, n)	(void)memset((char *)(s), '\0', n)
extern char *memset();
/*
 * Try this if ungetch() fails to resolve.
 *
 * #define ungetch ungetc
 */
#endif /* isxdigit */

extern unsigned sleep();
extern char *strchr(), *strcpy();
extern long time();
extern void exit();

static bool checkplace();

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    unsigned char dir;	/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(sig)
/* end the game, either normally or due to signal */
int	sig;
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(0);
}

static void announceopts()
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro()
{
    extern char *getlogin();
    char *tmpname;

    srand(time(0L)+getpid());	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

}		    

/* VARARGS1 */
static void prompt(n, f, s)
/* print a message at the prompt line */
int n;
char *f, *s;
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(s)
char *s;
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(n)
int n;
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(b, ss)
/* generate a valid random ship placement into px,py */
int b;
ship_t *ss;
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame()
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    bzero(board, sizeof(char) * BWIDTH * BDEPTH * 2);
    bzero(hits, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, i + 'A');
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch(i + 'A');
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	extern char *strchr();
	static char getcoord();
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...");
    (void) getch();
}

static int getcoord(atcpu)
int atcpu;
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(b, y, x)
/* is this location on the selected zboard adjacent to a ship? */
int b;
int y, x;
{
    int	collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != 0)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool checkplace(b, ss, vis)
int b;
ship_t *ss;
int vis;
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna()
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(x, y)
/* register a hit on the targeted ship */
int x, y;
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x, y;
			    
			    x = bx + i * xincr[ss->dir];
			    y = by + i * yincr[ss->dir];
			    if (ONBOARD(x, y))
			    {
				hits[turn][x][y] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y, x);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x = ss->x + i * xincr[ss->dir];
		    int y = ss->y + i * yincr[ss->dir];

		    hits[turn][x][y] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y, x);
			(void) addch(ss->symbol);
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn()
{
    ship_t *ss;
    bool hit;
    char *m = NULL;

    prompt(1, "Where do you want to shoot? ");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(s)
char *s;
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame();
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(px, py)
/* random-fire routine -- implements simple diagonal-striping strategy */
int	*px, *py;
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(x, y)
/* fire away at given location */
int	x, y;
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn()
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

int playagain()
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(c,op)
int c;
char *op[];
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(who)
int who;
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

main(argc, argv)
int argc;
char *argv[];
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame();
    /*NOTREACHED*/
}

/* bs.c ends here */


Revision-number: 12
Prop-content-length: 111
Content-length: 111

K 7
svn:log
V 13
Added bs.lsm

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-05-07T04:04:30.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 510
Text-content-sha1: 58b0d0ad0e06cfa998bcffa89d12db9e41e565c3
Content-length: 520

PROPS-END
#	Makefile for bs, the Battleships game

# Flags for use with the Linux ncurses package (recommended)
CFLAGS = -DNCURSES  -I/usr/local/include -L/usr/local/lib
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# CFLAGS =
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

bs.shar:
	shar READ.ME bs.c Makefile bs.6 >bs.shar

bs.tar.gz:
	tar -cvf bs.tar READ.ME bs.c Makefile bs.6 bs.lsm
	gzip bs.tar


Revision-number: 13
Prop-content-length: 131
Content-length: 131

K 7
svn:log
V 33
Corrected my home page location.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-05-08T01:37:29.000000Z
PROPS-END

Node-path: trunk/README
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1542
Text-content-sha1: 8dfedd176caaf136b4445ab7b3299777095ac47a
Content-length: 1552

PROPS-END
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write termcap games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

					Eric S. Raymond
					esr@snark.thyrsus.com
				(WWW: http://www.ccil.org/~esr/home.html)


Node-path: trunk/bs.xml
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 2044
Text-content-sha1: 0a4acf2f68539722422359bc768b393197556057
Content-length: 2054

PROPS-END
.TH BATTLESHIPS 6 "Nov 15 1993"
.SH NAME
bs \- battleships game
.SH SYNOPSIS
bs [ -b | -s ] [ -c ]
.SH DESCRIPTION
This program allows you to play the familiar Battleships game against the
computer on a 10x10 board. The interface is visual and largely
self-explanatory; you place your ships and pick your shots by moving the
cursor around the `sea' with the rogue/hack motion keys hjklyubn.  If
your UNIX has a modern (non-BSD) curses, your arrow keys will also work.
.PP
Note that when selecting a ship to place, you must type the capital letter
(these are, after all, capital ships). During ship placement, the `r' command
may be used to ignore the current position and randomly place your currently
selected ship. The `R' command will place all remaining ships randomly. The ^L
command (form feed, ASCII 12) will force a screen redraw).
.PP
The command-line arguments control game modes. 

.nf
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
.fi

The `blitz' variant allows a side to shoot for as long as it continues to
score hits.
.PP
The `salvo' game allows a player one shot per turn for each of his/her ships
still afloat.  This puts a premium scoring hits early and knocking out some
ships and also makes much harder the situation where you face a superior force
with only your PT-boat.
.PP
Normally, ships must be separated by at least one square of open water. The
-c option disables this check and allows them to close-pack.
.PP
The algorithm the computer uses once it has found a ship to sink is provably
optimal.  The dispersion criterion for the random-fire algorithm may not be.
.SH AUTHORS
Originally written by one Bruce Holloway in 1986. Salvo mode added by Chuck A.
DeGaul (cbosgd!cad). Visual user interface, `closepack' option, code rewrite
and manual page by Eric S. Raymond <esr@snark.thyrsus.com> August
1989.  Keypad support and ANSI/POSIX conformance, November '93.  See
http://www.ccil.org/~esr/home.html for updates,
also other software and resources by ESR.




Revision-number: 14
Prop-content-length: 153
Content-length: 153

K 7
svn:log
V 55
This matches the 2.1 that went out with ncurses-1.9.5.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-09-18T03:01:30.000000Z
PROPS-END

Node-path: trunk/bs.c
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 28087
Text-content-sha1: 74bd499fcb0c1a33fb55184e8a8116953e0f3e2a
Content-length: 28097

PROPS-END
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 */
#define _POSIX_SOURCE

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>
#include <time.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

static int getcoord(int);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    unsigned char dir;	/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(int sig)
/* end the game, either normally or due to signal */
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(sig);
}

static void announceopts(void)
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro(void)
{
    extern char *getlogin(void);
    char *tmpname;

    srand((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

#ifdef NCURSES_MOUSE_VERSION
    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
#endif /* NCURSES_MOUSE_VERSION*/
}		    

/* VARARGS1 */
static void prompt(int n, char *f, char *s)
/* print a message at the prompt line */
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(int n)
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(int b, ship_t *ss)
/* generate a valid random ship placement into px,py */
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...", "");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...", "");
    (void) getch();
}

static int getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
#ifdef NCURSES_MOUSE_VERSION
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		    beep();
	    }
	    break;
#endif /* NCURSES_MOUSE_VERSION */
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(int b, int y, int x)
/* is this location on the selected zboard adjacent to a ship? */
{
    int	collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != 0)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(int x, int y)
/* register a hit on the targeted ship */
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;
			    
			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y1, x1);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn(void)
{
    ship_t *ss;
    bool hit;
    char *m = NULL;

    prompt(1, "Where do you want to shoot? ", "");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.", "");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(char *s)
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(int *px, int *py)
/* random-fire routine -- implements simple diagonal-striping strategy */
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(int x, int y)
/* fire away at given location */
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn(void)
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

static
int playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(int c, char *op[])
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(int who)
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int main(int argc, char *argv[])
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    /*NOTREACHED*/
}

/* bs.c ends here */


Revision-number: 15
Prop-content-length: 80
Content-length: 80

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-09-18T03:01:30.000000Z
PROPS-END

Node-path: tags/2.1
Node-kind: dir
Node-action: add
Node-copyfrom-rev: 14
Node-copyfrom-path: trunk/
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 16
Prop-content-length: 114
Content-length: 114

K 7
svn:log
V 16
Comment change.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-12-06T03:42:08.000000Z
PROPS-END

Node-path: trunk/README
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1541
Text-content-sha1: 6966e0f3d117ca3ca03bb1bf35411edd5a127a48
Content-length: 1551

PROPS-END
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write curses games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

					Eric S. Raymond
					esr@snark.thyrsus.com
				(WWW: http://www.ccil.org/~esr/home.html)


Revision-number: 17
Prop-content-length: 115
Content-length: 115

K 7
svn:log
V 17
Initial revision

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-12-06T03:57:44.000000Z
PROPS-END

Node-path: trunk/bs.spec
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 311
Text-content-sha1: 44ad596e314a15846c61226afa381d2b308791ee
Content-length: 321

PROPS-END
Description: Battleships against the computer (text mode)
Name: bs
Version: 2.1
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.1.tar.gz
Copyright: BSD-like
Group: Games

%prep
%setup

%build
make

%install
rm -f /usr/bin/bs
cp bs /usr/bin
cp bs.6 /usr/man/man1/bs.6

%files
%doc /usr/man/man1/bs.6
/usr/bin/bs


Revision-number: 18
Prop-content-length: 119
Content-length: 119

K 7
svn:log
V 21
Made this RPM-ready.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-12-06T03:58:08.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 764
Text-content-sha1: d4d4148e5a82cdc05340592dc0ffe747b7105fc1
Content-length: 774

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.1

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs.tar.gz:
	(cd ..; tar -cvf bs-$(V)/bs.tar `echo $(SOURCES) | sed "/ /s// bs-$(V)\//g"`)
	gzip bs.tar

rpm: bs.tar.gz
	cp bs.tar.gz /usr/src/SOURCES/bs-$(V).tar.gz
	cp bs.spec /usr/src/SPECS/bs-$(V)-1.spec
	rpm -ba bs-$(V)-1.spec


Revision-number: 19
Prop-content-length: 127
Content-length: 127

K 7
svn:log
V 29
Fix the initial-file glitch.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-12-06T04:16:05.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 771
Text-content-sha1: 7d9df91e26f4e791ac11d504ec9ad00db1d51cc7
Content-length: 781

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.1

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs.tar.gz:
	(cd ..; tar -cvf bs-$(V)/bs.tar `echo $(SOURCES) | sed "/\(^\| \)/s// bs-$(V)\//g"`)
	gzip bs.tar

rpm: bs.tar.gz
	cp bs.tar.gz /usr/src/SOURCES/bs-$(V).tar.gz
	cp bs.spec /usr/src/SPECS/bs-$(V)-1.spec
	rpm -ba bs-$(V)-1.spec


Revision-number: 20
Prop-content-length: 121
Content-length: 121

K 7
svn:log
V 23
Add -f option to gzip.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-12-06T04:20:00.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 782
Text-content-sha1: c96ebae584a1d7ca36d4d3fc4ff5bc48d8aa7b07
Content-length: 792

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.1

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs.tar:
	(cd ..; tar -cvf bs-$(V)/bs.tar `echo $(SOURCES) | sed "/\(^\| \)/s// bs-$(V)\//g"`)
bs.tar.gz:
	gzip -f bs.tar

rpm: bs.tar.gz
	cp bs.tar.gz /usr/src/SOURCES/bs-$(V).tar.gz
	cp bs.spec /usr/src/SPECS/bs-$(V)-1.spec
	rpm -ba bs-$(V)-1.spec


Revision-number: 21
Prop-content-length: 114
Content-length: 114

K 7
svn:log
V 16
%doc corrected.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-12-06T13:11:40.000000Z
PROPS-END

Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 306
Text-content-sha1: 88bb06eca9fa1271780a9fdda23f98662cd9b912
Content-length: 316

PROPS-END
Description: Battleships against the computer (text mode)
Name: bs
Version: 2.1
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.1.tar.gz
Copyright: BSD-like
Group: Games

%prep
%setup

%build
make

%install
rm -f /usr/bin/bs
cp bs /usr/bin
cp bs.6 /usr/man/man1/bs.6

%files
/usr/man/man1/bs.6
/usr/bin/bs


Revision-number: 22
Prop-content-length: 121
Content-length: 121

K 7
svn:log
V 23
Corrected man section.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-12-06T13:51:50.000000Z
PROPS-END

Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 306
Text-content-sha1: b9b74ba3957611cec7b14f093bf76be95cb79591
Content-length: 316

PROPS-END
Description: Battleships against the computer (text mode)
Name: bs
Version: 2.1
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.1.tar.gz
Copyright: BSD-like
Group: Games

%prep
%setup

%build
make

%install
rm -f /usr/bin/bs
cp bs /usr/bin
cp bs.6 /usr/man/man6/bs.6

%files
/usr/man/man6/bs.6
/usr/bin/bs


Revision-number: 23
Prop-content-length: 105
Content-length: 105

K 7
svn:log
V 8
Nailed.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1995-12-07T23:06:02.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 789
Text-content-sha1: 777e4f99b2870327c7c8a22331bec5d89e133ea0
Content-length: 799

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.1

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs.tar:
	(cd ..; tar -cvf bs-$(V)/bs.tar `echo $(SOURCES) | sed "/\(^\| \)/s// bs-$(V)\//g"`)
bs.tar.gz: bs.tar
	gzip -f bs.tar

rpm: bs.tar.gz
	cp bs.tar.gz /usr/src/SOURCES/bs-$(V).tar.gz
	cp bs.spec /usr/src/SPECS/bs-$(V)-1.spec
	rpm -ba bs-$(V)-1.spec


Revision-number: 24
Prop-content-length: 130
Content-length: 130

K 7
svn:log
V 32
Slipstream this minor change...

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1996-05-09T02:14:19.000000Z
PROPS-END

Node-path: trunk/bs.c
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 28084
Text-content-sha1: 1eef00d6e97822ee2f7ccd9fea8f657536b1416d
Content-length: 28094

PROPS-END
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 */
#define _POSIX_SOURCE

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>
#include <time.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

static int getcoord(int);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	isupper(c)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;		/* name of the ship type */
    unsigned hits;	/* how many times has this ship been hit? */
    char symbol;	/* symbol for game purposes */
    char length;	/* length of ship */
    char x, y;		/* coordinates of ship start point */
    unsigned char dir;	/* direction of `bow' */
    bool placed;	/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH], board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(int sig)
/* end the game, either normally or due to signal */
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(sig);
}

static void announceopts(void)
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro(void)
{
    extern char *getlogin(void);
    char *tmpname;

    srand((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

#ifdef NCURSES_MOUSE_VERSION
    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
#endif /* NCURSES_MOUSE_VERSION*/
}		    

/* VARARGS1 */
static void prompt(int n, char *f, char *s)
/* print a message at the prompt line */
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(int n)
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(int b, ship_t *ss)
/* generate a valid random ship placement into px,py */
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
	ss = plyship + i;
	ss->x = ss->y = ss->dir = ss->hits = ss->placed = 0;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...", "");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...", "");
    (void) getch();
}

static int getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
#ifdef NCURSES_MOUSE_VERSION
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		    beep();
	    }
	    break;
#endif /* NCURSES_MOUSE_VERSION */
	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static int collidecheck(int b, int y, int x)
/* is this location on the selected zboard adjacent to a ship? */
{
    int	collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != 0)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend))
		collide += IS_SHIP(board[b][xend][yend]);
	}
    }
    return(collide);
}

static bool checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(0);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(int x, int y)
/* register a hit on the targeted ship */
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if(!(sym = board[OTHER][x][y]))
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;
			    
			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y1, x1);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn(void)
{
    ship_t *ss;
    bool hit;
    char *m = NULL;

    prompt(1, "Where do you want to shoot? ", "");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.", "");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = hit ? MARK_HIT : MARK_MISS;
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return(hit);
}

static int sgetc(char *s)
{
    char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(int *px, int *py)
/* random-fire routine -- implements simple diagonal-striping strategy */
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(1);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static bool cpufire(int x, int y)
/* fire away at given location */
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))))
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return(hit ? (sunk ? S_SUNK : S_HIT) : S_MISS);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn(void)
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n, hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return(hit);
}

static
int playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(int c, char *op[])
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(1);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(1);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(1);
		}
	    }
	}
    }
}

static int scount(int who)
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int main(int argc, char *argv[])
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    /*NOTREACHED*/
}

/* bs.c ends here */


Revision-number: 25
Prop-content-length: 112
Content-length: 112

K 7
svn:log
V 14
Code cleanup.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1998-08-14T03:53:19.000000Z
PROPS-END

Node-path: trunk/bs.c
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 28473
Text-content-sha1: 34f73535e3900feb67a3380dcf54ff80da6d269e
Content-length: 28483

PROPS-END
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 *
 * $Id: bs.c,v 1.22 1997/12/20 15:11:53 tom Exp $
 */

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <unistd.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#define	EXIT_SUCCESS	0
#define EXIT_FAILURE	1

static int getcoord(int);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	(isupper(c) ? TRUE : FALSE)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;			/* name of the ship type */
    int hits;			/* how many times has this ship been hit? */
    char symbol;		/* symbol for game purposes */
    int length;			/* length of ship */
    char x, y;			/* coordinates of ship start point */
    unsigned char dir;		/* direction of `bow' */
    bool placed;		/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

static ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

static ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH];
static char board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(int sig GCC_UNUSED)
/* end the game, either normally or due to signal */
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(EXIT_FAILURE);
}

static void announceopts(void)
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro(void)
{
    char *tmpname;

    srand((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

#ifdef NCURSES_MOUSE_VERSION
    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
#endif /* NCURSES_MOUSE_VERSION*/
}		    

/* VARARGS1 */
static void prompt(int n, NCURSES_CONST char *f, const char *s)
/* print a message at the prompt line */
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(NCURSES_CONST char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(int n)
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(int b, ship_t *ss)
/* generate a valid random ship placement into px,py */
{
    register int bwidth = BWIDTH - ss->length;
    register int bdepth = BDEPTH - ss->length;

    do {
	ss->y = rnd(bdepth);
	ss->x = rnd(bwidth);
	ss->dir = rnd(2) ? E : S;
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;

	ss = plyship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...", "");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...", "");
    (void) getch();
}

static int getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
#ifdef NCURSES_MOUSE_VERSION
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		{
		    beep();
		    continue;
		}
	    }
	    /* no fall through */
#endif /* NCURSES_MOUSE_VERSION */

	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static bool collidecheck(int b, int y, int x)
/* is this location on the selected zboard adjacent to a ship? */
{
    bool collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != FALSE)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend)
	     && IS_SHIP(board[b][xend][yend])) {
		collide = TRUE;
		break;
	    }
	}
    }
    return(collide);
}

static bool checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + ss->length * xincr[ss->dir];
    yend = ss->y + ss->length * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(FALSE);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(int x, int y)
/* register a hit on the targeted ship */
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if((sym = board[OTHER][x][y]) == 0)
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;
			    
			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y1, x1);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn(void)
{
    ship_t *ss;
    bool hit;
    NCURSES_CONST char *m = NULL;

    prompt(1, "Where do you want to shoot? ", "");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.", "");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = (hit ? MARK_HIT : MARK_MISS);
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return (hit);
}

static int sgetc(const char *s)
{
    const char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(int *px, int *py)
/* random-fire routine -- implements simple diagonal-striping strategy */
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(EXIT_FAILURE);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static int cpufire(int x, int y)
/* fire away at given location */
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))) != 0)
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return ((hit ? (sunk ? S_SUNK : S_HIT) : S_MISS) ? TRUE : FALSE);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn(void)
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n;
    int hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return ((hit) ? TRUE : FALSE);
}

static
int playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(int c, char *op[])
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(EXIT_FAILURE);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(EXIT_FAILURE);
		}
	    }
	}
    }
}

static int scount(int who)
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int main(int argc, char *argv[])
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    /*NOTREACHED*/
}

/* bs.c ends here */


Revision-number: 26
Prop-content-length: 106
Content-length: 106

K 7
svn:log
V 9
Updated.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1998-08-14T04:00:14.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 759
Text-content-sha1: ab12712e6bdd9afaaf755e626f3693961b55b49f
Content-length: 769

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.2

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs-$(V).tar.gz:
	tar --name-prefix='bs-$(V)/' -czf bs-$(V).tar.gz $(SOURCES)

tgz: bs-$(V).tar.gz

rpm: bs.tar.gz
	cp bs.tar.gz /usr/src/SOURCES/bs-$(V).tar.gz
	cp bs.spec /usr/src/SPECS/bs-$(V)-1.spec
	rpm -ba bs-$(V)-1.spec


Revision-number: 27
Prop-content-length: 80
Content-length: 80

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1998-08-14T04:00:14.000000Z
PROPS-END

Node-path: tags/2.2
Node-kind: dir
Node-action: add
Node-copyfrom-rev: 26
Node-copyfrom-path: trunk/
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 28
Prop-content-length: 118
Content-length: 118

K 7
svn:log
V 20
We can do RPMs now.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
1998-12-21T03:54:24.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1018
Text-content-sha1: 0afdec12553072716b09b92e15be16993c6f9292
Content-length: 1028

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.2

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs-$(V).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:bs-$(V)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(V))
	(cd ..; tar -czvf bs/bs-$(V).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(V))

dist: bs-$(V).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(V).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(V)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(V)*.src.rpm .



Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 510
Text-content-sha1: 2ff4db1fa9839c23d844d2644048054d7ad853d2
Content-length: 520

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.2
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.2.tar.gz
Copyright: BSD-like
Group: Games
%description
The classic game of Battleships agains the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
rm -f /usr/bin/bs
cp bs /usr/bin
cp bs.6 /usr/man/man6/bs.6

%files
/usr/man/man6/bs.6
/usr/bin/bs


Revision-number: 29
Prop-content-length: 124
Content-length: 124

K 7
svn:log
V 26
Bug fixes by  Eric Sigra.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2001-05-07T20:27:59.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1018
Text-content-sha1: 34f5192364dcebbd63852c7f57a02eebf70f917b
Content-length: 1028

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
V=2.3

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs-$(V).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:bs-$(V)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(V))
	(cd ..; tar -czvf bs/bs-$(V).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(V))

dist: bs-$(V).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(V).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(V)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(V)*.src.rpm .



Node-path: trunk/bs.c
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 28800
Text-content-sha1: 66b2ddf4bc6deb0d7ca1654f35c76d5611bfe6c6
Content-length: 28810

PROPS-END
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 *
 * $Id: bs.c,v 1.8 1998/08/14 03:53:19 esr Exp esr $
 */

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <unistd.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#define	EXIT_SUCCESS	0
#define EXIT_FAILURE	1

static int getcoord(int);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	(isupper(c) ? TRUE : FALSE)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;			/* name of the ship type */
    int hits;			/* how many times has this ship been hit? */
    char symbol;		/* symbol for game purposes */
    int length;			/* length of ship */
    char x, y;			/* coordinates of ship start point */
    unsigned char dir;		/* direction of `bow' */
    bool placed;		/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

static ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

static ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH];
static char board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(int sig GCC_UNUSED)
/* end the game, either normally or due to signal */
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(EXIT_FAILURE);
}

static void announceopts(void)
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro(void)
{
    char *tmpname;

    srand((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

#ifdef NCURSES_MOUSE_VERSION
    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
#endif /* NCURSES_MOUSE_VERSION*/
}		    

/* VARARGS1 */
static void prompt(int n, NCURSES_CONST char *f, const char *s)
/* print a message at the prompt line */
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(NCURSES_CONST char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(int n)
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(int b, ship_t *ss)
/* generate a valid random ship placement into px,py */
{

    do {
	ss->dir = rnd(2) ? E : S;
	ss->x = rnd(BWIDTH - (ss->dir == E ? ss->length : 0));
	ss->y = rnd(BDEPTH - (ss->dir == S ? ss->length : 0));
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;

	ss = plyship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...", "");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...", "");
    (void) getch();
}

static int getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
#ifdef NCURSES_MOUSE_VERSION
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		{
		    beep();
		    continue;
		}
	    }
	    /* no fall through */
#endif /* NCURSES_MOUSE_VERSION */

	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static bool collidecheck(int b, int y, int x)
/* is this location on the selected zboard adjacent to a ship? */
{
    bool collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != FALSE)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend)
	     && IS_SHIP(board[b][xend][yend])) {
		collide = TRUE;
		break;
	    }
	}
    }
    return(collide);
}

static bool checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + (ss->length - 1) * xincr[ss->dir];
    yend = ss->y + (ss->length - 1) * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(FALSE);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(int x, int y)
/* register a hit on the targeted ship */
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if((sym = board[OTHER][x][y]) == 0)
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;
			    
			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y1, x1);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
				else
				{
				  pgoto(y1, x1);
				  (void)addch(SHOWSPLASH);
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		    else
		    {
		      pgoto(y1, x1);
#ifdef A_COLOR
		      if (has_colors())
			attron(COLOR_PAIR(COLOR_RED));
#endif /* A_COLOR */
		      (void)addch(SHOWHIT);
#ifdef A_COLOR
		      attrset(0);
#endif /* A_COLOR */
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn(void)
{
    ship_t *ss;
    bool hit;
    NCURSES_CONST char *m = NULL;

    prompt(1, "Where do you want to shoot? ", "");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.", "");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = (hit ? MARK_HIT : MARK_MISS);
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return (hit);
}

static int sgetc(const char *s)
{
    const char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(int *px, int *py)
/* random-fire routine -- implements simple diagonal-striping strategy */
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(EXIT_FAILURE);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static int cpufire(int x, int y)
/* fire away at given location */
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))) != 0)
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return ((hit ? (sunk ? S_SUNK : S_HIT) : S_MISS) ? TRUE : FALSE);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn(void)
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n;
    int hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return ((hit) ? TRUE : FALSE);
}

static
int playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(int c, char *op[])
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(EXIT_FAILURE);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(EXIT_FAILURE);
		}
	    }
	}
    }
}

static int scount(int who)
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int main(int argc, char *argv[])
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    /*NOTREACHED*/
}

/* bs.c ends here */


Revision-number: 30
Prop-content-length: 129
Content-length: 129

K 7
svn:log
V 31
Version bump for 2.3 release. 

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2001-05-11T13:26:40.000000Z
PROPS-END

Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 510
Text-content-sha1: 1b218d30c482a1882a1fad593a7f74d0e9a9971e
Content-length: 520

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.3
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.3.tar.gz
Copyright: BSD-like
Group: Games
%description
The classic game of Battleships agains the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
rm -f /usr/bin/bs
cp bs /usr/bin
cp bs.6 /usr/man/man6/bs.6

%files
/usr/man/man6/bs.6
/usr/bin/bs


Revision-number: 31
Prop-content-length: 129
Content-length: 129

K 7
svn:log
V 31
Fix up man directory location.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2001-05-11T13:27:52.000000Z
PROPS-END

Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 522
Text-content-sha1: d9e2d9262b1cd0cee901af54447d3c64960eea08
Content-length: 532

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.3
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.3.tar.gz
Copyright: BSD-like
Group: Games
%description
The classic game of Battleships agains the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
rm -f /usr/bin/bs
cp bs /usr/bin
cp bs.6 /usr/share/man/man6/bs.6

%files
/usr/share/man/man6/bs.6
/usr/bin/bs


Revision-number: 32
Prop-content-length: 80
Content-length: 80

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2001-05-11T13:27:52.000000Z
PROPS-END

Node-path: tags/2.3
Node-kind: dir
Node-action: add
Node-copyfrom-rev: 31
Node-copyfrom-path: trunk/
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 33
Prop-content-length: 117
Content-length: 117

K 7
svn:log
V 19
Fix version macro.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2001-05-11T13:29:21.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1078
Text-content-sha1: aa950ef1c86dbbf6716a9d4631b241f0aff7d80c
Content-length: 1088

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
VERSION=2.3

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

lint:
	lint bs.c -lcurses

clean:
	rm -f bs bs.shar bs.tar.gz *~

SOURCES = READ.ME bs.c Makefile bs.6 bs.lsm bs.spec

bs.shar:
	shar $(SOURCES) >bs.shar

bs-$(VERSION).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(VERSION).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(VERSION)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERSION)*.src.rpm .



Revision-number: 34
Prop-content-length: 117
Content-length: 117

K 7
svn:log
V 19
First cut at SGML.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-07-10T22:30:56.000000Z
PROPS-END

Node-path: trunk/bs.xml
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 2833
Text-content-sha1: f8117425f27acab125c976c644e98c07dbc43119
Content-length: 2843

PROPS-END
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>BATTLESHIPS</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.ccil.org/~esr/'>http://www.ccil.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>



Revision-number: 35
Prop-content-length: 121
Content-length: 121

K 7
svn:log
V 23
Make the right target.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-07-10T22:34:23.000000Z
PROPS-END

Node-path: trunk/bs.xml
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 2824
Text-content-sha1: 601df909042b323428a7dd7b2dc3280849da71bc
Content-length: 2834

PROPS-END
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>bs</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.ccil.org/~esr/'>http://www.ccil.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>



Revision-number: 36
Prop-content-length: 115
Content-length: 115

K 7
svn:log
V 17
SGML conversion.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-07-10T22:40:19.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1174
Text-content-sha1: 312dfbd57a46fa720c5a67116f120efa891e8ca7
Content-length: 1184

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
VERSION=2.4

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6:
	docbook2man bs.sgml

clean:
	rm -f bs bs.6 bs.tar.gz *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME bs.c Makefile bs.sgml bs.lsm bs.spec

bs-$(VERSION).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(VERSION).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(VERSION)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERSION)*.src.rpm .



Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 469
Text-content-sha1: 685696cf7aef873fbe36779736c12c5ba75c5250
Content-length: 479

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.4
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.4.tar.gz
Copyright: BSD-like
Group: Games
%description
The classic game of Battleships agains the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs


Revision-number: 37
Prop-content-length: 128
Content-length: 128

K 7
svn:log
V 30
Improve the clean production.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-07-11T14:54:21.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1201
Text-content-sha1: 18d3caf55e330b9ce4c827c07fc44cfb3cf3dcd7
Content-length: 1211

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
VERSION=2.4

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6:
	docbook2man bs.sgml

clean:
	rm -f bs bs.6 bs.tar.gz manpage.links manpage.refs *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME bs.c Makefile bs.sgml bs.lsm bs.spec

bs-$(VERSION).tar.gz: $(SOURCES)
	@ls $(SOURCES) | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(VERSION).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(VERSION)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERSION)*.src.rpm .



Revision-number: 38
Prop-content-length: 106
Content-length: 106

K 7
svn:log
V 9
URL fix.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-07-11T16:30:57.000000Z
PROPS-END

Node-path: trunk/bs.xml
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 2828
Text-content-sha1: aa611133744cf0f9a1b2614e8cfda07a696f65c6
Content-length: 2838

PROPS-END
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>bs</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.tuxedo.org/~esr/'>http://www.tuxedo.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>



Revision-number: 39
Prop-content-length: 114
Content-length: 114

K 7
svn:log
V 16
Convert to XML.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-07-28T10:38:19.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1196
Text-content-sha1: cab30baa56a92cbe75c0faf6ca5abad08f3f838a
Content-length: 1206

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
VERSION=2.4

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME bs.c Makefile bs.xml bs.lsm bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(VERSION).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(VERSION)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERSION)*.src.rpm .



Node-path: trunk/README
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1543
Text-content-sha1: 18f01463dd4ae020919adc0dafb768b670e0f96b
Content-length: 1553

PROPS-END
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write curses games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

					Eric S. Raymond
					esr@snark.thyrsus.com
				(WWW: http://www.tuxedo.org/~esr/home.html)


Node-path: trunk/bs.xml
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 2864
Text-content-sha1: 522d7cc3e12fdb386d9ef0bd5f90b3c74a00a9ac
Content-length: 2874

PROPS-END
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>bs</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.tuxedo.org/~esr/'>http://www.tuxedo.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>



Revision-number: 40
Prop-content-length: 112
Content-length: 112

K 7
svn:log
V 14
Added header.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-07-29T19:55:39.000000Z
PROPS-END

Node-path: trunk/bs.xml
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 2908
Text-content-sha1: 8117f8a7ddf2a5042ae8cc56914aa508bd801309
Content-length: 2918

PROPS-END
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>bs</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.tuxedo.org/~esr/'>http://www.tuxedo.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>



Revision-number: 41
Prop-content-length: 116
Content-length: 116

K 7
svn:log
V 18
Placed under GPL.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-07-30T12:59:03.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1204
Text-content-sha1: 75e10439fcaf94bedf400efe3163469acdd67f90
Content-length: 1214

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change
#  * the name of the containing directory
#  * the RPM spec file
VERSION=2.4

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME COPYING bs.c Makefile bs.xml bs.lsm bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
RPM = rpm
RPMFLAGS = -ba
rpm: dist
	cp bs-$(VERSION).tar.gz $(RPMROOT)/SOURCES;
	cp bs.spec $(RPMROOT)/SPECS
	cd $(RPMROOT)/SPECS; $(RPM) $(RPMFLAGS) bs.spec	
	cp $(RPMROOT)/RPMS/`arch|sed 's/i[4-9]86/i386/'`/bs-$(VERSION)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERSION)*.src.rpm .



Revision-number: 42
Prop-content-length: 104
Content-length: 104

K 7
svn:log
V 7
GPLed.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-07-30T13:02:41.000000Z
PROPS-END

Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 464
Text-content-sha1: 69497b0516a7295fcca35bcaad7f484a2c03ec2b
Content-length: 474

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.4
Release: 1
Source: locke.ccil.org:/pub/esr/bs-2.4.tar.gz
Copyright: GPL
Group: Games
%description
The classic game of Battleships agains the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs


Revision-number: 43
Prop-content-length: 111
Content-length: 111

K 7
svn:log
V 13
Corrections.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-07-30T13:57:47.000000Z
PROPS-END

Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 468
Text-content-sha1: b1512242338142cfc773a99afd6efe018d747bd7
Content-length: 478

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.4
Release: 1
Source: http://www.tuxedo.org/~esr/bs-2.4.tar.gz
Copyright: GPL
Group: Games
%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs


Revision-number: 44
Prop-content-length: 111
Content-length: 111

K 7
svn:log
V 13
Corrections.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-07-30T13:58:29.000000Z
PROPS-END

Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 489
Text-content-sha1: 9435d08e426cf523f64edfb3335418ff991538c2
Content-length: 499

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.4
Release: 1
Source: http://www.tuxedo.org/~esr/bs-2.4.tar.gz
Copyright: GPL
Group: Games
%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs
%doc READ.ME COPYING


Revision-number: 45
Prop-content-length: 80
Content-length: 80

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-07-30T13:58:29.000000Z
PROPS-END

Node-path: tags/2.4
Node-kind: dir
Node-action: add
Node-copyfrom-rev: 44
Node-copyfrom-path: trunk/
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 46
Prop-content-length: 120
Content-length: 120

K 7
svn:log
V 22
Copyright -> License.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2002-08-01T06:40:38.000000Z
PROPS-END

Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 506
Text-content-sha1: c3197a3ce3c97356f41932ad87fe62471ec3e878
Content-length: 516

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.4
Release: 1
URL: http://www.tuxedo.org/~esr/
Source0: %{name}-%{version}.tar.gz
License: GPL
Group: Games
%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs
%doc READ.ME COPYING


Revision-number: 47
Prop-content-length: 121
Content-length: 121

K 7
svn:log
V 23
Ready for 2.5 release.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2003-12-24T21:34:28.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1006
Text-content-sha1: 8120cd9f45d3e97f8cb8bf7edaceef3b071cd700
Content-length: 1016

PROPS-END
#	Makefile for bs, the Battleships game

# Note: When the version changes, you also have to change the RPM spec file
VERSION=2.5

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# Flags for use with stock curses
# TERMLIB = -lcurses
# CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME COPYING bs.c Makefile bs.xml bs.lsm bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
rpm: dist
	rpmbuild -ta bs-$(VERS).tar.gz
	cp $(RPMROOT)/RPMS/*/bs-$(VERS)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERS)*.src.rpm .



Node-path: trunk/README
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1541
Text-content-sha1: eeaea1d8e24b0b2d60b1f2ca562f7657d01179c4
Content-length: 1551

PROPS-END
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write curses games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

					Eric S. Raymond
					esr@snark.thyrsus.com
				(WWW: http://www.catb.org/~esr/home.html)


Node-path: trunk/bs.c
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 28560
Text-content-sha1: ee525d29fec7f1262cf82e4d6ff2f6d73a77309e
Content-length: 28570

PROPS-END
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 *
 * $Id: bs.c,v 1.9 2001/05/07 20:27:59 esr Exp esr $
 */

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <unistd.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#define	EXIT_SUCCESS	0
#define EXIT_FAILURE	1

static int getcoord(int);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	(isupper(c) ? TRUE : FALSE)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;			/* name of the ship type */
    int hits;			/* how many times has this ship been hit? */
    char symbol;		/* symbol for game purposes */
    int length;			/* length of ship */
    char x, y;			/* coordinates of ship start point */
    unsigned char dir;		/* direction of `bow' */
    bool placed;		/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

static ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

static ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH];
static char board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static int salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(int sig GCC_UNUSED)
/* end the game, either normally or due to signal */
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(EXIT_FAILURE);
}

static void announceopts(void)
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro(void)
{
    char *tmpname;

    srand((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

#ifdef NCURSES_MOUSE_VERSION
    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
#endif /* NCURSES_MOUSE_VERSION*/
}		    

/* VARARGS1 */
static void prompt(int n, NCURSES_CONST char *f, const char *s)
/* print a message at the prompt line */
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(NCURSES_CONST char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(int n)
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(int b, ship_t *ss)
/* generate a valid random ship placement into px,py */
{

    do {
	ss->dir = rnd(2) ? E : S;
	ss->x = rnd(BWIDTH - (ss->dir == E ? ss->length : 0));
	ss->y = rnd(BDEPTH - (ss->dir == S ? ss->length : 0));
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;

	ss = plyship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...", "");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...", "");
    (void) getch();
}

static int getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
#ifdef NCURSES_MOUSE_VERSION
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		{
		    beep();
		    continue;
		}
	    }
	    /* no fall through */
#endif /* NCURSES_MOUSE_VERSION */

	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static bool collidecheck(int b, int y, int x)
/* is this location on the selected zboard adjacent to a ship? */
{
    bool collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != FALSE)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend)
	     && IS_SHIP(board[b][xend][yend])) {
		collide = TRUE;
		break;
	    }
	}
    }
    return(collide);
}

static bool checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + (ss->length - 1) * xincr[ss->dir];
    yend = ss->y + (ss->length - 1) * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(FALSE);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(int x, int y)
/* register a hit on the targeted ship */
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if((sym = board[OTHER][x][y]) == 0)
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;
			    
			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y1, x1);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
				else
				{
				  pgoto(y1, x1);
				  (void)addch(SHOWSPLASH);
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		    else
		    {
		      pgoto(y1, x1);
#ifdef A_COLOR
		      if (has_colors())
			attron(COLOR_PAIR(COLOR_RED));
#endif /* A_COLOR */
		      (void)addch(SHOWHIT);
#ifdef A_COLOR
		      attrset(0);
#endif /* A_COLOR */
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn(void)
{
    ship_t *ss;
    bool hit;
    NCURSES_CONST char *m = NULL;

    prompt(1, "Where do you want to shoot? ", "");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.", "");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = (hit ? MARK_HIT : MARK_MISS);
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return (hit);
}

static int sgetc(const char *s)
{
    const char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(int *px, int *py)
/* random-fire routine -- implements simple diagonal-striping strategy */
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(EXIT_FAILURE);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static int cpufire(int x, int y)
/* fire away at given location */
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))) != 0)
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return ((hit ? (sunk ? S_SUNK : S_HIT) : S_MISS) ? TRUE : FALSE);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn(void)
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n;
    int hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return ((hit) ? TRUE : FALSE);
}

static
int playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(int c, char *op[])
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(EXIT_FAILURE);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = 1;
		    if (salvo == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 's':
		    salvo = 1;
		    if (blitz == 1)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 'c':
		    closepack = 1;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(EXIT_FAILURE);
		}
	    }
	}
    }
}

static int scount(int who)
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int main(int argc, char *argv[])
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    /*NOTREACHED*/
}

/* bs.c ends here */


Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 912
Text-content-sha1: 962d45d37eaa6762ce981c804e59e6a26c704fa8
Content-length: 922

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: %{myversion}
Release: 1
URL: http://www.tuxedo.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: GPL
Group: Games
%undefine __check_files

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs
%doc READ.ME COPYING

%changelog
* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.


Revision-number: 48
Prop-content-length: 145
Content-length: 145

K 7
svn:log
V 47
Get the spec version number from the makefile.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2003-12-24T21:36:02.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 892
Text-content-sha1: 911f079f9ee494fa9ed6c6aac08242c4518b94ac
Content-length: 902

PROPS-END
#	Makefile for bs, the Battleships game

VERSION=2.5

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME COPYING bs.c Makefile bs.xml bs.lsm bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
rpm: dist
	rpmbuild --define 'myversion $(VERS)' -ta bs-$(VERS).tar.gz
	cp $(RPMROOT)/RPMS/*/bs-$(VERS)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERS)*.src.rpm .



Revision-number: 49
Prop-content-length: 122
Content-length: 122

K 7
svn:log
V 24
LSM no longer a source.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2003-12-24T21:37:10.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 885
Text-content-sha1: a31aa70f71156fa8bcf2f69ed45d26bace3aad9e
Content-length: 895

PROPS-END
#	Makefile for bs, the Battleships game

VERSION=2.5

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME COPYING bs.c Makefile bs.xml bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
rpm: dist
	rpmbuild --define 'myversion $(VERS)' -ta bs-$(VERS).tar.gz
	cp $(RPMROOT)/RPMS/*/bs-$(VERS)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERS)*.src.rpm .



Revision-number: 50
Prop-content-length: 112
Content-length: 112

K 7
svn:log
V 14
Lock for 2.5.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2003-12-26T17:35:19.000000Z
PROPS-END

Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 910
Text-content-sha1: ec9f702d3cb82937f80e5edbcd7430b6c411d1cd
Content-length: 920

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: %{myversion}
Release: 1
URL: http://www.catb.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: GPL
Group: Games
%undefine __check_files

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs
%doc READ.ME COPYING

%changelog
* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.


Revision-number: 51
Prop-content-length: 80
Content-length: 80

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2003-12-26T17:35:19.000000Z
PROPS-END

Node-path: tags/2.5
Node-kind: dir
Node-action: add
Node-copyfrom-rev: 50
Node-copyfrom-path: trunk/
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 52
Prop-content-length: 124
Content-length: 124

K 7
svn:log
V 26
Version bump and cleanup.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2003-12-26T17:44:00.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 885
Text-content-sha1: b377578b37438b88fc97fa877835a3a10f8809f4
Content-length: 895

PROPS-END
#	Makefile for bs, the Battleships game

VERSION=2.6

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME COPYING bs.c Makefile bs.xml bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
rpm: dist
	rpmbuild --define 'myversion $(VERS)' -ta bs-$(VERS).tar.gz
	cp $(RPMROOT)/RPMS/*/bs-$(VERS)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERS)*.src.rpm .



Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1017
Text-content-sha1: 2a77c81030f6466ea42b59ca671aa145c9bd52d6
Content-length: 1027

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: %{myversion}
Release: 1
URL: http://www.catb.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: GPL
Group: Games
%undefine __check_files

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
make install

%files
/usr/share/man/man6/bs.6
/usr/bin/bs
%doc READ.ME COPYING

%changelog
* Fri Dec 26 2003 Eric S. Raymond <esr@snark.thyrsus.com> d2.6
- Fix a broken URL in the documentation

* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.5
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.


Node-path: trunk/bs.xml
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 2904
Text-content-sha1: ab3cd58f6282b51cc0de5eded5f7967f53c8959d
Content-length: 2914

PROPS-END
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>bs</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.catb.org/~esr/'>http://www.catb.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>



Revision-number: 53
Prop-content-length: 118
Content-length: 118

K 7
svn:log
V 20
Fix RPM production.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2003-12-26T17:45:19.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 897
Text-content-sha1: 93714b6a2ce006f93a20790b6349e12e6a660175
Content-length: 907

PROPS-END
#	Makefile for bs, the Battleships game

VERSION=2.6

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs /usr/bin
	cp bs.6 /usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = READ.ME COPYING bs.c Makefile bs.xml bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

RPMROOT=/usr/src/redhat
rpm: dist
	rpmbuild --define 'myversion $(VERSION)' -ta bs-$(VERSION).tar.gz
	cp $(RPMROOT)/RPMS/*/bs-$(VERSION)*.rpm .
	cp $(RPMROOT)/SRPMS/bs-$(VERSION)*.src.rpm .



Revision-number: 54
Prop-content-length: 80
Content-length: 80

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2003-12-26T17:45:19.000000Z
PROPS-END

Node-path: tags/2.6
Node-kind: dir
Node-action: add
Node-copyfrom-rev: 53
Node-copyfrom-path: trunk/
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 55
Prop-content-length: 119
Content-length: 119

K 7
svn:log
V 21
RPM packaging fixes.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2003-12-29T07:15:53.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 805
Text-content-sha1: bf2412e0f1fdd54c22658607f142b0f72bfb5500
Content-length: 815

PROPS-END
#	Makefile for bs, the Battleships game

VERSION=$(shell sed <bs.spec -n -e '/Version: \(.*\)/s//\1/p')

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# DESTDIR support
DESTDIR = 

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~

install: bs.6 uninstall
	cp bs $(DESTDIR)/usr/bin
	cp bs.6 $(DESTDIR)/usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = README COPYING bs.c Makefile bs.xml bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz


Node-path: trunk/README
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1532
Text-content-sha1: c3bbe78fa9c8760164b75d800ca851398461cb7d
Content-length: 1542

PROPS-END
				BS 2.0

Battleships is an intrinsically silly game, but I couldn't resist fixing this
sucker. It now has a purely visual interface (you place ships and call for
shots by moving the cursor around the board using the standard yuhjklbn keys).

The default game now disallows placement of ships so that they touch. A new
-c option is available to force the older behavior.

I also removed the `seemiss' option (now always on) and `ask' (which is only
useful for cheating). And I ifdefed out the ditsy opening screen; if you want
it back, compile with -DPENGUIN. One strike against featureitis...

The code now lints as clean as the broken SysV curses lint library will let it.

Some #ifdefs in the code should result in the right things being done for
BSD or USG systems. They key off A_UNDERLINE.  If you're using the Linux
ncurses library, tell the makefile.

This was probably a waste of a day or so. But what the hack -- rewriting the
strategy robot as an FSM was fun, and maybe the interface will set a good
example for the next guy.

<*** FLAME ON ***>

People who write curses games that require you to enter #@!!#$! coordinates
rather than doing the natural pick-and-place with cursor motions should be
stuffed in suits and condemned to write COBOL for the rest of their days...

<*** FLAME OFF ***>

O.K., I feel better now that I've got that off my chest...

November 1993: I've added function key support, and ANSI/POSIXized the code.

					Eric S. Raymond
					esr@snark.thyrsus.com
				(WWW: http://www.catb.org/~esr/)


Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1474
Text-content-sha1: 32f1a42b3cbb82b6d49b1e5d71303cfad1f07606
Content-length: 1484

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.7
Release: 1
URL: http://www.catb.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: GPL
Group: Games
BuildRoot: %{_tmppath}/%{name}-root

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make

%install
[ ! -z "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
mkdir -p "$RPM_BUILD_ROOT"/usr/bin
mkdir -p "$RPM_BUILD_ROOT"/usr/share/man/man6/
cp bs "$RPM_BUILD_ROOT"/usr/bin
cp bs.6 "$RPM_BUILD_ROOT"/usr/share/man/man6/

%clean
[ ! -z "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
%files
%defattr(-,root,root,-)
%{_mandir}/man6/bs.6*
%{_bindir}/bs
%doc README COPYING

%changelog
* Mon Dec 29 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.7-1
- Source RPMS no longer depend on myversion define.

* Fri Dec 26 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.6
- Fix a broken URL in the documentation

* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.5
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.


Revision-number: 56
Prop-content-length: 80
Content-length: 80

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2003-12-29T07:15:53.000000Z
PROPS-END

Node-path: tags/2.7
Node-kind: dir
Node-action: add
Node-copyfrom-rev: 55
Node-copyfrom-path: trunk/
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 57
Prop-content-length: 130
Content-length: 130

K 7
svn:log
V 32
Belatedly check in the license.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2010-10-13T00:07:34.000000Z
PROPS-END

Node-path: trunk/COPYING
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 17992
Text-content-sha1: dfac199a7539a404407098a2541b9482279f690d
Content-length: 18002

PROPS-END
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year  name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.


Revision-number: 58
Prop-content-length: 120
Content-length: 120

K 7
svn:log
V 22
Use bools and stdlib.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2010-10-19T10:19:17.000000Z
PROPS-END

Node-path: trunk/bs.c
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 28545
Text-content-sha1: 63b82e79a1db4c2eff06a4f31b43e63b6979bdba
Content-length: 28555

PROPS-END
/* 
 * bs.c - original author: Bruce Holloway
 *		salvo option by: Chuck A DeGaul
 * with improved user interface, autoconfiguration and code cleanup
 *		by Eric S. Raymond <esr@snark.thyrsus.com>
 */

#include <curses.h>
#include <signal.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdbool.h>

#ifndef SIGIOT
#define SIGIOT SIGABRT
#endif

#ifndef A_UNDERLINE	/* BSD curses */
#define	beep()	write(1,"\007",1);
#define	cbreak	crmode
#define	saveterm savetty
#define	resetterm resetty
#define	nocbreak nocrmode
#define strchr	index
#endif /* !A_UNDERLINE */

#define	EXIT_SUCCESS	0
#define EXIT_FAILURE	1

static int getcoord(int);

/*
 * Constants for tuning the random-fire algorithm. It prefers moves that
 * diagonal-stripe the board with a stripe separation of srchstep. If
 * no such preferred moves are found, srchstep is decremented.
 */
#define BEGINSTEP	3	/* initial value of srchstep */

/* miscellaneous constants */
#define SHIPTYPES	5
#define	OTHER		(1-turn)
#define PLAYER		0
#define COMPUTER	1
#define MARK_HIT	'H'
#define MARK_MISS	'o'
#define CTRLC		'\003'	/* used as terminate command */
#define FF		'\014'	/* used as redraw command */

/* coordinate handling */
#define BWIDTH		10
#define BDEPTH		10

/* display symbols */
#define SHOWHIT		'*'
#define SHOWSPLASH	' '
#define IS_SHIP(c)	(isupper(c) ? TRUE : FALSE)

/* how to position us on player board */
#define PYBASE	3
#define PXBASE	3
#define PY(y)	(PYBASE + (y))
#define PX(x)	(PXBASE + (x)*3)
#define pgoto(y, x)	(void)move(PY(y), PX(x))

/* how to position us on cpu board */
#define CYBASE	3
#define CXBASE	48
#define CY(y)	(CYBASE + (y))
#define CX(x)	(CXBASE + (x)*3)
#define CYINV(y)	((y) - CYBASE)
#define CXINV(x)	(((x) - CXBASE) / 3)
#define cgoto(y, x)	(void)move(CY(y), CX(x))

#define ONBOARD(x, y)	(x >= 0 && x < BWIDTH && y >= 0 && y < BDEPTH)

/* other board locations */
#define COLWIDTH	80
#define PROMPTLINE	21			/* prompt line */
#define SYBASE		CYBASE + BDEPTH + 3	/* move key diagram */
#define SXBASE		63
#define MYBASE		SYBASE - 1		/* diagram caption */
#define MXBASE		64
#define HYBASE		SYBASE - 1		/* help area */
#define HXBASE		0

/* this will need to be changed if BWIDTH changes */
static char numbers[] = "   0  1  2  3  4  5  6  7  8  9";

static char carrier[] = "Aircraft Carrier";
static char battle[] = "Battleship";
static char sub[] = "Submarine";
static char destroy[] = "Destroyer";
static char ptboat[] = "PT Boat";

static char name[40];
static char dftname[] = "stranger";

/* direction constants */
#define E	0
#define SE	1
#define S	2
#define SW	3
#define W	4
#define NW	5
#define N	6
#define NE	7
static int xincr[8] = {1,  1,  0, -1, -1, -1,  0,  1};
static int yincr[8] = {0,  1,  1,  1,  0, -1, -1, -1};

/* current ship position and direction */
static int curx = (BWIDTH / 2);
static int cury = (BDEPTH / 2);

typedef struct
{
    char *name;			/* name of the ship type */
    int hits;			/* how many times has this ship been hit? */
    char symbol;		/* symbol for game purposes */
    int length;			/* length of ship */
    char x, y;			/* coordinates of ship start point */
    unsigned char dir;		/* direction of `bow' */
    bool placed;		/* has it been placed on the board? */
}
ship_t;

static bool checkplace(int b, ship_t *ss, int vis);

static ship_t plyship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

static ship_t cpuship[SHIPTYPES] =
{
    { carrier,	0, 'A', 5},
    { battle,	0, 'B', 4},
    { destroy,	0, 'D', 3},
    { sub,	0, 'S', 3},
    { ptboat,	0, 'P', 2},
};

/* "Hits" board, and main board. */
static char hits[2][BWIDTH][BDEPTH];
static char board[2][BWIDTH][BDEPTH];

static int turn;			/* 0=player, 1=computer */
static int plywon=0, cpuwon=0;		/* How many games has each won? */

static bool salvo, blitz, closepack;

#define	PR	(void)addstr

static void uninitgame(int sig GCC_UNUSED)
/* end the game, either normally or due to signal */
{
    clear();
    (void)refresh();
    (void)resetterm();
    (void)echo();
    (void)endwin();
    exit(EXIT_FAILURE);
}

static void announceopts(void)
/* announce which game options are enabled */
{
    if (salvo || blitz || closepack)
    {
	(void) printw("Playing optional game (");
	if (salvo)
	    (void) printw("salvo, ");
	else
	    (void) printw("nosalvo, ");
	if (blitz)
	    (void) printw("blitz ");
	else
	    (void) printw("noblitz, ");
	if (closepack)
	    (void) printw("closepack)");
	else
	    (void) printw("noclosepack)");
    }
    else
	(void) printw(
	"Playing standard game (noblitz, nosalvo, noclosepack)");
}

static void intro(void)
{
    char *tmpname;

    srand((unsigned)(time(0L)+getpid()));	/* Kick the random number generator */

    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGINT,uninitgame);
    (void) signal(SIGIOT,uninitgame);		/* for assert(3) */
    if(signal(SIGQUIT,SIG_IGN) != SIG_IGN)
	(void)signal(SIGQUIT,uninitgame);

    if((tmpname = getlogin()) != 0)
    {
	(void)strcpy(name,tmpname);
	name[0] = toupper(name[0]);
    }
    else
	(void)strcpy(name,dftname);

    (void)initscr();
#ifdef KEY_MIN
    keypad(stdscr, TRUE);
#endif /* KEY_MIN */
    (void)saveterm();
    (void)nonl();
    (void)cbreak();
    (void)noecho();

#ifdef PENGUIN
    (void)clear();
    (void)mvaddstr(4,29,"Welcome to Battleship!");
    (void)move(8,0);
    PR("                                                  \\\n");
    PR("                           \\                     \\ \\\n");
    PR("                          \\ \\                   \\ \\ \\_____________\n");
    PR("                         \\ \\ \\_____________      \\ \\/            |\n");
    PR("                          \\ \\/             \\      \\/             |\n");
    PR("                           \\/               \\_____/              |__\n");
    PR("           ________________/                                       |\n");
    PR("           \\  S.S. Penguin                                         |\n");
    PR("            \\                                                     /\n");
    PR("             \\___________________________________________________/\n");

    (void) mvaddstr(22,27,"Hit any key to continue..."); (void)refresh();
    (void) getch();
#endif /* PENGUIN */

#ifdef A_COLOR
    start_color();

    init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
    init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
    init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
    init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
    init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
    init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
    init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
#endif /* A_COLOR */

#ifdef NCURSES_MOUSE_VERSION
    (void) mousemask(BUTTON1_CLICKED, (mmask_t *)NULL);
#endif /* NCURSES_MOUSE_VERSION*/
}		    

/* VARARGS1 */
static void prompt(int n, NCURSES_CONST char *f, const char *s)
/* print a message at the prompt line */
{
    (void) move(PROMPTLINE + n, 0);
    (void) clrtoeol();
    (void) printw(f, s);
    (void) refresh();
}

static void error(NCURSES_CONST char *s)
{
    (void) move(PROMPTLINE + 2, 0);
    (void) clrtoeol();
    if (s)
    {
	(void) addstr(s);
	(void) beep();
    }
}

static void placeship(int b, ship_t *ss, int vis)
{
    int l;

    for(l = 0; l < ss->length; ++l)
    {
	int newx = ss->x + l * xincr[ss->dir];
	int newy = ss->y + l * yincr[ss->dir];

	board[b][newx][newy] = ss->symbol;
	if (vis)
	{
	    pgoto(newy, newx);
	    (void) addch((chtype)ss->symbol);
	}
    }
    ss->hits = 0;
}

static int rnd(int n)
{
    return(((rand() & 0x7FFF) % n));
}

static void randomplace(int b, ship_t *ss)
/* generate a valid random ship placement into px,py */
{

    do {
	ss->dir = rnd(2) ? E : S;
	ss->x = rnd(BWIDTH - (ss->dir == E ? ss->length : 0));
	ss->y = rnd(BDEPTH - (ss->dir == S ? ss->length : 0));
    } while
	(!checkplace(b, ss, FALSE));
}

static void initgame(void)
{
    int i, j, unplaced;
    ship_t *ss;

    (void) clear();
    (void) mvaddstr(0,35,"BATTLESHIPS");
    (void) move(PROMPTLINE + 2, 0);
    announceopts();

    memset(board, 0, sizeof(char) * BWIDTH * BDEPTH * 2);
    memset(hits,  0, sizeof(char) * BWIDTH * BDEPTH * 2);
    for (i = 0; i < SHIPTYPES; i++)
    {
	ss = cpuship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;

	ss = plyship + i;

	ss->x =
	ss->y =
	ss->dir =
	ss->hits = 0;
	ss->placed = FALSE;
    }

    /* draw empty boards */
    (void) mvaddstr(PYBASE - 2, PXBASE + 5, "Main Board");
    (void) mvaddstr(PYBASE - 1, PXBASE - 3,numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(PYBASE + i, PXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }
    (void) mvaddstr(PYBASE + BDEPTH, PXBASE - 3,numbers);
    (void) mvaddstr(CYBASE - 2, CXBASE + 7,"Hit/Miss Board");
    (void) mvaddstr(CYBASE - 1, CXBASE - 3, numbers);
    for(i=0; i < BDEPTH; ++i)
    {
	(void) mvaddch(CYBASE + i, CXBASE - 3, (chtype)(i + 'A'));
#ifdef A_COLOR
	if (has_colors())
	    attron(COLOR_PAIR(COLOR_BLUE));
#endif /* A_COLOR */
	(void) addch(' ');
	for (j = 0; j < BWIDTH; j++)
	    (void) addstr(" . ");
#ifdef A_COLOR
	attrset(0);
#endif /* A_COLOR */
	(void) addch(' ');
	(void) addch((chtype)(i + 'A'));
    }

    (void) mvaddstr(CYBASE + BDEPTH,CXBASE - 3,numbers);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To position your ships: move the cursor to a spot, then");
    (void) mvprintw(HYBASE+1,HXBASE,
		    "type the first letter of a ship type to select it, then");
    (void) mvprintw(HYBASE+2,HXBASE,
		    "type a direction ([hjkl] or [4862]), indicating how the");
    (void) mvprintw(HYBASE+3,HXBASE,
		    "ship should be pointed. You may also type a ship letter");
    (void) mvprintw(HYBASE+4,HXBASE,
		    "followed by `r' to position it randomly, or type `R' to");
    (void) mvprintw(HYBASE+5,HXBASE,
		    "place all remaining ships randomly.");

    (void) mvaddstr(MYBASE,   MXBASE, "Aiming keys:");
    (void) mvaddstr(SYBASE,   SXBASE, "y k u    7 8 9");
    (void) mvaddstr(SYBASE+1, SXBASE, " \\|/      \\|/ ");
    (void) mvaddstr(SYBASE+2, SXBASE, "h-+-l    4-+-6");
    (void) mvaddstr(SYBASE+3, SXBASE, " /|\\      /|\\ ");
    (void) mvaddstr(SYBASE+4, SXBASE, "b j n    1 2 3");

    /* have the computer place ships */
    for(ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
    {
	randomplace(COMPUTER, ss);
	placeship(COMPUTER, ss, FALSE);
    }

    ss = (ship_t *)NULL;
    do {
	char c, docked[SHIPTYPES + 2], *cp = docked;

	/* figure which ships still wait to be placed */
	*cp++ = 'R';
	for (i = 0; i < SHIPTYPES; i++)
	    if (!plyship[i].placed)
		*cp++ = plyship[i].symbol;
	*cp = '\0';

	/* get a command letter */
	prompt(1, "Type one of [%s] to pick a ship.", docked+1);
	do {
	    c = getcoord(PLAYER);
	} while
	    (!strchr(docked, c));

	if (c == 'R')
	    (void) ungetch('R');
	else
	{
	    /* map that into the corresponding symbol */
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (ss->symbol == c)
		    break;

	    prompt(1, "Type one of [hjklrR] to place your %s.", ss->name);
	    pgoto(cury, curx);
	}

	do {
	    c = getch();
	} while
	    (!strchr("hjklrR", c) || c == FF);

	if (c == FF)
	{
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	}
	else if (c == 'r')
	{
	    prompt(1, "Random-placing your %s", ss->name);
	    randomplace(PLAYER, ss);
	    placeship(PLAYER, ss, TRUE);
	    error((char *)NULL);
	    ss->placed = TRUE;
	}	    
	else if (c == 'R')
	{
	    prompt(1, "Placing the rest of your fleet at random...", "");
	    for (ss = plyship; ss < plyship + SHIPTYPES; ss++)
		if (!ss->placed)
		{
		    randomplace(PLAYER, ss);
		    placeship(PLAYER, ss, TRUE);
		    ss->placed = TRUE;
		}
	    error((char *)NULL);
	}	    
	else if (strchr("hjkl8462", c))
	{
	    ss->x = curx;
	    ss->y = cury;

	    switch(c)
	    {
	    case 'k': case '8': ss->dir = N; break;
	    case 'j': case '2': ss->dir = S; break;
	    case 'h': case '4': ss->dir = W; break;
	    case 'l': case '6': ss->dir = E; break;
	    }	    

	    if (checkplace(PLAYER, ss, TRUE))
	    {
		placeship(PLAYER, ss, TRUE);
		error((char *)NULL);
		ss->placed = TRUE;
	    }
	}

	for (unplaced = i = 0; i < SHIPTYPES; i++)
	    unplaced += !plyship[i].placed;
    } while
	(unplaced);

    turn = rnd(2);

    (void) mvprintw(HYBASE,  HXBASE,
		    "To fire, move the cursor to your chosen aiming point   ");
    (void) mvprintw(HYBASE+1,  HXBASE,
		    "and strike any key other than a motion key.            ");
    (void) mvprintw(HYBASE+2,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+3,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+4,  HXBASE,
		    "                                                       ");
    (void) mvprintw(HYBASE+5,  HXBASE,
		    "                                                       ");

    (void) prompt(0, "Press any key to start...", "");
    (void) getch();
}

static int getcoord(int atcpu)
{
    int ny, nx, c;

    if (atcpu)
	cgoto(cury,curx);
    else
	pgoto(cury, curx);
    (void)refresh();
    for (;;)
    {
	if (atcpu)
	{
	    (void) mvprintw(CYBASE + BDEPTH+1, CXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    cgoto(cury, curx);
	}
	else
	{
	    (void) mvprintw(PYBASE + BDEPTH+1, PXBASE+11, "(%d, %c)", curx, 'A'+cury);
	    pgoto(cury, curx);
	}

	switch(c = getch())
	{
	case 'k': case '8':
#ifdef KEY_MIN
	case KEY_UP:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx;
	    break;
	case 'j': case '2':
#ifdef KEY_MIN
	case KEY_DOWN:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx;
	    break;
	case 'h': case '4':
#ifdef KEY_MIN
	case KEY_LEFT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+BWIDTH-1;
	    break;
	case 'l': case '6':
#ifdef KEY_MIN
	case KEY_RIGHT:
#endif /* KEY_MIN */
	    ny = cury;          nx = curx+1;
	    break;
	case 'y': case '7':
#ifdef KEY_MIN
	case KEY_A1:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+BWIDTH-1;
	    break;
	case 'b': case '1':
#ifdef KEY_MIN
	case KEY_C1:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+BWIDTH-1;
	    break;
	case 'u': case '9':
#ifdef KEY_MIN
	case KEY_A3:
#endif /* KEY_MIN */
	    ny = cury+BDEPTH-1; nx = curx+1;
	    break;
	case 'n': case '3':
#ifdef KEY_MIN
	case KEY_C3:
#endif /* KEY_MIN */
	    ny = cury+1;        nx = curx+1;
	    break;
	case FF:
	    nx = curx; ny = cury;
	    (void)clearok(stdscr, TRUE);
	    (void)refresh();
	    break;
#ifdef NCURSES_MOUSE_VERSION
	case KEY_MOUSE:
	    {
		MEVENT	myevent;

		getmouse(&myevent);
		if (atcpu
			&& myevent.y >= CY(0) && myevent.y <= CY(BDEPTH)
			&& myevent.x >= CX(0) && myevent.x <= CX(BDEPTH))
		{
		    curx = CXINV(myevent.x);
		    cury = CYINV(myevent.y);
		    return(' ');
		}
		else
		{
		    beep();
		    continue;
		}
	    }
	    /* no fall through */
#endif /* NCURSES_MOUSE_VERSION */

	default:
	    if (atcpu)
		(void) mvaddstr(CYBASE + BDEPTH + 1, CXBASE + 11, "      ");
	    else
		(void) mvaddstr(PYBASE + BDEPTH + 1, PXBASE + 11, "      ");
	    return(c);
	}

	curx = nx % BWIDTH;
	cury = ny % BDEPTH;
    }
}

static bool collidecheck(int b, int y, int x)
/* is this location on the selected zboard adjacent to a ship? */
{
    bool collide;

    /* anything on the square */
    if ((collide = IS_SHIP(board[b][x][y])) != FALSE)
	return(collide);

    /* anything on the neighbors */
    if (!closepack)
    {
	int i;

	for (i = 0; i < 8; i++)
	{
	    int xend, yend;

	    yend = y + yincr[i];
	    xend = x + xincr[i];
	    if (ONBOARD(xend, yend)
	     && IS_SHIP(board[b][xend][yend])) {
		collide = TRUE;
		break;
	    }
	}
    }
    return(collide);
}

static bool checkplace(int b, ship_t *ss, int vis)
{
    int l, xend, yend;

    /* first, check for board edges */
    xend = ss->x + (ss->length - 1) * xincr[ss->dir];
    yend = ss->y + (ss->length - 1) * yincr[ss->dir];
    if (!ONBOARD(xend, yend))
    {
	if (vis)
	    switch(rnd(3))
	    {
	    case 0:
		error("Ship is hanging from the edge of the world");
		break;
	    case 1:
		error("Try fitting it on the board");
		break;
	    case 2:
		error("Figure I won't find it if you put it there?");
		break;
	    }
	return(FALSE);
    }

    for(l = 0; l < ss->length; ++l)
    {
	if(collidecheck(b, ss->y+l*yincr[ss->dir], ss->x+l*xincr[ss->dir]))
	{
	    if (vis)
		switch(rnd(3))
		{
		    case 0:
			error("There's already a ship there");
			break;
		    case 1:
			error("Collision alert!  Aaaaaagh!");
			break;
		    case 2:
			error("Er, Admiral, what about the other ship?");
			break;
		    }
	    return(FALSE);
	    }
	}
    return(TRUE);
}

static int awinna(void)
{
    int i, j;
    ship_t *ss;

    for(i=0; i<2; ++i)
    {
	ss = (i) ? cpuship : plyship;
	for(j=0; j < SHIPTYPES; ++j, ++ss)
	    if(ss->length > ss->hits)
		break;
	if (j == SHIPTYPES)
	    return(OTHER);
    }
    return(-1);
}

static ship_t *hitship(int x, int y)
/* register a hit on the targeted ship */
{
    ship_t *sb, *ss;
    char sym;
    int oldx, oldy;

    getyx(stdscr, oldy, oldx);
    sb = (turn) ? plyship : cpuship;
    if((sym = board[OTHER][x][y]) == 0)
	return((ship_t *)NULL);
    for(ss = sb; ss < sb + SHIPTYPES; ++ss)
	if(ss->symbol == sym)
	{
	    if (++ss->hits < ss->length)	/* still afloat? */
		return((ship_t *)NULL);
	    else				/* sunk! */
	    {
		int i, j;

		if (!closepack)
		    for (j = -1; j <= 1; j++)
		    {
			int bx = ss->x + j * xincr[(ss->dir + 2) % 8];
			int by = ss->y + j * yincr[(ss->dir + 2) % 8];

			for (i = -1; i <= ss->length; ++i)
			{
			    int x1, y1;
			    
			    x1 = bx + i * xincr[ss->dir];
			    y1 = by + i * yincr[ss->dir];
			    if (ONBOARD(x1, y1))
			    {
				hits[turn][x1][y1] = MARK_MISS;
				if (turn % 2 == PLAYER)
				{
				    cgoto(y1, x1);
#ifdef A_COLOR
				    if (has_colors())
					attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
				    (void)addch(MARK_MISS);
#ifdef A_COLOR
				    attrset(0);
#endif /* A_COLOR */
				}
				else
				{
				  pgoto(y1, x1);
				  (void)addch(SHOWSPLASH);
				}
			    }
			}
		    }

		for (i = 0; i < ss->length; ++i)
		{
		    int x1 = ss->x + i * xincr[ss->dir];
		    int y1 = ss->y + i * yincr[ss->dir];

		    hits[turn][x1][y1] = ss->symbol;
		    if (turn % 2 == PLAYER)
		    {
			cgoto(y1, x1);
			(void) addch((chtype)(ss->symbol));
		    }
		    else
		    {
		      pgoto(y1, x1);
#ifdef A_COLOR
		      if (has_colors())
			attron(COLOR_PAIR(COLOR_RED));
#endif /* A_COLOR */
		      (void)addch(SHOWHIT);
#ifdef A_COLOR
		      attrset(0);
#endif /* A_COLOR */
		    }
		}

		(void) move(oldy, oldx);
		return(ss);
	    }
	}
    (void) move(oldy, oldx);
    return((ship_t *)NULL);
}

static int plyturn(void)
{
    ship_t *ss;
    bool hit;
    NCURSES_CONST char *m = NULL;

    prompt(1, "Where do you want to shoot? ", "");
    for (;;)
    {
	(void) getcoord(COMPUTER);
	if (hits[PLAYER][curx][cury])
	{
	    prompt(1, "You shelled this spot already! Try again.", "");
	    beep();
	}
	else
	    break;
    }
    hit = IS_SHIP(board[COMPUTER][curx][cury]);
    hits[PLAYER][curx][cury] = (hit ? MARK_HIT : MARK_MISS);
    cgoto(cury, curx);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void) addch((chtype)hits[PLAYER][curx][cury]);
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    prompt(1, "You %s.", hit ? "scored a hit" : "missed");
    if(hit && (ss = hitship(curx, cury)))
    {
	switch(rnd(5))
	{
	case 0:
	    m = " You sank my %s!";
	    break;
	case 1:
	    m = " I have this sinking feeling about my %s....";
	    break;
	case 2:
	    m = " My %s has gone to Davy Jones's locker!";
	    break;
	case 3:
	    m = " Glub, glub -- my %s is headed for the bottom!";
	    break;
	case 4:
	    m = " You'll pick up survivors from my %s, I hope...!";
	    break;
	}
	(void)printw(m, ss->name);
	(void)beep();
	return(awinna() == -1);
    }
    return (hit);
}

static int sgetc(const char *s)
{
    const char *s1;
    int ch;

    (void)refresh();
    for(;;)
    {
	ch = getch();
	if (islower(ch))
	    ch = toupper(ch);
	if (ch == CTRLC)
	    uninitgame(0);
	for (s1=s; *s1 && ch != *s1; ++s1)
	    continue;
	if (*s1)
	{
	    (void) addch((chtype)ch);
	    (void)refresh();
	    return(ch);
	    }
	}
}


static void randomfire(int *px, int *py)
/* random-fire routine -- implements simple diagonal-striping strategy */
{
    static int turncount = 0;
    static int srchstep = BEGINSTEP;
    static int huntoffs;		/* Offset on search strategy */
    int ypossible[BWIDTH * BDEPTH], xpossible[BWIDTH * BDEPTH], nposs;
    int ypreferred[BWIDTH * BDEPTH], xpreferred[BWIDTH * BDEPTH], npref;
    int x, y, i;

    if (turncount++ == 0)
	huntoffs = rnd(srchstep);

    /* first, list all possible moves */
    nposs = npref = 0;
    for (x = 0; x < BWIDTH; x++)
	for (y = 0; y < BDEPTH; y++)
	    if (!hits[COMPUTER][x][y])
	    {
		xpossible[nposs] = x;
		ypossible[nposs] = y;
		nposs++;
		if (((x+huntoffs) % srchstep) != (y % srchstep))
		{
		    xpreferred[npref] = x;
		    ypreferred[npref] = y;
		    npref++;
		}
	    }

    if (npref)
    {
	i = rnd(npref);

	*px = xpreferred[i];
	*py = ypreferred[i];
    }
    else if (nposs)
    {
	i = rnd(nposs);

	*px = xpossible[i];
	*py = ypossible[i];

	if (srchstep > 1)
	    --srchstep;
    }
    else
    {
	error("No moves possible?? Help!");
	exit(EXIT_FAILURE);
	/*NOTREACHED*/
    }
}

#define S_MISS	0
#define S_HIT	1
#define S_SUNK	-1

static int cpufire(int x, int y)
/* fire away at given location */
{
    bool hit, sunk;
    ship_t *ss = NULL;

    hits[COMPUTER][x][y] = (hit = (board[PLAYER][x][y])) ? MARK_HIT : MARK_MISS;
    (void) mvprintw(PROMPTLINE, 0,
	"I shoot at %c%d. I %s!", y + 'A', x, hit ? "hit" : "miss");
    if ((sunk = (hit && (ss = hitship(x, y)))) != 0)
	(void) printw(" I've sunk your %s", ss->name);
    (void)clrtoeol();

    pgoto(y, x);
#ifdef A_COLOR
    if (has_colors())
	if (hit)
	    attron(COLOR_PAIR(COLOR_RED));
	else
	    attron(COLOR_PAIR(COLOR_GREEN));
#endif /* A_COLOR */
    (void)addch((chtype)(hit ? SHOWHIT : SHOWSPLASH));
#ifdef A_COLOR
    attrset(0);
#endif /* A_COLOR */

    return ((hit ? (sunk ? S_SUNK : S_HIT) : S_MISS) ? TRUE : FALSE);
}

/*
 * This code implements a fairly irregular FSM, so please forgive the rampant
 * unstructuredness below. The five labels are states which need to be held
 * between computer turns.
 */
static bool cputurn(void)
{
#define POSSIBLE(x, y)	(ONBOARD(x, y) && !hits[COMPUTER][x][y])
#define RANDOM_FIRE	0
#define RANDOM_HIT	1
#define HUNT_DIRECT	2
#define FIRST_PASS	3
#define REVERSE_JUMP	4
#define SECOND_PASS	5
    static int next = RANDOM_FIRE;
    static bool used[4];
    static ship_t ts;
    int navail, x, y, d, n;
    int hit = S_MISS;

    switch(next)
    {
    case RANDOM_FIRE:	/* last shot was random and missed */
    refire:
	randomfire(&x, &y);
	if (!(hit = cpufire(x, y)))
	    next = RANDOM_FIRE;
	else
	{
	    ts.x = x; ts.y = y;
	    ts.hits = 1;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : RANDOM_HIT;
	}
	break;

    case RANDOM_HIT:	/* last shot was random and hit */
	used[E/2] = used[S/2] = used[W/2] = used[N/2] = FALSE;
	/* FALLTHROUGH */

    case HUNT_DIRECT:	/* last shot hit, we're looking for ship's long axis */
	for (d = navail = 0; d < 4; d++)
	{
	    x = ts.x + xincr[d*2]; y = ts.y + yincr[d*2];
	    if (!used[d] && POSSIBLE(x, y))
		navail++;
	    else
		used[d] = TRUE;
	}
	if (navail == 0)	/* no valid places for shots adjacent... */
	    goto refire;	/* ...so we must random-fire */
	else
	{
	    for (d = 0, n = rnd(navail) + 1; n; n--)
		while (used[d])
		    d++;

	    assert(d <= 4);

	    used[d] = FALSE;
	    x = ts.x + xincr[d*2];
	    y = ts.y + yincr[d*2];

	    assert(POSSIBLE(x, y));

	    if (!(hit = cpufire(x, y)))
		next = HUNT_DIRECT;
	    else
	    {
		ts.x = x; ts.y = y; ts.dir = d*2; ts.hits++;
		next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	    }
	}
	break;

    case FIRST_PASS:	/* we have a start and a direction now */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : FIRST_PASS;
	}
	else
	    next = REVERSE_JUMP;
	break;

    case REVERSE_JUMP:	/* nail down the ship's other end */
	d = ts.dir + 4;
	x = ts.x + ts.hits * xincr[d];
	y = ts.y + ts.hits * yincr[d];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.dir = d; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE : SECOND_PASS;
	}
	else
	    next = RANDOM_FIRE;
	break;

    case SECOND_PASS:	/* kill squares not caught on first pass */
	x = ts.x + xincr[ts.dir];
	y = ts.y + yincr[ts.dir];
	if (POSSIBLE(x, y) && (hit = cpufire(x, y)))
	{
	    ts.x = x; ts.y = y; ts.hits++;
	    next = (hit == S_SUNK) ? RANDOM_FIRE: SECOND_PASS;
	    break;
	}
	else
	    next = RANDOM_FIRE;
	break;
    }

    /* check for continuation and/or winner */
    if (salvo)
    {
	(void)refresh();
	(void)sleep(1);
    }
    if (awinna() != -1)
	return(FALSE);

#ifdef DEBUG
    (void) mvprintw(PROMPTLINE + 2, 0,
		    "New state %d, x=%d, y=%d, d=%d",
		    next, x, y, d);
#endif /* DEBUG */
    return ((hit) ? TRUE : FALSE);
}

static
int playagain(void)
{
    int j;
    ship_t *ss;

    for (ss = cpuship; ss < cpuship + SHIPTYPES; ss++)
	for(j = 0; j < ss->length; j++)
	{
	    cgoto(ss->y + j * yincr[ss->dir], ss->x + j * xincr[ss->dir]);
	    (void)addch((chtype)ss->symbol);
	}

    if(awinna())
	++cpuwon;
    else
	++plywon;
    j = 18 + strlen(name);
    if(plywon >= 10)
	++j;
    if(cpuwon >= 10)
	++j;
    (void) mvprintw(1,(COLWIDTH-j)/2,
		    "%s: %d     Computer: %d",name,plywon,cpuwon);

    prompt(2, (awinna()) ? "Want to be humiliated again, %s [yn]? "
	   : "Going to give me a chance for revenge, %s [yn]? ",name);
    return(sgetc("YN") == 'Y');
}

static void do_options(int c, char *op[])
{
    register int i;

    if (c > 1)
    {
	for (i=1; i<c; i++)
	{
	    switch(op[i][0])
	    {
	    default:
	    case '?':
		(void) fprintf(stderr, "Usage: battle [-s | -b] [-c]\n");
		(void) fprintf(stderr, "\tWhere the options are:\n");
		(void) fprintf(stderr, "\t-s : play a salvo game\n");
		(void) fprintf(stderr, "\t-b : play a blitz game\n");
		(void) fprintf(stderr, "\t-c : ships may be adjacent\n");
		exit(EXIT_FAILURE);
		break;
	    case '-':
		switch(op[i][1])
		{
		case 'b':
		    blitz = true;
		    if (salvo)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -b and -s are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 's':
		    salvo = true;
		    if (blitz)
		    {
			(void) fprintf(stderr,
				"Bad Arg: -s and -b are mutually exclusive\n");
			exit(EXIT_FAILURE);
		    }
		    break;
		case 'c':
		    closepack = true;
		    break;
		default:
		    (void) fprintf(stderr,
			    "Bad arg: type \"%s ?\" for usage message\n", op[0]);
		    exit(EXIT_FAILURE);
		}
	    }
	}
    }
}

static int scount(int who)
{
    register int i, shots;
    register ship_t *sp;

    if (who)
	sp = cpuship;	/* count cpu shots */
    else
	sp = plyship;	/* count player shots */

    for (i=0, shots = 0; i < SHIPTYPES; i++, sp++)
    {
	if (sp->hits >= sp->length)
	    continue;		/* dead ship */
	else
	    shots++;
    }
    return(shots);
}

int main(int argc, char *argv[])
{
    do_options(argc, argv);

    intro();
    do {
	initgame();
	while(awinna() == -1)
	{
	    if (!blitz)
	    {
		if (!salvo)
		{
	    	    if(turn)
			(void) cputurn();
		    else
			(void) plyturn();
		}
		else
		{
		    register int i;

		    i = scount(turn);
		    while (i--)
		    {
			if (turn)
			{
			    if (cputurn() && awinna() != -1)
				i = 0;
			}
			else
			{
			    if (plyturn() && awinna() != -1)
				i = 0;
			}
		    }
		} 
	    }
	    else
	    	while(turn ? cputurn() : plyturn())
		    continue;
	    turn = OTHER;
	}
    } while
	(playagain());
    uninitgame(0);
    /*NOTREACHED*/
}

/* bs.c ends here */


Revision-number: 59
Prop-content-length: 127
Content-length: 127

K 7
svn:log
V 29
Ignore some generated stuff.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2010-10-19T10:24:15.000000Z
PROPS-END

Node-path: trunk
Node-kind: dir
Node-action: change
Prop-content-length: 49
Content-length: 49

K 10
svn:ignore
V 17
bs
*~
*.html
*.6

PROPS-END


Revision-number: 60
Prop-content-length: 118
Content-length: 118

K 7
svn:log
V 20
Update the history.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2010-10-19T10:26:46.000000Z
PROPS-END

Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1623
Text-content-sha1: b319989d409846a84f84a499924cbfbb319b1ca0
Content-length: 1633

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.8
Release: 1
URL: http://www.catb.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: GPL
Group: Games
BuildRoot: %{_tmppath}/%{name}-root
#Project-Tag-List: battleships, game, solitaire

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make %{?_smp_mflags} bs bs.6

%install
[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
mkdir -p "$RPM_BUILD_ROOT"%{_bindir}
mkdir -p "$RPM_BUILD_ROOT"%{_mandir}/man6/
cp bs "$RPM_BUILD_ROOT"%{_bindir}
cp bs.6 "$RPM_BUILD_ROOT"%{_mandir}/man6/

%clean
[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
%files
%defattr(-,root,root,-)
%{_mandir}/man6/bs.6*
%{_bindir}/bs
%doc README COPYING

%changelog
* Tue Oct 19 2010 Eric S. Raymond <esr@snark.thyrsus.com> 2.8-1
- Port to modern C.

* Mon Dec 29 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.7-1
- Source RPMS no longer depend on --define myversion.

* Fri Dec 26 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.6-1
- Fix a broken URL in the documentation

* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.5-1
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.


Revision-number: 61
Prop-content-length: 115
Content-length: 115

K 7
svn:log
V 17
Ignore MANIFEST.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2010-10-19T10:27:55.000000Z
PROPS-END

Node-path: trunk
Node-kind: dir
Node-action: change
Prop-content-length: 58
Content-length: 58

K 10
svn:ignore
V 26
bs
*~
*.html
*.6
MANIFEST

PROPS-END


Revision-number: 62
Prop-content-length: 131
Content-length: 131

K 7
svn:log
V 33
Adapt for new shipper machinery.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2010-10-19T10:29:32.000000Z
PROPS-END

Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 892
Text-content-sha1: 2736172bad9da69f3d55fea631d4c7603b3a6030
Content-length: 902

PROPS-END
#	Makefile for bs, the Battleships game

VERSION=$(shell sed <bs.spec -n -e '/Version: \(.*\)/s//\1/p')

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# DESTDIR support
DESTDIR = 

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~ *.html SHIPPER.*

install: bs.6 uninstall
	cp bs $(DESTDIR)/usr/bin
	cp bs.6 $(DESTDIR)/usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = README COPYING bs.c Makefile bs.xml bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

release: bs-$(VERSION).tar.gz bs.html
	shipper -u -m -t; make clean



Revision-number: 63
Prop-content-length: 130
Content-length: 130

K 7
svn:log
V 32
Suppress some warning messages.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2010-10-19T10:32:15.000000Z
PROPS-END

Node-path: trunk/bs.xml
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 3047
Text-content-sha1: c6971a0040ff8823137ae1626cc801d806337df9
Content-length: 3057

PROPS-END
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='bs.6'>
<refmeta>
<refentrytitle>bs</refentrytitle>
<manvolnum>6</manvolnum>
<refmiscinfo class='date'>Nov 15 1993</refmiscinfo>
<refmiscinfo class='manual'>Games</refmiscinfo>
<refmiscinfo class='source'>bs</refmiscinfo>
<refmiscinfo class='productname'>bs</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>bs</refname>
<refpurpose>battleships game</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <!-- bs  [  \-b  |  \-s  ]   [  \-c  ]  -->
  <command>bs</command>  <group choice='opt'><arg choice='plain'>-b </arg><arg choice='plain'>-s </arg></group>
  <arg choice='opt'>-c </arg>
</cmdsynopsis>

</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>This program allows you to play the familiar Battleships game
against the computer on a 10x10 board. The interface is visual and
largely self-explanatory; you place your ships and pick your shots by
moving the cursor around the `sea' with the rogue/hack motion keys
hjklyubn.  If your UNIX has a modern (non-BSD) curses, your arrow keys
will also work.</para>

<para>Note that when selecting a ship to place, you must type the
capital letter (these are, after all, capital ships). During ship
placement, the `r' command may be used to ignore the current position
and randomly place your currently selected ship. The `R' command will
place all remaining ships randomly. The ^L command (form feed, ASCII
12) will force a screen redraw).</para>

<para>The command-line arguments control game modes. </para>

<literallayout remap='.nf'>
	-b selects a `blitz' variant
	-s selects a `salvo' variant
	-c permits ships to be placed adjacently
</literallayout> <!-- .fi -->

<para>The `blitz' variant allows a side to shoot for as long as it continues to
score hits.</para>

<para>The `salvo' game allows a player one shot per turn for each of
his/her ships still afloat.  This puts a premium scoring hits early
and knocking out some ships and also makes much harder the situation
where you face a superior force with only your PT-boat.</para>

<para>Normally, ships must be separated by at least one square of open
water. The -c option disables this check and allows them to
close-pack.</para>

<para>The algorithm the computer uses once it has found a ship to sink
is provably optimal.  The dispersion criterion for the random-fire
algorithm may not be.</para> 
</refsect1>

<refsect1 id='authors'><title>AUTHORS</title>

<para>Originally written by one Bruce Holloway in 1986. Salvo mode
added by Chuck A.  DeGaul (cbosgd!cad). Visual user interface,
`closepack' option, code rewrite and manual page by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt; August 1989.  Keypad support and
ANSI/POSIX conformance, November '93.  See <ulink
url='http://www.catb.org/~esr/'>http://www.catb.org/~esr/</ulink>
for updates, also other software and resources by ESR.</para>

</refsect1>
</refentry>



Revision-number: 64
Prop-content-length: 130
Content-length: 130

K 7
svn:log
V 32
Tagged for external release 2.8

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2010-10-19T10:33:58.000000Z
PROPS-END

Node-path: tags/2.8
Node-kind: dir
Node-action: add
Node-copyfrom-rev: 63
Node-copyfrom-path: trunk/
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 65
Prop-content-length: 121
Content-length: 121

K 7
svn:log
V 23
Change license to BSD.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2010-10-19T11:12:51.000000Z
PROPS-END

Node-path: trunk/COPYING
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1421
Text-content-sha1: a69c5345946705001618795284ea60f8f6971a51
Content-length: 1431

PROPS-END
			BSD LICENSE

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

Neither name of the this project nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


Node-path: trunk/Makefile
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 936
Text-content-sha1: dec740119c2357834bfdb9a21b7b6be4421b7a90
Content-length: 946

PROPS-END
#	Makefile for bs, the Battleships game

VERSION=$(shell sed <bs.spec -n -e '/Version: \(.*\)/s//\1/p')

# Flags for use with the Linux ncurses package (recommended)
TERMLIB = -lncurses
CC = gcc

# DESTDIR support
DESTDIR = 

bs: bs.c
	$(CC) $(CFLAGS) -o bs bs.c $(TERMLIB)

bs.6: bs.xml
	xmlto man bs.xml
bs.html: bs.xml
	xmlto html-nochunks bs.xml

clean:
	rm -f bs bs.6 bs*.tar.gz bs*.rpm *~ *.html SHIPPER.*

install: bs.6 uninstall
	cp bs $(DESTDIR)/usr/bin
	cp bs.6 $(DESTDIR)/usr/share/man/man6/bs.6

uninstall:
	rm -f /usr/bin/bs /usr/share/man/man6/bs.6

SOURCES = README COPYING bs.c Makefile bs.xml bs.spec

bs-$(VERSION).tar.gz: $(SOURCES) bs.6
	@ls $(SOURCES) bs.6 | sed s:^:bs-$(VERSION)/: >MANIFEST
	@(cd ..; ln -s bs bs-$(VERSION))
	(cd ..; tar -czvf bs/bs-$(VERSION).tar.gz `cat bs/MANIFEST`)
	@(cd ..; rm bs-$(VERSION))

dist: bs-$(VERSION).tar.gz

release: bs-$(VERSION).tar.gz bs.html
	shipper -u -m -t; make clean



Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1623
Text-content-sha1: 15e534be922863879045e0f77cbb63442d41ceab
Content-length: 1633

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.9
Release: 1
URL: http://www.catb.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: BSD
Group: Games
BuildRoot: %{_tmppath}/%{name}-root
#Project-Tag-List: battleships, game, solitaire

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make %{?_smp_mflags} bs bs.6

%install
[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
mkdir -p "$RPM_BUILD_ROOT"%{_bindir}
mkdir -p "$RPM_BUILD_ROOT"%{_mandir}/man6/
cp bs "$RPM_BUILD_ROOT"%{_bindir}
cp bs.6 "$RPM_BUILD_ROOT"%{_mandir}/man6/

%clean
[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
%files
%defattr(-,root,root,-)
%{_mandir}/man6/bs.6*
%{_bindir}/bs
%doc README COPYING

%changelog
* Tue Oct 19 2010 Eric S. Raymond <esr@snark.thyrsus.com> 2.8-1
- Port to modern C.

* Mon Dec 29 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.7-1
- Source RPMS no longer depend on --define myversion.

* Fri Dec 26 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.6-1
- Fix a broken URL in the documentation

* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.5-1
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.


Revision-number: 66
Prop-content-length: 140
Content-length: 140

K 7
svn:log
V 42
Be explicit about releasing to freshmeat.

K 10
svn:author
V 3
esr
K 8
svn:date
V 27
2010-11-29T02:33:05.000000Z
PROPS-END

Node-path: trunk/bs.spec
Node-kind: file
Node-action: change
Prop-content-length: 10
Text-content-length: 1648
Text-content-sha1: 538d38a5a50693e2d77d22c322cc75ab4b7d814d
Content-length: 1658

PROPS-END
Name: bs
Summary: Battleships against the computer (character-cell graphics)
Version: 2.9
Release: 1
URL: http://www.catb.org/~esr/bs/
Source0: %{name}-%{version}.tar.gz
License: BSD
Group: Games
BuildRoot: %{_tmppath}/%{name}-root
#Destinations: freshmeat
#Project-Tag-List: battleships, game, solitaire

%description
The classic game of Battleships against the computer.
Uses character-cell graphics with a visual point-and-shoot interface.
If you're using an xterm under Linux the mouse will work.

%prep
%setup

%build
make %{?_smp_mflags} bs bs.6

%install
[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
mkdir -p "$RPM_BUILD_ROOT"%{_bindir}
mkdir -p "$RPM_BUILD_ROOT"%{_mandir}/man6/
cp bs "$RPM_BUILD_ROOT"%{_bindir}
cp bs.6 "$RPM_BUILD_ROOT"%{_mandir}/man6/

%clean
[ "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf "$RPM_BUILD_ROOT"
%files
%defattr(-,root,root,-)
%{_mandir}/man6/bs.6*
%{_bindir}/bs
%doc README COPYING

%changelog
* Tue Oct 19 2010 Eric S. Raymond <esr@snark.thyrsus.com> 2.8-1
- Port to modern C.

* Mon Dec 29 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.7-1
- Source RPMS no longer depend on --define myversion.

* Fri Dec 26 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.6-1
- Fix a broken URL in the documentation

* Wed Dec 24 2003 Eric S. Raymond <esr@snark.thyrsus.com> 2.5-1
- Improved packaging.

 * v1.2 with color support and minor portability fixes, November 1990
 * v2.0 featuring strict ANSI/POSIX conformance, November 1993.
 * v2.1 with ncurses mouse support, September 1995
 * v2.2 code cleanup.
 * v2.3 bug fixes by Erik Sigra.
 * v2.4 Update the RPM production.


