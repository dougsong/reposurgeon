#!/bin/bash
#
##repobench - generate or render reposurgeon profiling results
##
## usage: repobench [-h] [-p datafile] [-o datafile] [-m datafiles] [-s runtime|rss|memory] [dumpfile min step max]

datfile=""
display=no
merge=no
style=runtime
while getopts hmops: opt
do
    case $opt in
	m) merge=yes;;
	o) display=yes; svg=yes;;
	p) display=yes; svg=no;;
	s) style=$OPTARG;;
	*) grep '^##' "${0}" | sed -e 's/##//'
	   exit 0;;
    esac
done
shift $((OPTIND - 1))

reposurgeon="$(dirname "${0}")/reposurgeon"

if [ $# = 4 ] && [ $merge = no ]
then
	function run {
	    datfile="${1}"	# The output benchmark data
	    logfile="${2}"	# The logfile for the conversion
	    dump="${3}"	# The dump to be read in
	    readlimit="${4}"	# The nmber of revisions to read
	    # %e = CPU real time
	    # %M = maximum resident set size of the process in KB
	    # %K = average total (data+stack+text) memory use in KB
	    /usr/bin/time -f "${readlimit} %e %M %K" -a -o "${datfile}" \
			  "${reposurgeon}" "logfile ${logfile}" \
					   "readlimit ${readlimit}" \
					   "read <${dump}"
	}

	dump="${1}"
	min="${2}"
	step="${3}"
	max="${4}"
	rev="$(git describe HEAD)"
	datfile="$(basename "${dump}")_${rev}.dat"
	logfile="$(basename "${dump}")_${rev}_${readlimit}.log"
	for readlimit in $(seq "${min}" "${step}" "${max}"); do
	    # Flush all disk VM caches so the data file has to be reread
	    sudo sh -c 'echo 3 >/proc/sys/vm/drop_caches'
	    run "${datfile}" "${logfile}" "${dump}" "${readlimit}"
	done
	echo "Results are in ${datfile}"
fi

if [ $display = yes ]
then
    datfile=${datfile:-$1}
    case $style in
	runtime)
	    cat >/tmp/plotme$$ <<EOF
set key top lmargin
set xlabel "number of SVN revisions read in by reposurgeon"
set ylabel "runtime"
f(x) = a*x + b
g(x) = c*x**2 + d*x + e
fit f(x) file using 1:2 via a,b
fit g(x) file using 1:2 via c,d,e
plot file u 1:2 title "memory usage" lw 2, \
     f(x) title "linear fit" lw 2, \
     g(x) title "quadratic fit" lw 2
EOF
	    ;;
	rss)
	    cat >/tmp/plotme$$ <<EOF
set key top lmargin
set xlabel "number of SVN revisions read in by reposurgeon"
set ylabel "RSS"
f(x) = a*x + b
g(x) = c*x**2 + d*x + e
fit f(x) file using 1:3 via a,b
fit g(x) file using 1:3 via c,d,e
plot file u 1:3 title "memory (max RSS)" lw 2, \
     f(x) title "linear fit" lw 2, \
     g(x) title "quadratic fit" lw 2
EOF
	    ;;
	memory)
	    cat >/tmp/plotme$$ <<EOF
set key top lmargin
set xlabel "number of SVN revisions read in by reposurgeon"
set ylabel "average total memory"
f(x) = a*x + b
g(x) = c*x**2 + d*x + e
fit f(x) file using 1:4 via a,b
fit g(x) file using 1:4 via c,d,e
plot file u 1:4 title "memory (average of total)" lw 2, \
     f(x) title "linear fit" lw 2, \
     g(x) title "quadratic fit" lw 2
EOF
	    ;;
	*)
	    echo "Unknown plot type $style" >&2
	    exit 1
	    ;;
    esac

    # The actual plotting
    if [ $svg = yes ]
    then
	# You could use the non-SVG mode to view the graph, and then
	# use the viewer to save an svg file. However, that has some
	# drawbacks; in particular the size of the graph will be fixed
	# rather than dynamic, which means that it won't resize to
	# your browser window.
	name="${style} from ${datfile}"
	gnuplot --persist -e "file='${datfile}'; set terminal svg size 1920,1080 dynamic name '${name}'" /tmp/plotme$$
    else
	gnuplot --persist -e "file='${datfile}'" /tmp/plotme$$ -
    fi
    rm -f /tmp/plotme$$
fi

if [ $merge = yes ]
then
    # We have: Multiple benchmark-data files corresponding to diffrent
    # revisions.  We want: A merged plot extracting a selected statistic
    # from all of them for comparative graphing, as GNUPLOT code on stdout.
    python <<EOF
alldata = []
keys = set([])

runtime = 1
rss = 2
memory = 3

for i, fn in enumerate("$*".split()):
    data = []
    with open(fn) as fp:
        for line in fp:
            fields = line.split()
            keys.add(fields[0])
            data.append((fields[0], fields[$style]))
    alldata.append(data)
    print(alldata)
EOF
fi

# end
